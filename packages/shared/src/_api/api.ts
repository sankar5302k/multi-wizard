/* tslint:disable */
/* eslint-disable */
/**
 * Micro Store API
 * Open API documentation for Rebel Micro Store project
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AWSHeadObjectNotFoundError
 */
export interface AWSHeadObjectNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof AWSHeadObjectNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof AWSHeadObjectNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface AWSObjectNotFoundError
 */
export interface AWSObjectNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof AWSObjectNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof AWSObjectNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ActiveProductsCountForProgramResponse
 */
export interface ActiveProductsCountForProgramResponse {
    /**
     * 
     * @type {number}
     * @memberof ActiveProductsCountForProgramResponse
     */
    activeProductsCount: number;
}
/**
 * 
 * @export
 * @interface ActiveProductsCountResponse
 */
export interface ActiveProductsCountResponse {
    /**
     * 
     * @type {number}
     * @memberof ActiveProductsCountResponse
     */
    activeProductsCount: number;
}
/**
 * 
 * @export
 * @interface ActiveProgramsCountResponse
 */
export interface ActiveProgramsCountResponse {
    /**
     * 
     * @type {number}
     * @memberof ActiveProgramsCountResponse
     */
    activeProgramsCount: number;
}
/**
 * 
 * @export
 * @interface ActiveUsersCountForProgramResponse
 */
export interface ActiveUsersCountForProgramResponse {
    /**
     * 
     * @type {number}
     * @memberof ActiveUsersCountForProgramResponse
     */
    activeUsersCount: number;
}
/**
 * 
 * @export
 * @interface AddCartItemDTO
 */
export interface AddCartItemDTO {
    /**
     * 
     * @type {string}
     * @memberof AddCartItemDTO
     */
    programProductId: string;
    /**
     * 
     * @type {string}
     * @memberof AddCartItemDTO
     */
    inventorySku: string;
    /**
     * 
     * @type {number}
     * @memberof AddCartItemDTO
     */
    quantity: number;
}
/**
 * 
 * @export
 * @interface AddCustomerDto
 */
export interface AddCustomerDto {
    /**
     * 
     * @type {string}
     * @memberof AddCustomerDto
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof AddCustomerDto
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof AddCustomerDto
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof AddCustomerDto
     */
    programId: string;
    /**
     * 
     * @type {boolean}
     * @memberof AddCustomerDto
     */
    canBuyProducts: boolean;
}
/**
 * 
 * @export
 * @interface AddProgramProductDTO
 */
export interface AddProgramProductDTO {
    /**
     * 
     * @type {string}
     * @memberof AddProgramProductDTO
     */
    coloredProductId: string;
}
/**
 * 
 * @export
 * @interface AddTextureDTO
 */
export interface AddTextureDTO {
    /**
     * 
     * @type {string}
     * @memberof AddTextureDTO
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof AddTextureDTO
     */
    canCombine: boolean;
}
/**
 * 
 * @export
 * @interface AddressNotFoundError
 */
export interface AddressNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof AddressNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof AddressNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface AppliedArtworkNotFoundError
 */
export interface AppliedArtworkNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof AppliedArtworkNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof AppliedArtworkNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface AppliedTextureNotFoundError
 */
export interface AppliedTextureNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof AppliedTextureNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof AppliedTextureNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ApplyArtworkDTO
 */
export interface ApplyArtworkDTO {
    /**
     * 
     * @type {string}
     * @memberof ApplyArtworkDTO
     */
    boundaryId: string;
    /**
     * 
     * @type {ArtworkDetailsDTO}
     * @memberof ApplyArtworkDTO
     */
    chosenArtworkDetails?: ArtworkDetailsDTO;
}
/**
 * 
 * @export
 * @interface ApplyTextureDTO
 */
export interface ApplyTextureDTO {
    /**
     * 
     * @type {string}
     * @memberof ApplyTextureDTO
     */
    textureId: string;
    /**
     * 
     * @type {string}
     * @memberof ApplyTextureDTO
     */
    programArtworkColorId: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Artwork {
    None = 'none',
    Texture = 'texture',
    Images = 'images'
}

/**
 * 
 * @export
 * @interface ArtworkAndProgramNotRelatedError
 */
export interface ArtworkAndProgramNotRelatedError {
    /**
     * 
     * @type {string}
     * @memberof ArtworkAndProgramNotRelatedError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ArtworkAndProgramNotRelatedError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ArtworkColorNotAvailabeForOriginalImageError
 */
export interface ArtworkColorNotAvailabeForOriginalImageError {
    /**
     * 
     * @type {string}
     * @memberof ArtworkColorNotAvailabeForOriginalImageError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ArtworkColorNotAvailabeForOriginalImageError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ArtworkDetailsDTO
 */
export interface ArtworkDetailsDTO {
    /**
     * 
     * @type {string}
     * @memberof ArtworkDetailsDTO
     */
    programArtworkId: string;
    /**
     * 
     * @type {number}
     * @memberof ArtworkDetailsDTO
     */
    sizeRatio: number;
    /**
     * 
     * @type {number}
     * @memberof ArtworkDetailsDTO
     */
    xRatio: number;
    /**
     * 
     * @type {number}
     * @memberof ArtworkDetailsDTO
     */
    yRatio: number;
    /**
     * 
     * @type {number}
     * @memberof ArtworkDetailsDTO
     */
    whRatio: number;
    /**
     * 
     * @type {number}
     * @memberof ArtworkDetailsDTO
     */
    rotation: number;
    /**
     * 
     * @type {Array<ApplyTextureDTO>}
     * @memberof ArtworkDetailsDTO
     */
    chosenTextures?: Array<ApplyTextureDTO>;
}
/**
 * 
 * @export
 * @interface ArtworkNotFoundForProgramError
 */
export interface ArtworkNotFoundForProgramError {
    /**
     * 
     * @type {string}
     * @memberof ArtworkNotFoundForProgramError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ArtworkNotFoundForProgramError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface BadRequestError
 */
export interface BadRequestError {
    /**
     * 
     * @type {string}
     * @memberof BadRequestError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof BadRequestError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface BankAccountNumberNotValidError
 */
export interface BankAccountNumberNotValidError {
    /**
     * 
     * @type {string}
     * @memberof BankAccountNumberNotValidError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof BankAccountNumberNotValidError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface BankRoutingNumberNotValidError
 */
export interface BankRoutingNumberNotValidError {
    /**
     * 
     * @type {string}
     * @memberof BankRoutingNumberNotValidError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof BankRoutingNumberNotValidError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface BillingAddressIsRequiredError
 */
export interface BillingAddressIsRequiredError {
    /**
     * 
     * @type {string}
     * @memberof BillingAddressIsRequiredError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof BillingAddressIsRequiredError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface Boundary3DNotFoundError
 */
export interface Boundary3DNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof Boundary3DNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof Boundary3DNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface BoundaryAndProductNotRelatedError
 */
export interface BoundaryAndProductNotRelatedError {
    /**
     * 
     * @type {string}
     * @memberof BoundaryAndProductNotRelatedError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof BoundaryAndProductNotRelatedError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CancelOrderStatusError
 */
export interface CancelOrderStatusError {
    /**
     * 
     * @type {string}
     * @memberof CancelOrderStatusError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CancelOrderStatusError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CancelOrderTimeWindowExpiredError
 */
export interface CancelOrderTimeWindowExpiredError {
    /**
     * 
     * @type {string}
     * @memberof CancelOrderTimeWindowExpiredError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CancelOrderTimeWindowExpiredError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotApplyMultipleArtworkImageForArtworkTypeImageError
 */
export interface CannotApplyMultipleArtworkImageForArtworkTypeImageError {
    /**
     * 
     * @type {string}
     * @memberof CannotApplyMultipleArtworkImageForArtworkTypeImageError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotApplyMultipleArtworkImageForArtworkTypeImageError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotApproveCustomerError
 */
export interface CannotApproveCustomerError {
    /**
     * 
     * @type {string}
     * @memberof CannotApproveCustomerError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotApproveCustomerError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotCancelCustomerInvitationError
 */
export interface CannotCancelCustomerInvitationError {
    /**
     * 
     * @type {string}
     * @memberof CannotCancelCustomerInvitationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotCancelCustomerInvitationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotCancelMoqOrdersOnceApprovedError
 */
export interface CannotCancelMoqOrdersOnceApprovedError {
    /**
     * 
     * @type {string}
     * @memberof CannotCancelMoqOrdersOnceApprovedError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotCancelMoqOrdersOnceApprovedError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotCombineTexturesError
 */
export interface CannotCombineTexturesError {
    /**
     * 
     * @type {string}
     * @memberof CannotCombineTexturesError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotCombineTexturesError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotDeactivateCustomerError
 */
export interface CannotDeactivateCustomerError {
    /**
     * 
     * @type {string}
     * @memberof CannotDeactivateCustomerError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotDeactivateCustomerError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotDeactivateDeactivatedProgramError
 */
export interface CannotDeactivateDeactivatedProgramError {
    /**
     * 
     * @type {string}
     * @memberof CannotDeactivateDeactivatedProgramError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotDeactivateDeactivatedProgramError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotDeactivateDeactivatedUserError
 */
export interface CannotDeactivateDeactivatedUserError {
    /**
     * 
     * @type {string}
     * @memberof CannotDeactivateDeactivatedUserError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotDeactivateDeactivatedUserError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotDeactivateInactiveProgramError
 */
export interface CannotDeactivateInactiveProgramError {
    /**
     * 
     * @type {string}
     * @memberof CannotDeactivateInactiveProgramError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotDeactivateInactiveProgramError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotDeactivateInactiveUserError
 */
export interface CannotDeactivateInactiveUserError {
    /**
     * 
     * @type {string}
     * @memberof CannotDeactivateInactiveUserError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotDeactivateInactiveUserError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotDeactivateInvitedProgramError
 */
export interface CannotDeactivateInvitedProgramError {
    /**
     * 
     * @type {string}
     * @memberof CannotDeactivateInvitedProgramError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotDeactivateInvitedProgramError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotDeactivateInvitedUserError
 */
export interface CannotDeactivateInvitedUserError {
    /**
     * 
     * @type {string}
     * @memberof CannotDeactivateInvitedUserError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotDeactivateInvitedUserError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotDeactivateOnboardingProgramError
 */
export interface CannotDeactivateOnboardingProgramError {
    /**
     * 
     * @type {string}
     * @memberof CannotDeactivateOnboardingProgramError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotDeactivateOnboardingProgramError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotDeactivateRequestedUserError
 */
export interface CannotDeactivateRequestedUserError {
    /**
     * 
     * @type {string}
     * @memberof CannotDeactivateRequestedUserError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotDeactivateRequestedUserError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotDeclineCustomerError
 */
export interface CannotDeclineCustomerError {
    /**
     * 
     * @type {string}
     * @memberof CannotDeclineCustomerError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotDeclineCustomerError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotDeleteActiveUserError
 */
export interface CannotDeleteActiveUserError {
    /**
     * 
     * @type {string}
     * @memberof CannotDeleteActiveUserError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotDeleteActiveUserError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotDeleteInactiveUserError
 */
export interface CannotDeleteInactiveUserError {
    /**
     * 
     * @type {string}
     * @memberof CannotDeleteInactiveUserError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotDeleteInactiveUserError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotDeleteInvitedUserError
 */
export interface CannotDeleteInvitedUserError {
    /**
     * 
     * @type {string}
     * @memberof CannotDeleteInvitedUserError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotDeleteInvitedUserError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotDeleteRequestedUserError
 */
export interface CannotDeleteRequestedUserError {
    /**
     * 
     * @type {string}
     * @memberof CannotDeleteRequestedUserError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotDeleteRequestedUserError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotDraftActiveOrInactiveProductError
 */
export interface CannotDraftActiveOrInactiveProductError {
    /**
     * 
     * @type {string}
     * @memberof CannotDraftActiveOrInactiveProductError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotDraftActiveOrInactiveProductError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotEditArtworkForOncePublishedProduct
 */
export interface CannotEditArtworkForOncePublishedProduct {
    /**
     * 
     * @type {string}
     * @memberof CannotEditArtworkForOncePublishedProduct
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotEditArtworkForOncePublishedProduct
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotEditCustomerDetailsError
 */
export interface CannotEditCustomerDetailsError {
    /**
     * 
     * @type {string}
     * @memberof CannotEditCustomerDetailsError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotEditCustomerDetailsError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotEditDisconnectedProductDetails
 */
export interface CannotEditDisconnectedProductDetails {
    /**
     * 
     * @type {string}
     * @memberof CannotEditDisconnectedProductDetails
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotEditDisconnectedProductDetails
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotEditOncepublishedProductError
 */
export interface CannotEditOncepublishedProductError {
    /**
     * 
     * @type {string}
     * @memberof CannotEditOncepublishedProductError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotEditOncepublishedProductError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotEditUnpublishedProductError
 */
export interface CannotEditUnpublishedProductError {
    /**
     * 
     * @type {string}
     * @memberof CannotEditUnpublishedProductError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotEditUnpublishedProductError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotGetShippingLabelForReturnNotApprovedError
 */
export interface CannotGetShippingLabelForReturnNotApprovedError {
    /**
     * 
     * @type {string}
     * @memberof CannotGetShippingLabelForReturnNotApprovedError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotGetShippingLabelForReturnNotApprovedError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotInviteActiveProgramError
 */
export interface CannotInviteActiveProgramError {
    /**
     * 
     * @type {string}
     * @memberof CannotInviteActiveProgramError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotInviteActiveProgramError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotInviteAnInvitedProgramError
 */
export interface CannotInviteAnInvitedProgramError {
    /**
     * 
     * @type {string}
     * @memberof CannotInviteAnInvitedProgramError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotInviteAnInvitedProgramError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotInviteDeactivatedProgramError
 */
export interface CannotInviteDeactivatedProgramError {
    /**
     * 
     * @type {string}
     * @memberof CannotInviteDeactivatedProgramError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotInviteDeactivatedProgramError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotInviteOnboardingProgramError
 */
export interface CannotInviteOnboardingProgramError {
    /**
     * 
     * @type {string}
     * @memberof CannotInviteOnboardingProgramError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotInviteOnboardingProgramError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotPublishActiveProductError
 */
export interface CannotPublishActiveProductError {
    /**
     * 
     * @type {string}
     * @memberof CannotPublishActiveProductError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotPublishActiveProductError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotPublishIdleProductError
 */
export interface CannotPublishIdleProductError {
    /**
     * 
     * @type {string}
     * @memberof CannotPublishIdleProductError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotPublishIdleProductError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotPublishProductWithZeroPriceError
 */
export interface CannotPublishProductWithZeroPriceError {
    /**
     * 
     * @type {string}
     * @memberof CannotPublishProductWithZeroPriceError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotPublishProductWithZeroPriceError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotReactivateActiveProgramError
 */
export interface CannotReactivateActiveProgramError {
    /**
     * 
     * @type {string}
     * @memberof CannotReactivateActiveProgramError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotReactivateActiveProgramError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotReactivateActiveUserError
 */
export interface CannotReactivateActiveUserError {
    /**
     * 
     * @type {string}
     * @memberof CannotReactivateActiveUserError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotReactivateActiveUserError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotReactivateInactiveProgramError
 */
export interface CannotReactivateInactiveProgramError {
    /**
     * 
     * @type {string}
     * @memberof CannotReactivateInactiveProgramError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotReactivateInactiveProgramError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotReactivateInactiveUserError
 */
export interface CannotReactivateInactiveUserError {
    /**
     * 
     * @type {string}
     * @memberof CannotReactivateInactiveUserError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotReactivateInactiveUserError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotReactivateInvitedProgramError
 */
export interface CannotReactivateInvitedProgramError {
    /**
     * 
     * @type {string}
     * @memberof CannotReactivateInvitedProgramError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotReactivateInvitedProgramError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotReactivateInvitedUserError
 */
export interface CannotReactivateInvitedUserError {
    /**
     * 
     * @type {string}
     * @memberof CannotReactivateInvitedUserError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotReactivateInvitedUserError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotReactivateOnboardingProgramError
 */
export interface CannotReactivateOnboardingProgramError {
    /**
     * 
     * @type {string}
     * @memberof CannotReactivateOnboardingProgramError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotReactivateOnboardingProgramError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotReactivateRequestedUserError
 */
export interface CannotReactivateRequestedUserError {
    /**
     * 
     * @type {string}
     * @memberof CannotReactivateRequestedUserError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotReactivateRequestedUserError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotReinviteActiveProgramError
 */
export interface CannotReinviteActiveProgramError {
    /**
     * 
     * @type {string}
     * @memberof CannotReinviteActiveProgramError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotReinviteActiveProgramError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotReinviteDeactivatedProgramError
 */
export interface CannotReinviteDeactivatedProgramError {
    /**
     * 
     * @type {string}
     * @memberof CannotReinviteDeactivatedProgramError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotReinviteDeactivatedProgramError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotReinviteInactiveProgramError
 */
export interface CannotReinviteInactiveProgramError {
    /**
     * 
     * @type {string}
     * @memberof CannotReinviteInactiveProgramError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotReinviteInactiveProgramError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotReinviteOnboardingProgramError
 */
export interface CannotReinviteOnboardingProgramError {
    /**
     * 
     * @type {string}
     * @memberof CannotReinviteOnboardingProgramError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotReinviteOnboardingProgramError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotRemoveTexturesForTheArtworkType
 */
export interface CannotRemoveTexturesForTheArtworkType {
    /**
     * 
     * @type {string}
     * @memberof CannotRemoveTexturesForTheArtworkType
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotRemoveTexturesForTheArtworkType
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotSaveProductDescription
 */
export interface CannotSaveProductDescription {
    /**
     * 
     * @type {string}
     * @memberof CannotSaveProductDescription
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotSaveProductDescription
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotSwapSystemProductsOfDifferentCategories
 */
export interface CannotSwapSystemProductsOfDifferentCategories {
    /**
     * 
     * @type {string}
     * @memberof CannotSwapSystemProductsOfDifferentCategories
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotSwapSystemProductsOfDifferentCategories
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotUnpublishDraftedProductError
 */
export interface CannotUnpublishDraftedProductError {
    /**
     * 
     * @type {string}
     * @memberof CannotUnpublishDraftedProductError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotUnpublishDraftedProductError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotUnpublishLastActiveSFColorProduct
 */
export interface CannotUnpublishLastActiveSFColorProduct {
    /**
     * 
     * @type {string}
     * @memberof CannotUnpublishLastActiveSFColorProduct
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotUnpublishLastActiveSFColorProduct
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotUnselectLastActiveProgramProduct
 */
export interface CannotUnselectLastActiveProgramProduct {
    /**
     * 
     * @type {string}
     * @memberof CannotUnselectLastActiveProgramProduct
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotUnselectLastActiveProgramProduct
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotUpdateProductTextureOptionsError
 */
export interface CannotUpdateProductTextureOptionsError {
    /**
     * 
     * @type {string}
     * @memberof CannotUpdateProductTextureOptionsError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotUpdateProductTextureOptionsError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CannotUpdateProgramColorsError
 */
export interface CannotUpdateProgramColorsError {
    /**
     * 
     * @type {string}
     * @memberof CannotUpdateProgramColorsError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CannotUpdateProgramColorsError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CartItemNotFoundError
 */
export interface CartItemNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof CartItemNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CartItemNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CartItemQuantityNotAvailable
 */
export interface CartItemQuantityNotAvailable {
    /**
     * 
     * @type {string}
     * @memberof CartItemQuantityNotAvailable
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CartItemQuantityNotAvailable
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ChangePasswordDto
 */
export interface ChangePasswordDto {
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordDto
     */
    oldPassword: string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordDto
     */
    newPassword: string;
}
/**
 * 
 * @export
 * @interface ChildOrderReturnReasonDTO
 */
export interface ChildOrderReturnReasonDTO {
    /**
     * 
     * @type {string}
     * @memberof ChildOrderReturnReasonDTO
     */
    reason: string;
    /**
     * 
     * @type {boolean}
     * @memberof ChildOrderReturnReasonDTO
     */
    manualApproval?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ChildOrderReturnReasonDTO
     */
    requireEvidence: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ChildOrderReturnReasonDTO
     */
    eligibleForFullRefund?: boolean;
}
/**
 * 
 * @export
 * @interface ChooseArtworkToCustomizeArtworkTypeImageError
 */
export interface ChooseArtworkToCustomizeArtworkTypeImageError {
    /**
     * 
     * @type {string}
     * @memberof ChooseArtworkToCustomizeArtworkTypeImageError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ChooseArtworkToCustomizeArtworkTypeImageError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ColorAlreadyAddedToProgramParentProductError
 */
export interface ColorAlreadyAddedToProgramParentProductError {
    /**
     * 
     * @type {string}
     * @memberof ColorAlreadyAddedToProgramParentProductError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ColorAlreadyAddedToProgramParentProductError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ColoredProductIdsNotMatchedError
 */
export interface ColoredProductIdsNotMatchedError {
    /**
     * 
     * @type {string}
     * @memberof ColoredProductIdsNotMatchedError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ColoredProductIdsNotMatchedError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ColoredProductPublishedAlreadyError
 */
export interface ColoredProductPublishedAlreadyError {
    /**
     * 
     * @type {string}
     * @memberof ColoredProductPublishedAlreadyError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ColoredProductPublishedAlreadyError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CreateOrderReturnReasonDTO
 */
export interface CreateOrderReturnReasonDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateOrderReturnReasonDTO
     */
    reason: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrderReturnReasonDTO
     */
    forItemType?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateOrderReturnReasonDTO
     */
    manualApproval?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateOrderReturnReasonDTO
     */
    requireEvidence: boolean;
    /**
     * 
     * @type {Array<ChildOrderReturnReasonDTO>}
     * @memberof CreateOrderReturnReasonDTO
     */
    childReasons?: Array<ChildOrderReturnReasonDTO>;
}
/**
 * 
 * @export
 * @interface CreateRebelProgramProductDTO
 */
export interface CreateRebelProgramProductDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateRebelProgramProductDTO
     */
    title: string;
    /**
     * 
     * @type {number}
     * @memberof CreateRebelProgramProductDTO
     */
    price?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateRebelProgramProductDTO
     */
    note?: string;
}
/**
 * 
 * @export
 * @interface CreateShippingCostDTO
 */
export interface CreateShippingCostDTO {
    /**
     * 
     * @type {number}
     * @memberof CreateShippingCostDTO
     */
    minOrderLimit: number;
    /**
     * 
     * @type {number}
     * @memberof CreateShippingCostDTO
     */
    maxOrderLimit: number;
    /**
     * 
     * @type {number}
     * @memberof CreateShippingCostDTO
     */
    shippingCost: number;
}
/**
 * 
 * @export
 * @interface CreateShippingInfoDTO
 */
export interface CreateShippingInfoDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateShippingInfoDTO
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof CreateShippingInfoDTO
     */
    rate: number;
}
/**
 * 
 * @export
 * @interface CronJobLockSetupError
 */
export interface CronJobLockSetupError {
    /**
     * 
     * @type {string}
     * @memberof CronJobLockSetupError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CronJobLockSetupError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CustomerAndOrderNotRelatedError
 */
export interface CustomerAndOrderNotRelatedError {
    /**
     * 
     * @type {string}
     * @memberof CustomerAndOrderNotRelatedError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerAndOrderNotRelatedError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CustomerAndProgramNotRelatedError
 */
export interface CustomerAndProgramNotRelatedError {
    /**
     * 
     * @type {string}
     * @memberof CustomerAndProgramNotRelatedError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerAndProgramNotRelatedError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CustomerCardNotFoundError
 */
export interface CustomerCardNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof CustomerCardNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerCardNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CustomerForInvoice
 */
export interface CustomerForInvoice {
    /**
     * 
     * @type {string}
     * @memberof CustomerForInvoice
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerForInvoice
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerForInvoice
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerForInvoice
     */
    email: string;
}
/**
 * 
 * @export
 * @interface CustomerForgotPasswordDto
 */
export interface CustomerForgotPasswordDto {
    /**
     * 
     * @type {string}
     * @memberof CustomerForgotPasswordDto
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerForgotPasswordDto
     */
    programId: string;
}
/**
 * 
 * @export
 * @interface CustomerIsNotEligibleForInvitationError
 */
export interface CustomerIsNotEligibleForInvitationError {
    /**
     * 
     * @type {string}
     * @memberof CustomerIsNotEligibleForInvitationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerIsNotEligibleForInvitationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CustomerIsNotEligibleForReInvitationError
 */
export interface CustomerIsNotEligibleForReInvitationError {
    /**
     * 
     * @type {string}
     * @memberof CustomerIsNotEligibleForReInvitationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerIsNotEligibleForReInvitationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CustomerLoginToWrongProgramError
 */
export interface CustomerLoginToWrongProgramError {
    /**
     * 
     * @type {string}
     * @memberof CustomerLoginToWrongProgramError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerLoginToWrongProgramError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CustomerNotEligibleToUpdateStatusError
 */
export interface CustomerNotEligibleToUpdateStatusError {
    /**
     * 
     * @type {string}
     * @memberof CustomerNotEligibleToUpdateStatusError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerNotEligibleToUpdateStatusError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CustomerNotFoundError
 */
export interface CustomerNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof CustomerNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface CustomerSignInDto
 */
export interface CustomerSignInDto {
    /**
     * 
     * @type {string}
     * @memberof CustomerSignInDto
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerSignInDto
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerSignInDto
     */
    programId: string;
}
/**
 * 
 * @export
 * @interface CustomerSignUpDto
 */
export interface CustomerSignUpDto {
    /**
     * 
     * @type {string}
     * @memberof CustomerSignUpDto
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerSignUpDto
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerSignUpDto
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerSignUpDto
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerSignUpDto
     */
    programId: string;
}
/**
 * 
 * @export
 * @interface EditCustomerDetailsValidationError
 */
export interface EditCustomerDetailsValidationError {
    /**
     * 
     * @type {string}
     * @memberof EditCustomerDetailsValidationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof EditCustomerDetailsValidationError
     */
    type: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ErrorType {
    UserNotFound = 'UserNotFound',
    FailedToGetResource = 'FailedToGetResource',
    FailedToSaveResource = 'FailedToSaveResource',
    AddressNotFound = 'AddressNotFound',
    SystemAdminUserExists = 'SystemAdminUserExists',
    LimitExceedBulkCustomersUpdate = 'LimitExceedBulkCustomersUpdate',
    UserDoesNotHavePrivileges = 'UserDoesNotHavePrivileges',
    BadRequest = 'BadRequest',
    InvalidPassword = 'InvalidPassword',
    UserExistsWithEmail = 'UserExistsWithEmail',
    PasswordTokenNotFound = 'PasswordTokenNotFound',
    PasswordTokenExpired = 'PasswordTokenExpired',
    WrongPassword = 'WrongPassword',
    SameAsOneOfPreviousPasswords = 'SameAsOneOfPreviousPasswords',
    PermissionsRequired = 'PermissionsRequired',
    InvalidPermissionName = 'InvalidPermissionName',
    InvalidPermissionForUserType = 'InvalidPermissionForUserType',
    UserNotActive = 'UserNotActive',
    CustomerLoginToWrongProgram = 'CustomerLoginToWrongProgram',
    RefreshTokenExpiredOrNotActive = 'RefreshTokenExpiredOrNotActive',
    ProgramNotFound = 'ProgramNotFound',
    ProgramNotActive = 'ProgramNotActive',
    CannotInviteAnInvitedProgram = 'CannotInviteAnInvitedProgram',
    CannotInviteActivateProgram = 'CannotInviteActivateProgram',
    CannotInviteDeactivatedProgram = 'CannotInviteDeactivatedProgram',
    StoreDomainUrlNotAvailable = 'StoreDomainUrlNotAvailable',
    FailedToCreateProgramOwner = 'FailedToCreateProgramOwner',
    ProgramCannotAcceptNewCustomer = 'ProgramCannotAcceptNewCustomer',
    UserAlreadyAssociatedWithOtherProgram = 'UserAlreadyAssociatedWithOtherProgram',
    ProgramOwnerAlreadyAssociatedWithOtherProgramError = 'ProgramOwnerAlreadyAssociatedWithOtherProgramError',
    UserIsNotEligibleForAccess = 'UserIsNotEligibleForAccess',
    UserIsNotEligibleForAccessProgramError = 'UserIsNotEligibleForAccessProgramError',
    UserIsNotEligibleForInvitation = 'UserIsNotEligibleForInvitation',
    CannotReinviteActiveProgram = 'CannotReinviteActiveProgram',
    CannotReinviteDeactivatedProgram = 'CannotReinviteDeactivatedProgram',
    CannotReinviteInactiveProgram = 'CannotReinviteInactiveProgram',
    ProgramOwnerNotFound = 'ProgramOwnerNotFound',
    CannotInviteOnboardingProgram = 'CannotInviteOnboardingProgram',
    CannotReinviteOnboardingProgram = 'CannotReinviteOnboardingProgram',
    CannotUpdateProgramColors = 'CannotUpdateProgramColors',
    CannotReactivateInvitedProgram = 'CannotReactivateInvitedProgram',
    CannotReactivateActiveProgram = 'CannotReactivateActiveProgram',
    CannotReactivateInactiveProgram = 'CannotReactivateInactiveProgram',
    CannotReactivateOnboardingProgram = 'CannotReactivateOnboardingProgram',
    CannotDeactivateInvitedProgram = 'CannotDeactivateInvitedProgram',
    CannotDeactivateDeactivatedProgram = 'CannotDeactivateDeactivatedProgram',
    CannotDeactivateInactiveProgram = 'CannotDeactivateInactiveProgram',
    CannotDeactivateOnboardingProgram = 'CannotDeactivateOnboardingProgram',
    CannotDeactivateInvitedUser = 'CannotDeactivateInvitedUser',
    CannotDeactivateDeactivatedUser = 'CannotDeactivateDeactivatedUser',
    CannotDeactivateInactiveUser = 'CannotDeactivateInactiveUser',
    CannotDeactivateRequestedUser = 'CannotDeactivateRequestedUser',
    BankAccountNumberNotValid = 'BankAccountNumberNotValid',
    BankRoutingNumberNotValid = 'BankRoutingNumberNotValid',
    Forbidden = 'Forbidden',
    Unauthorized = 'Unauthorized',
    InvalidEmail = 'InvalidEmail',
    InvalidInt = 'InvalidInt',
    InvalidDecimal = 'InvalidDecimal',
    InvalidNumber = 'InvalidNumber',
    MinNumber = 'MinNumber',
    MaxNumber = 'MaxNumber',
    NotMatchingRegex = 'NotMatchingRegex',
    TaxCalculationError = 'TaxCalculationError',
    NotOneOfValues = 'NotOneOfValues',
    InvalidDate = 'InvalidDate',
    InvalidString = 'InvalidString',
    InvalidBool = 'InvalidBool',
    InvalidValue = 'InvalidValue',
    MinStringLength = 'MinStringLength',
    MaxStringLength = 'MaxStringLength',
    MediaFileNotFound = 'MediaFileNotFound',
    MediaFileInvalid = 'MediaFileInvalid',
    FileTypeNotSupported = 'FileTypeNotSupported',
    MediaFileTypeMetaDataNotFound = 'MediaFileTypeMetaDataNotFound',
    MediaFileFailedToProcess = 'MediaFileFailedToProcess',
    InternalServerError = 'InternalServerError',
    ProgramBannerNotFoundError = 'ProgramBannerNotFoundError',
    ProgramlogoNotFoundError = 'ProgramlogoNotFoundError',
    FailedToGenerateProgramListFileError = 'FailedToGenerateProgramListFileError',
    FailedToGenerateMoqNotMetProductOrderListFileError = 'FailedToGenerateMoqNotMetProductOrderListFileError',
    FailedToGenerateOrderListFileError = 'FailedToGenerateOrderListFileError',
    AwsHeadObjectNotFoundError = 'AWSHeadObjectNotFoundError',
    SfProductNotFound = 'SFProductNotFound',
    ShippingCostNotFoundError = 'ShippingCostNotFoundError',
    OrderReturnReasonNotFoundError = 'OrderReturnReasonNotFoundError',
    OrderItemReturnNotFoundError = 'OrderItemReturnNotFoundError',
    ProductNotFound = 'ProductNotFound',
    InvalidEnumValidationError = 'InvalidEnumValidationError',
    SwatchColorValidationError = 'SwatchColorValidationError',
    CannotPublishIdleProductError = 'CannotPublishIdleProductError',
    CannotPublishActiveProductError = 'CannotPublishActiveProductError',
    CustomerAndProgramNotRelatedError = 'CustomerAndProgramNotRelatedError',
    CustomerNotEligibleToUpdateStatusError = 'CustomerNotEligibleToUpdateStatusError',
    CustomerIsNotEligibleForReInvitationError = 'CustomerIsNotEligibleForReInvitationError',
    CustomerIsNotEligibleForInvitationError = 'CustomerIsNotEligibleForInvitationError',
    CustomerNotFoundError = 'CustomerNotFoundError',
    CannotCancelCustomerInvitationError = 'CannotCancelCustomerInvitationError',
    CannotDeactivateCustomerError = 'CannotDeactivateCustomerError',
    CannotApproveCustomerError = 'CannotApproveCustomerError',
    CannotDeclineCustomerError = 'CannotDeclineCustomerError',
    CannotEditCustomerDetailsError = 'CannotEditCustomerDetailsError',
    EditCustomerDetailsValidationError = 'EditCustomerDetailsValidationError',
    ProductImageNotFoundError = 'ProductImageNotFoundError',
    ShouldHaveSwatchColorsError = 'ShouldHaveSwatchColorsError',
    ColoredProductPublishedAlreadyError = 'ColoredProductPublishedAlreadyError',
    ParentNotActiveInSfError = 'ParentNotActiveInSFError',
    ShouldHaveOne2DAssetError = 'ShouldHaveOne2DAssetError',
    ImageAndColoredProductNotRelatedError = 'ImageAndColoredProductNotRelatedError',
    CannotEditDisconnectedProductDetails = 'CannotEditDisconnectedProductDetails',
    CannotSaveProductDescription = 'CannotSaveProductDescription',
    ProgramProductNotFoundError = 'ProgramProductNotFoundError',
    ShoulHaveAtleastOneActiveSfColorProductError = 'ShoulHaveAtleastOneActiveSFColorProductError',
    ProgramArtworkNotFoundError = 'ProgramArtworkNotFoundError',
    ArtworkAndProgramNotRelatedError = 'ArtworkAndProgramNotRelatedError',
    ColorAlreadyAddedToProgramParentProductError = 'ColorAlreadyAddedToProgramParentProductError',
    SfColoredProductAndProgramParentNotRelatedError = 'SFColoredProductAndProgramParentNotRelatedError',
    SfColoredProductNotActiveError = 'SFColoredProductNotActiveError',
    ProgramProductImageNotFoundError = 'ProgramProductImageNotFoundError',
    ImageAndProgramProductNotRelatedError = 'ImageAndProgramProductNotRelatedError',
    ProgramProductShouldHaveAtleastOneImageError = 'ProgramProductShouldHaveAtleastOneImageError',
    SystemProductNotPublishedError = 'SystemProductNotPublishedError',
    ProgramProductNotPublishedError = 'ProgramProductNotPublishedError',
    CannotUnpublishDraftedProductError = 'CannotUnpublishDraftedProductError',
    CannotDraftActiveOrInactiveProductError = 'CannotDraftActiveOrInactiveProductError',
    ShouldHaveAtleastOneColorSelectedForParentProductPublishingError = 'ShouldHaveAtleastOneColorSelectedForParentProductPublishingError',
    ShouldHaveAtleastOneImageForSelectedColorForParentProductPublishingError = 'ShouldHaveAtleastOneImageForSelectedColorForParentProductPublishingError',
    ShouldHavePriceSetForSelectedColorForParentProductPublishingError = 'ShouldHavePriceSetForSelectedColorForParentProductPublishingError',
    CannotEditUnpublishedProductError = 'CannotEditUnpublishedProductError',
    ProductNotInStockError = 'ProductNotInStockError',
    CartItemNotFoundError = 'CartItemNotFoundError',
    CannotReactivateRequestedUserError = 'CannotReactivateRequestedUserError',
    CannotReactivateInvitedUserError = 'CannotReactivateInvitedUserError',
    CannotReactivateActiveUserError = 'CannotReactivateActiveUserError',
    CannotReactivateInactiveUserError = 'CannotReactivateInactiveUserError',
    CannotUnpublishLastActiveSfColorProduct = 'CannotUnpublishLastActiveSFColorProduct',
    CannotUnselectLastActiveProgramProduct = 'CannotUnselectLastActiveProgramProduct',
    SfParentProductDescriptionIsEmptyError = 'SFParentProductDescriptionIsEmptyError',
    CannotPublishProductWithZeroPriceError = 'CannotPublishProductWithZeroPriceError',
    _3DBoundaryNotFoundError = '3DBoundaryNotFoundError',
    _3DLayerNotFoundError = '3DLayerNotFoundError',
    Model3DNotFoundError = 'Model3DNotFoundError',
    Product3DColorNotFoundError = 'Product3DColorNotFoundError',
    AwsObjectNotFoundError = 'AWSObjectNotFoundError',
    CannotDeleteRequestedUserError = 'CannotDeleteRequestedUserError',
    CannotDeleteInvitedUserError = 'CannotDeleteInvitedUserError',
    CannotDeleteActiveUserError = 'CannotDeleteActiveUserError',
    CannotDeleteInactiveUserError = 'CannotDeleteInactiveUserError',
    TextureNotFoundError = 'TextureNotFoundError',
    CannotEditOncepublishedProductError = 'CannotEditOncepublishedProductError',
    TextureExistsError = 'TextureExistsError',
    CannotUpdateProductTextureOptionsError = 'CannotUpdateProductTextureOptionsError',
    Model3DAndProductNotRelatedError = 'Model3DAndProductNotRelatedError',
    FavoriteNotFoundError = 'FavoriteNotFoundError',
    UpdateProgramProductColorsValidationError = 'UpdateProgramProductColorsValidationError',
    UpdateProgramProductColorNotUniqueValidationError = 'UpdateProgramProductColorNotUniqueValidationError',
    ProgramparentProductNotFoundError = 'ProgramparentProductNotFoundError',
    ProgramArtworkColorNotFoundError = 'ProgramArtworkColorNotFoundError',
    ArtworkColorNotAvailabeForOriginalImageError = 'ArtworkColorNotAvailabeForOriginalImageError',
    AppliedArtworkNotFoundError = 'AppliedArtworkNotFoundError',
    AppliedTextureNotFoundError = 'AppliedTextureNotFoundError',
    TexturesNotFoundForSfParentProductError = 'TexturesNotFoundForSFParentProductError',
    SfParentProductNotEligibleForArtworkCustomizationError = 'SFParentProductNotEligibleForArtworkCustomizationError',
    SfParentProductNotEligibleForArtworkTextureCustomizationError = 'SFParentProductNotEligibleForArtworkTextureCustomizationError',
    SfParentProductTexturesNotChosenError = 'SFParentProductTexturesNotChosenError',
    BoundaryAndProductNotRelatedError = 'BoundaryAndProductNotRelatedError',
    TextureAndProductNotRelatedError = 'TextureAndProductNotRelatedError',
    ChooseArtworkToCustomizeArtworkTypeImageError = 'ChooseArtworkToCustomizeArtworkTypeImageError',
    CannotRemoveTexturesForTheArtworkType = 'CannotRemoveTexturesForTheArtworkType',
    TexturesMandatoryForTheArtworkType = 'TexturesMandatoryForTheArtworkType',
    ProvideAllArtworkColorsToApplyArtworkValidationError = 'ProvideAllArtworkColorsToApplyArtworkValidationError',
    ArtworkNotFoundForProgramError = 'ArtworkNotFoundForProgramError',
    CannotEditArtworkForOncePublishedProduct = 'CannotEditArtworkForOncePublishedProduct',
    ProductIsNotActive = 'ProductIsNotActive',
    ServiceError = 'ServiceError',
    CannotApplyMultipleArtworkImageForArtworkTypeImageError = 'CannotApplyMultipleArtworkImageForArtworkTypeImageError',
    OrderNotFoundError = 'OrderNotFoundError',
    OrderItemNotFoundError = 'OrderItemNotFoundError',
    OrderAddressNotFoundError = 'OrderAddressNotFoundError',
    NoProductsFoundForOrderCheckout = 'NoProductsFoundForOrderCheckout',
    PaymentFailedError = 'PaymentFailedError',
    PaymentDeclinedError = 'PaymentDeclinedError',
    RefundFailedError = 'RefundFailedError',
    OneOrAllCategoriesNotFoundError = 'OneOrAllCategoriesNotFoundError',
    OneOrAllSfProductsNotFoundError = 'OneOrAllSFProductsNotFoundError',
    OneOrAllProgramParentProductsNotFoundError = 'OneOrAllProgramParentProductsNotFoundError',
    ProvideTwoUniqueValuesToSwapValidationError = 'ProvideTwoUniqueValuesToSwapValidationError',
    InvalidPaymentAmountError = 'InvalidPaymentAmountError',
    StoreCreditsNotAvailableToPlaceOrder = 'StoreCreditsNotAvailableToPlaceOrder',
    CannotSwapSystemProductsOfDifferentCategories = 'CannotSwapSystemProductsOfDifferentCategories',
    CustomerCardNotFoundError = 'CustomerCardNotFoundError',
    CartItemQuantityNotAvailable = 'CartItemQuantityNotAvailable',
    ProductsPriceNotAvailable = 'ProductsPriceNotAvailable',
    NoProductsInCart = 'NoProductsInCart',
    FailedToFetchSalesForceProducts = 'FailedToFetchSalesForceProducts',
    FailedToFetchSalesForcePrograms = 'FailedToFetchSalesForcePrograms',
    FailedToConnectToSalesForce = 'FailedToConnectToSalesForce',
    TechPackNotFoundError = 'TechPackNotFoundError',
    ProgramParentProductAndTechpackNotRelatedError = 'ProgramParentProductAndTechpackNotRelatedError',
    TechPackAlreadyExistsForTheProgramProductError = 'TechPackAlreadyExistsForTheProgramProductError',
    ProductSettingOverrideNotFound = 'ProductSettingOverrideNotFound',
    ProductSettingsDataNotFoundToUpdate = 'ProductSettingsDataNotFoundToUpdate',
    ShippingInfoNotFoundError = 'ShippingInfoNotFoundError',
    SfColoredProductNotFound = 'SFColoredProductNotFound',
    CancelOrderStatusError = 'CancelOrderStatusError',
    ReturnOrderStatusError = 'ReturnOrderStatusError',
    ReturnRequestInvalidOrderItemError = 'ReturnRequestInvalidOrderItemError',
    ReturnRequestInvalidResponseError = 'ReturnRequestInvalidResponseError',
    ReturnRequestInvalidReasonError = 'ReturnRequestInvalidReasonError',
    ReturnOrderRequestedStatusError = 'ReturnOrderRequestedStatusError',
    ReturnOrderDeliveredStatusError = 'ReturnOrderDeliveredStatusError',
    CancelOrderTimeWindowExpiredError = 'CancelOrderTimeWindowExpiredError',
    ReturnOrderTimeWindowExpiredError = 'ReturnOrderTimeWindowExpiredError',
    ReasonNotAllowedForReturnError = 'ReasonNotAllowedForReturnError',
    ImagesRequiredForReturnError = 'ImagesRequiredForReturnError',
    ExplanationRequiredForReturnError = 'ExplanationRequiredForReturnError',
    OrderItemReturnImageNotFoundError = 'OrderItemReturnImageNotFoundError',
    CannotGetShippingLabelForReturnNotApprovedError = 'CannotGetShippingLabelForReturnNotApprovedError',
    FailedToFetchMoqAndReceivedOrderCountForProgramProductsError = 'FailedToFetchMoqAndReceivedOrderCountForProgramProductsError',
    PendingMoqNotMetOrdersNotFoundForApprovalOrDenialError = 'PendingMoqNotMetOrdersNotFoundForApprovalOrDenialError',
    InvalidPricesFortheProgramProductsError = 'InvalidPricesFortheProgramProductsError',
    PriceShouldNotBeLessThanRecommendedPriceError = 'PriceShouldNotBeLessThanRecommendedPriceError',
    MultiplePricesFoundFortheProgramProductsError = 'MultiplePricesFoundFortheProgramProductsError',
    OneOrManyofTheChosenProgramProductsDonotBelongToProgramParentProductError = 'OneOrManyofTheChosenProgramProductsDonotBelongToProgramParentProductError',
    InvalidDateRangeError = 'InvalidDateRangeError',
    UserCannotAddMoreThanInventoryCount = 'UserCannotAddMoreThanInventoryCount',
    ReceivedOrderQuantityMoreThanInventoryCount = 'ReceivedOrderQuantityMoreThanInventoryCount',
    FailedToGenerateOrderCustomItemsListError = 'FailedToGenerateOrderCustomItemsListError',
    SystemVariableNotFoundError = 'SystemVariableNotFoundError',
    Invalid3dModelError = 'Invalid3dModelError',
    TransactionIdRequiredForPayment = 'TransactionIdRequiredForPayment',
    FailedToCreateShipmentOrderError = 'FailedToCreateShipmentOrderError',
    FailedToCreateShippingLabelError = 'FailedToCreateShippingLabelError',
    ColoredProductIdsNotMatchedError = 'ColoredProductIdsNotMatchedError',
    ShippingLabelAlreadyCreatedForOrder = 'ShippingLabelAlreadyCreatedForOrder',
    NotEligibleForRefundApprovalDenialError = 'NotEligibleForRefundApprovalDenialError',
    OrderRefundedError = 'OrderRefundedError',
    OrderRefundDeclinedError = 'OrderRefundDeclinedError',
    SizeChartNotFoundError = 'SizeChartNotFoundError',
    CannotCombineTexturesError = 'CannotCombineTexturesError',
    OrderItemReturnRequestAlreadySubmittedError = 'OrderItemReturnRequestAlreadySubmittedError',
    FailedToFetchCartSummary = 'FailedToFetchCartSummary',
    OneOeMoreImagesDoesNotBelongToTheProgramProduct = 'OneOeMoreImagesDoesNotBelongToTheProgramProduct',
    ValidationErrorOnDeleteMultipleProgramProductImages = 'ValidationErrorOnDeleteMultipleProgramProductImages',
    OrderGroupNotFoundError = 'OrderGroupNotFoundError',
    InvalidOverrideRefundAmountError = 'InvalidOverrideRefundAmountError',
    CustomerAndOrderNotRelatedError = 'CustomerAndOrderNotRelatedError',
    BillingAddressIsRequiredError = 'BillingAddressIsRequiredError',
    NotEnoughStoreCreditsError = 'NotEnoughStoreCreditsError',
    OrderAlreadyPaidError = 'OrderAlreadyPaidError',
    SelectAtleastOnepaymentMethod = 'SelectAtleastOnepaymentMethod',
    ProgramShippingNotFoundError = 'ProgramShippingNotFoundError',
    CronJobLockSetUpError = 'CronJobLockSetUpError',
    InvalidPhoneNumberError = 'InvalidPhoneNumberError',
    ShippingLabelGenerationError = 'ShippingLabelGenerationError',
    PostalServiceServiceError = 'PostalServiceServiceError',
    ModelShouldBeUploadedForTheChosenArtworkTypeError = 'ModelShouldBeUploadedForTheChosenArtworkTypeError',
    ProgramParentProductNotPublishedError = 'ProgramParentProductNotPublishedError',
    PublishProgramProductsValidationError = 'PublishProgramProductsValidationError',
    OrderReturnNotFoundError = 'OrderReturnNotFoundError',
    CannotCancelMoqOrdersOnceApprovedError = 'CannotCancelMoqOrdersOnceApprovedError',
    UserNotSystemAdmin = 'UserNotSystemAdmin',
    NoTextureOptionsSelectedError = 'NoTextureOptionsSelectedError',
    ProgramArtworkColorValidationError = 'ProgramArtworkColorValidationError'
}

/**
 * 
 * @export
 * @interface ExplanationRequiredForReturnError
 */
export interface ExplanationRequiredForReturnError {
    /**
     * 
     * @type {string}
     * @memberof ExplanationRequiredForReturnError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ExplanationRequiredForReturnError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ExportOrdersDto
 */
export interface ExportOrdersDto {
    /**
     * 
     * @type {string}
     * @memberof ExportOrdersDto
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface ExportProgramsDto
 */
export interface ExportProgramsDto {
    /**
     * 
     * @type {string}
     * @memberof ExportProgramsDto
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof ExportProgramsDto
     */
    storeStatus?: string;
    /**
     * 
     * @type {string}
     * @memberof ExportProgramsDto
     */
    nameSearch?: string;
}
/**
 * 
 * @export
 * @interface FailedToConnectToSalesForce
 */
export interface FailedToConnectToSalesForce {
    /**
     * 
     * @type {string}
     * @memberof FailedToConnectToSalesForce
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof FailedToConnectToSalesForce
     */
    type: string;
}
/**
 * 
 * @export
 * @interface FailedToCreateProgramOwnerError
 */
export interface FailedToCreateProgramOwnerError {
    /**
     * 
     * @type {string}
     * @memberof FailedToCreateProgramOwnerError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof FailedToCreateProgramOwnerError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface FailedToCreateShipmentOrderError
 */
export interface FailedToCreateShipmentOrderError {
    /**
     * 
     * @type {string}
     * @memberof FailedToCreateShipmentOrderError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof FailedToCreateShipmentOrderError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface FailedToCreateShippingLabelError
 */
export interface FailedToCreateShippingLabelError {
    /**
     * 
     * @type {string}
     * @memberof FailedToCreateShippingLabelError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof FailedToCreateShippingLabelError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface FailedToFetchCartSummary
 */
export interface FailedToFetchCartSummary {
    /**
     * 
     * @type {string}
     * @memberof FailedToFetchCartSummary
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof FailedToFetchCartSummary
     */
    type: string;
}
/**
 * 
 * @export
 * @interface FailedToFetchMoqAndReceivedOrderCountForProgramProductsError
 */
export interface FailedToFetchMoqAndReceivedOrderCountForProgramProductsError {
    /**
     * 
     * @type {string}
     * @memberof FailedToFetchMoqAndReceivedOrderCountForProgramProductsError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof FailedToFetchMoqAndReceivedOrderCountForProgramProductsError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface FailedToFetchSalesForceProducts
 */
export interface FailedToFetchSalesForceProducts {
    /**
     * 
     * @type {string}
     * @memberof FailedToFetchSalesForceProducts
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof FailedToFetchSalesForceProducts
     */
    type: string;
}
/**
 * 
 * @export
 * @interface FailedToFetchSalesForcePrograms
 */
export interface FailedToFetchSalesForcePrograms {
    /**
     * 
     * @type {string}
     * @memberof FailedToFetchSalesForcePrograms
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof FailedToFetchSalesForcePrograms
     */
    type: string;
}
/**
 * 
 * @export
 * @interface FailedToGenerateMoqNotMetProductOrderListFileError
 */
export interface FailedToGenerateMoqNotMetProductOrderListFileError {
    /**
     * 
     * @type {string}
     * @memberof FailedToGenerateMoqNotMetProductOrderListFileError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof FailedToGenerateMoqNotMetProductOrderListFileError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface FailedToGenerateOrderCustomItemsListError
 */
export interface FailedToGenerateOrderCustomItemsListError {
    /**
     * 
     * @type {string}
     * @memberof FailedToGenerateOrderCustomItemsListError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof FailedToGenerateOrderCustomItemsListError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface FailedToGenerateOrderListFileError
 */
export interface FailedToGenerateOrderListFileError {
    /**
     * 
     * @type {string}
     * @memberof FailedToGenerateOrderListFileError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof FailedToGenerateOrderListFileError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface FailedToGenerateProgramListFileError
 */
export interface FailedToGenerateProgramListFileError {
    /**
     * 
     * @type {string}
     * @memberof FailedToGenerateProgramListFileError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof FailedToGenerateProgramListFileError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface FailedToGetResourceError
 */
export interface FailedToGetResourceError {
    /**
     * 
     * @type {string}
     * @memberof FailedToGetResourceError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof FailedToGetResourceError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface FailedToGetShipStationResourceError
 */
export interface FailedToGetShipStationResourceError {
    /**
     * 
     * @type {string}
     * @memberof FailedToGetShipStationResourceError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof FailedToGetShipStationResourceError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface FailedToGetShippingServiceResourceError
 */
export interface FailedToGetShippingServiceResourceError {
    /**
     * 
     * @type {string}
     * @memberof FailedToGetShippingServiceResourceError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof FailedToGetShippingServiceResourceError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface FailedToSaveResourceError
 */
export interface FailedToSaveResourceError {
    /**
     * 
     * @type {string}
     * @memberof FailedToSaveResourceError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof FailedToSaveResourceError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface FavoriteNotFoundError
 */
export interface FavoriteNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof FavoriteNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof FavoriteNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface FileTypeNotSupportedError
 */
export interface FileTypeNotSupportedError {
    /**
     * 
     * @type {string}
     * @memberof FileTypeNotSupportedError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof FileTypeNotSupportedError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ForbiddenError
 */
export interface ForbiddenError {
    /**
     * 
     * @type {string}
     * @memberof ForbiddenError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ForbiddenError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ForgotPasswordDto
 */
export interface ForgotPasswordDto {
    /**
     * 
     * @type {string}
     * @memberof ForgotPasswordDto
     */
    email: string;
}
/**
 * 
 * @export
 * @interface Get3DBoundaryData
 */
export interface Get3DBoundaryData {
    /**
     * 
     * @type {string}
     * @memberof Get3DBoundaryData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Get3DBoundaryData
     */
    model3DId: string;
    /**
     * 
     * @type {string}
     * @memberof Get3DBoundaryData
     */
    boundaryName: string;
    /**
     * 
     * @type {string}
     * @memberof Get3DBoundaryData
     */
    displayName: string | null;
}
/**
 * 
 * @export
 * @interface Get3DLayerData
 */
export interface Get3DLayerData {
    /**
     * 
     * @type {string}
     * @memberof Get3DLayerData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Get3DLayerData
     */
    model3DId: string;
    /**
     * 
     * @type {string}
     * @memberof Get3DLayerData
     */
    layerName: string;
    /**
     * 
     * @type {string}
     * @memberof Get3DLayerData
     */
    displayName: string | null;
}
/**
 * 
 * @export
 * @interface Get3DModelResponse
 */
export interface Get3DModelResponse {
    /**
     * 
     * @type {string}
     * @memberof Get3DModelResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Get3DModelResponse
     */
    sku: string;
    /**
     * 
     * @type {string}
     * @memberof Get3DModelResponse
     */
    file3DId: string;
    /**
     * 
     * @type {GetDirectAccessMediaFileResponse | GetPrivateAccessMediaFileResponse}
     * @memberof Get3DModelResponse
     */
    file3D: GetDirectAccessMediaFileResponse | GetPrivateAccessMediaFileResponse | null;
    /**
     * 
     * @type {Array<Get3DBoundaryData>}
     * @memberof Get3DModelResponse
     */
    boundaries: Array<Get3DBoundaryData>;
    /**
     * 
     * @type {Array<Get3DLayerData>}
     * @memberof Get3DModelResponse
     */
    layers: Array<Get3DLayerData>;
}
/**
 * 
 * @export
 * @interface GetActiveProgramProductListForProgramParentProductResponse
 */
export interface GetActiveProgramProductListForProgramParentProductResponse {
    /**
     * 
     * @type {Array<GetProgramProductListData>}
     * @memberof GetActiveProgramProductListForProgramParentProductResponse
     */
    data: Array<GetProgramProductListData>;
}
/**
 * 
 * @export
 * @interface GetAddressListData
 */
export interface GetAddressListData {
    /**
     * 
     * @type {string}
     * @memberof GetAddressListData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetAddressListData
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof GetAddressListData
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof GetAddressListData
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof GetAddressListData
     */
    phone: string;
    /**
     * 
     * @type {string}
     * @memberof GetAddressListData
     */
    addressLine1: string;
    /**
     * 
     * @type {string}
     * @memberof GetAddressListData
     */
    addressLine2: string;
    /**
     * 
     * @type {string}
     * @memberof GetAddressListData
     */
    zipCode: string;
    /**
     * 
     * @type {string}
     * @memberof GetAddressListData
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof GetAddressListData
     */
    state: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetAddressListData
     */
    isDefault: boolean;
}
/**
 * 
 * @export
 * @interface GetAddressListResponse
 */
export interface GetAddressListResponse {
    /**
     * 
     * @type {number}
     * @memberof GetAddressListResponse
     */
    nextCursor: number;
    /**
     * 
     * @type {Array<GetAddressListData>}
     * @memberof GetAddressListResponse
     */
    data: Array<GetAddressListData>;
    /**
     * 
     * @type {number}
     * @memberof GetAddressListResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetAddressResponse
 */
export interface GetAddressResponse {
    /**
     * 
     * @type {string}
     * @memberof GetAddressResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetAddressResponse
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof GetAddressResponse
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof GetAddressResponse
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof GetAddressResponse
     */
    phone: string;
    /**
     * 
     * @type {string}
     * @memberof GetAddressResponse
     */
    addressLine1: string;
    /**
     * 
     * @type {string}
     * @memberof GetAddressResponse
     */
    addressLine2: string;
    /**
     * 
     * @type {string}
     * @memberof GetAddressResponse
     */
    zipCode: string;
    /**
     * 
     * @type {string}
     * @memberof GetAddressResponse
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof GetAddressResponse
     */
    state: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetAddressResponse
     */
    isDefault: boolean;
}
/**
 * 
 * @export
 * @interface GetAdminListData
 */
export interface GetAdminListData {
    /**
     * 
     * @type {string}
     * @memberof GetAdminListData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetAdminListData
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof GetAdminListData
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof GetAdminListData
     */
    email: string;
    /**
     * 
     * @type {UserStatus}
     * @memberof GetAdminListData
     */
    status: UserStatus;
    /**
     * 
     * @type {boolean}
     * @memberof GetAdminListData
     */
    isSystemAdmin: boolean;
    /**
     * 
     * @type {Array<UserPermission>}
     * @memberof GetAdminListData
     */
    permissionList: Array<UserPermission>;
}
/**
 * 
 * @export
 * @interface GetAdminListResponse
 */
export interface GetAdminListResponse {
    /**
     * 
     * @type {number}
     * @memberof GetAdminListResponse
     */
    nextCursor: number;
    /**
     * 
     * @type {Array<GetAdminListData>}
     * @memberof GetAdminListResponse
     */
    data: Array<GetAdminListData>;
    /**
     * 
     * @type {number}
     * @memberof GetAdminListResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetAvailableRebelProductListData
 */
export interface GetAvailableRebelProductListData {
    /**
     * 
     * @type {string}
     * @memberof GetAvailableRebelProductListData
     */
    sku: string;
    /**
     * 
     * @type {string}
     * @memberof GetAvailableRebelProductListData
     */
    name: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetAvailableRebelProductListData
     */
    description: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetAvailableRebelProductListData
     */
    isPublished: boolean;
    /**
     * 
     * @type {number}
     * @memberof GetAvailableRebelProductListData
     */
    logoPrice: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetAvailableRebelProductListData
     */
    isSfActive: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetAvailableRebelProductListData
     */
    isPublishedOnce: boolean;
    /**
     * 
     * @type {number}
     * @memberof GetAvailableRebelProductListData
     */
    recommendedPrice: number | null;
    /**
     * 
     * @type {number}
     * @memberof GetAvailableRebelProductListData
     */
    minimumPrice: number | null;
    /**
     * 
     * @type {string}
     * @memberof GetAvailableRebelProductListData
     */
    category: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetAvailableRebelProductListData
     */
    sizeChartId: string | null;
    /**
     * 
     * @type {GetDirectAccessMediaFileResponse | GetPrivateAccessMediaFileResponse}
     * @memberof GetAvailableRebelProductListData
     */
    thumbnail: GetDirectAccessMediaFileResponse | GetPrivateAccessMediaFileResponse | null;
    /**
     * 
     * @type {Array<GetColoredProductListData>}
     * @memberof GetAvailableRebelProductListData
     */
    colors: Array<GetColoredProductListData>;
    /**
     * 
     * @type {GetSizeChartResponse}
     * @memberof GetAvailableRebelProductListData
     */
    sizeChart?: GetSizeChartResponse;
}
/**
 * 
 * @export
 * @interface GetAvailableRebelProductListResponse
 */
export interface GetAvailableRebelProductListResponse {
    /**
     * 
     * @type {number}
     * @memberof GetAvailableRebelProductListResponse
     */
    nextCursor: number;
    /**
     * 
     * @type {Array<GetAvailableRebelProductListData>}
     * @memberof GetAvailableRebelProductListResponse
     */
    data: Array<GetAvailableRebelProductListData>;
    /**
     * 
     * @type {number}
     * @memberof GetAvailableRebelProductListResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetCardsListData
 */
export interface GetCardsListData {
    /**
     * 
     * @type {string}
     * @memberof GetCardsListData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetCardsListData
     */
    customerId: string;
    /**
     * 
     * @type {string}
     * @memberof GetCardsListData
     */
    cardToken: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetCardsListData
     */
    cardType: string;
    /**
     * 
     * @type {string}
     * @memberof GetCardsListData
     */
    cardLast4Digit: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetCardsListData
     */
    isDefault: boolean;
}
/**
 * 
 * @export
 * @interface GetCardsListResponse
 */
export interface GetCardsListResponse {
    /**
     * 
     * @type {number}
     * @memberof GetCardsListResponse
     */
    nextCursor: number;
    /**
     * 
     * @type {Array<GetCardsListData>}
     * @memberof GetCardsListResponse
     */
    data: Array<GetCardsListData>;
    /**
     * 
     * @type {number}
     * @memberof GetCardsListResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetCartListData
 */
export interface GetCartListData {
    /**
     * 
     * @type {string}
     * @memberof GetCartListData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetCartListData
     */
    inventorySku: string | null;
    /**
     * 
     * @type {number}
     * @memberof GetCartListData
     */
    inventoryCount: number | null;
    /**
     * 
     * @type {string}
     * @memberof GetCartListData
     */
    programProductId: string;
    /**
     * 
     * @type {number}
     * @memberof GetCartListData
     */
    price: number;
    /**
     * 
     * @type {number}
     * @memberof GetCartListData
     */
    quantity: number;
    /**
     * 
     * @type {number}
     * @memberof GetCartListData
     */
    maxLimitPerOrder: number | null;
    /**
     * 
     * @type {string}
     * @memberof GetCartListData
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof GetCartListData
     */
    color: string;
    /**
     * 
     * @type {string}
     * @memberof GetCartListData
     */
    size: string;
    /**
     * 
     * @type {string}
     * @memberof GetCartListData
     */
    note: string;
    /**
     * 
     * @type {number}
     * @memberof GetCartListData
     */
    minimumOrderQuantity: number;
    /**
     * 
     * @type {number}
     * @memberof GetCartListData
     */
    receivedOrderQuantity: number;
    /**
     * 
     * @type {boolean}
     * @memberof GetCartListData
     */
    isMoqMet: boolean;
    /**
     * 
     * @type {GetPrivateAccessMediaFileResponse}
     * @memberof GetCartListData
     */
    thumbnail: GetPrivateAccessMediaFileResponse | null;
    /**
     * 
     * @type {string}
     * @memberof GetCartListData
     */
    error: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetCartListData
     */
    isIndividualShipping: boolean;
}
/**
 * 
 * @export
 * @interface GetCartListResponse
 */
export interface GetCartListResponse {
    /**
     * 
     * @type {number}
     * @memberof GetCartListResponse
     */
    nextCursor: number;
    /**
     * 
     * @type {Array<GetCartListData>}
     * @memberof GetCartListResponse
     */
    data: Array<GetCartListData>;
    /**
     * 
     * @type {number}
     * @memberof GetCartListResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetCartProductQuantityData
 */
export interface GetCartProductQuantityData {
    /**
     * 
     * @type {string}
     * @memberof GetCartProductQuantityData
     */
    programProductId: string;
    /**
     * 
     * @type {number}
     * @memberof GetCartProductQuantityData
     */
    quantity: number;
    /**
     * 
     * @type {string}
     * @memberof GetCartProductQuantityData
     */
    inventorySku: string | null;
}
/**
 * 
 * @export
 * @interface GetCartProductsQuantityListResponse
 */
export interface GetCartProductsQuantityListResponse {
    /**
     * 
     * @type {Array<GetCartProductQuantityData>}
     * @memberof GetCartProductsQuantityListResponse
     */
    data: Array<GetCartProductQuantityData>;
    /**
     * 
     * @type {number}
     * @memberof GetCartProductsQuantityListResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetColoredProductLayersListData
 */
export interface GetColoredProductLayersListData {
    /**
     * 
     * @type {string}
     * @memberof GetColoredProductLayersListData
     */
    coloredProductId: string;
    /**
     * 
     * @type {Array<GetLayerDataResponse>}
     * @memberof GetColoredProductLayersListData
     */
    layers: Array<GetLayerDataResponse>;
}
/**
 * 
 * @export
 * @interface GetColoredProductListData
 */
export interface GetColoredProductListData {
    /**
     * 
     * @type {string}
     * @memberof GetColoredProductListData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetColoredProductListData
     */
    sku: string;
    /**
     * 
     * @type {string}
     * @memberof GetColoredProductListData
     */
    parentSku: string;
    /**
     * 
     * @type {string}
     * @memberof GetColoredProductListData
     */
    color: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetColoredProductListData
     */
    thumbnailId: string | null;
    /**
     * 
     * @type {ProductStatus}
     * @memberof GetColoredProductListData
     */
    status: ProductStatus;
    /**
     * 
     * @type {string}
     * @memberof GetColoredProductListData
     */
    swatchFirstColor: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetColoredProductListData
     */
    swatchSecondColor: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetColoredProductListData
     */
    isSfActive: boolean;
    /**
     * 
     * @type {Array<GetProductInventoryListData>}
     * @memberof GetColoredProductListData
     */
    inventories: Array<GetProductInventoryListData>;
    /**
     * 
     * @type {GetDirectAccessMediaFileResponse | GetPrivateAccessMediaFileResponse}
     * @memberof GetColoredProductListData
     */
    thumbnail: GetDirectAccessMediaFileResponse | GetPrivateAccessMediaFileResponse | null;
}
/**
 * 
 * @export
 * @interface GetColouredProductResponse
 */
export interface GetColouredProductResponse {
    /**
     * 
     * @type {string}
     * @memberof GetColouredProductResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetColouredProductResponse
     */
    sku: string;
    /**
     * 
     * @type {string}
     * @memberof GetColouredProductResponse
     */
    parentSku: string;
    /**
     * 
     * @type {string}
     * @memberof GetColouredProductResponse
     */
    color: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetColouredProductResponse
     */
    thumbnailId: string | null;
    /**
     * 
     * @type {ProductStatus}
     * @memberof GetColouredProductResponse
     */
    status: ProductStatus;
    /**
     * 
     * @type {string}
     * @memberof GetColouredProductResponse
     */
    swatchFirstColor: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetColouredProductResponse
     */
    swatchSecondColor: string | null;
    /**
     * 
     * @type {number}
     * @memberof GetColouredProductResponse
     */
    productPriceOverride: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetColouredProductResponse
     */
    isSfActive: boolean;
    /**
     * 
     * @type {Array<GetProductInventoryListData>}
     * @memberof GetColouredProductResponse
     */
    inventories: Array<GetProductInventoryListData>;
    /**
     * 
     * @type {Array<GetProductImageData>}
     * @memberof GetColouredProductResponse
     */
    images: Array<GetProductImageData>;
    /**
     * 
     * @type {Array<GetLayerDataResponse>}
     * @memberof GetColouredProductResponse
     */
    layers: Array<GetLayerDataResponse>;
}
/**
 * 
 * @export
 * @interface GetCreatedIdResponse
 */
export interface GetCreatedIdResponse {
    /**
     * 
     * @type {string}
     * @memberof GetCreatedIdResponse
     */
    id: string;
}
/**
 * 
 * @export
 * @interface GetCustomerBulkUpdateData
 */
export interface GetCustomerBulkUpdateData {
    /**
     * 
     * @type {string}
     * @memberof GetCustomerBulkUpdateData
     */
    customerId: string;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerBulkUpdateData
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerBulkUpdateData
     */
    message: string;
}
/**
 * 
 * @export
 * @interface GetCustomerBulkUpdateFailedResponse
 */
export interface GetCustomerBulkUpdateFailedResponse {
    /**
     * 
     * @type {Array<GetCustomerBulkUpdateData>}
     * @memberof GetCustomerBulkUpdateFailedResponse
     */
    failedRecords: Array<GetCustomerBulkUpdateData>;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerBulkUpdateFailedResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetCustomerBulkUploadHistoryResponse
 */
export interface GetCustomerBulkUploadHistoryResponse {
    /**
     * 
     * @type {number}
     * @memberof GetCustomerBulkUploadHistoryResponse
     */
    nextCursor: number;
    /**
     * 
     * @type {Array<GetHistoryData>}
     * @memberof GetCustomerBulkUploadHistoryResponse
     */
    data: Array<GetHistoryData>;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerBulkUploadHistoryResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetCustomerBulkUploadResponse
 */
export interface GetCustomerBulkUploadResponse {
    /**
     * 
     * @type {string}
     * @memberof GetCustomerBulkUploadResponse
     */
    reportFile: string;
}
/**
 * 
 * @export
 * @interface GetCustomerCartSubTotalDetailsResponse
 */
export interface GetCustomerCartSubTotalDetailsResponse {
    /**
     * 
     * @type {string}
     * @memberof GetCustomerCartSubTotalDetailsResponse
     */
    customerId: string;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerCartSubTotalDetailsResponse
     */
    subTotal: number;
}
/**
 * 
 * @export
 * @interface GetCustomerCartSummaryDetailsResponse
 */
export interface GetCustomerCartSummaryDetailsResponse {
    /**
     * 
     * @type {string}
     * @memberof GetCustomerCartSummaryDetailsResponse
     */
    customerId: string;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerCartSummaryDetailsResponse
     */
    subTotal: number;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerCartSummaryDetailsResponse
     */
    estimatedShipping: number | null;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerCartSummaryDetailsResponse
     */
    estimatedTax: number | null;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerCartSummaryDetailsResponse
     */
    totalPrice: number | null;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerCartSummaryDetailsResponse
     */
    shipping: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerCartSummaryDetailsResponse
     */
    bulkShippingStreet: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerCartSummaryDetailsResponse
     */
    bulkShippingCity: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerCartSummaryDetailsResponse
     */
    bulkShippingState: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerCartSummaryDetailsResponse
     */
    bulkShippingZipCode: string | null;
}
/**
 * 
 * @export
 * @interface GetCustomerCountByStatusResponse
 */
export interface GetCustomerCountByStatusResponse {
    /**
     * 
     * @type {number}
     * @memberof GetCustomerCountByStatusResponse
     */
    active: number;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerCountByStatusResponse
     */
    inactive: number;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerCountByStatusResponse
     */
    deactivated: number;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerCountByStatusResponse
     */
    invited: number;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerCountByStatusResponse
     */
    requested: number;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerCountByStatusResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetCustomerFavoriteProductData
 */
export interface GetCustomerFavoriteProductData {
    /**
     * 
     * @type {string}
     * @memberof GetCustomerFavoriteProductData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerFavoriteProductData
     */
    customerId: string;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerFavoriteProductData
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerFavoriteProductData
     */
    price: number;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerFavoriteProductData
     */
    programProductId: string;
    /**
     * 
     * @type {GetPrivateAccessMediaFileResponse}
     * @memberof GetCustomerFavoriteProductData
     */
    thumbnail: GetPrivateAccessMediaFileResponse | null;
    /**
     * 
     * @type {Array<GetMinimalProgramColoredProductData>}
     * @memberof GetCustomerFavoriteProductData
     */
    availableColors: Array<GetMinimalProgramColoredProductData>;
}
/**
 * 
 * @export
 * @interface GetCustomerFavoriteProductListResponse
 */
export interface GetCustomerFavoriteProductListResponse {
    /**
     * 
     * @type {number}
     * @memberof GetCustomerFavoriteProductListResponse
     */
    nextCursor: number;
    /**
     * 
     * @type {Array<GetCustomerFavoriteProductData>}
     * @memberof GetCustomerFavoriteProductListResponse
     */
    data: Array<GetCustomerFavoriteProductData>;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerFavoriteProductListResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetCustomerGroupOrdersData
 */
export interface GetCustomerGroupOrdersData {
    /**
     * 
     * @type {string}
     * @memberof GetCustomerGroupOrdersData
     */
    orderId: string;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerGroupOrdersData
     */
    orderDisplayId: string;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerGroupOrdersData
     */
    sfOrderId: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerGroupOrdersData
     */
    orderItemId: string;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerGroupOrdersData
     */
    orderItemDisplayId: string;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerGroupOrdersData
     */
    orderedDate: string;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerGroupOrdersData
     */
    programProductId: string;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerGroupOrdersData
     */
    productName: string;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerGroupOrdersData
     */
    price: number;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerGroupOrdersData
     */
    paidAmount: number;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerGroupOrdersData
     */
    taxFee: number;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerGroupOrdersData
     */
    size: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerGroupOrdersData
     */
    color: string | null;
    /**
     * 
     * @type {OrderStatus}
     * @memberof GetCustomerGroupOrdersData
     */
    status: OrderStatus;
    /**
     * 
     * @type {OrderPaidStatus}
     * @memberof GetCustomerGroupOrdersData
     */
    orderPaidStatus: OrderPaidStatus;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerGroupOrdersData
     */
    quantity: number;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerGroupOrdersData
     */
    expectedDate: string;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerGroupOrdersData
     */
    deliveredDate: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetCustomerGroupOrdersData
     */
    isCustom: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerGroupOrdersData
     */
    inventorySku: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetCustomerGroupOrdersData
     */
    isReturnable: boolean;
    /**
     * 
     * @type {object}
     * @memberof GetCustomerGroupOrdersData
     */
    returnableDate: object;
    /**
     * 
     * @type {boolean}
     * @memberof GetCustomerGroupOrdersData
     */
    isCancelable: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetCustomerGroupOrdersData
     */
    isMoqMet: boolean;
    /**
     * 
     * @type {object}
     * @memberof GetCustomerGroupOrdersData
     */
    cancelledAt: object;
    /**
     * 
     * @type {boolean}
     * @memberof GetCustomerGroupOrdersData
     */
    isCustomizableProduct: boolean;
    /**
     * 
     * @type {GetPrivateAccessMediaFileResponse}
     * @memberof GetCustomerGroupOrdersData
     */
    thumbnail: GetPrivateAccessMediaFileResponse | null;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerGroupOrdersData
     */
    productMinimumOrderQuantity: number;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerGroupOrdersData
     */
    productReceivedOrderQuantity: number;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerGroupOrdersData
     */
    cancelledBy: string | null;
    /**
     * 
     * @type {CustomerForInvoice}
     * @memberof GetCustomerGroupOrdersData
     */
    cancelledUser: CustomerForInvoice;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerGroupOrdersData
     */
    orderGroupId: string;
}
/**
 * 
 * @export
 * @interface GetCustomerGroupedOrdersListResponse
 */
export interface GetCustomerGroupedOrdersListResponse {
    /**
     * 
     * @type {Array<GetCustomerGroupOrdersData>}
     * @memberof GetCustomerGroupedOrdersListResponse
     */
    data: Array<GetCustomerGroupOrdersData>;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerGroupedOrdersListResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetCustomerOrdersData
 */
export interface GetCustomerOrdersData {
    /**
     * 
     * @type {string}
     * @memberof GetCustomerOrdersData
     */
    orderId: string;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerOrdersData
     */
    orderGroupId: string;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerOrdersData
     */
    orderDisplayId: string;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerOrdersData
     */
    sfOrderId: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerOrdersData
     */
    orderItemId: string;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerOrdersData
     */
    orderItemDisplayId: string;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerOrdersData
     */
    orderedDate: string;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerOrdersData
     */
    programProductId: string;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerOrdersData
     */
    productName: string;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerOrdersData
     */
    price: number;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerOrdersData
     */
    paidAmount: number;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerOrdersData
     */
    taxFee: number;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerOrdersData
     */
    size: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerOrdersData
     */
    color: string | null;
    /**
     * 
     * @type {OrderStatus}
     * @memberof GetCustomerOrdersData
     */
    status: OrderStatus;
    /**
     * 
     * @type {OrderPaidStatus}
     * @memberof GetCustomerOrdersData
     */
    orderPaidStatus: OrderPaidStatus;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerOrdersData
     */
    quantity: number;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerOrdersData
     */
    expectedDate: string;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerOrdersData
     */
    deliveredDate: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetCustomerOrdersData
     */
    isCustom: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerOrdersData
     */
    inventorySku: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetCustomerOrdersData
     */
    isReturnable: boolean;
    /**
     * 
     * @type {object}
     * @memberof GetCustomerOrdersData
     */
    returnableDate: object;
    /**
     * 
     * @type {boolean}
     * @memberof GetCustomerOrdersData
     */
    isCancelable: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetCustomerOrdersData
     */
    isMoqMet: boolean;
    /**
     * 
     * @type {object}
     * @memberof GetCustomerOrdersData
     */
    cancelledAt: object;
    /**
     * 
     * @type {boolean}
     * @memberof GetCustomerOrdersData
     */
    isCustomizableProduct: boolean;
    /**
     * 
     * @type {GetPrivateAccessMediaFileResponse}
     * @memberof GetCustomerOrdersData
     */
    thumbnail: GetPrivateAccessMediaFileResponse | null;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerOrdersData
     */
    productMinimumOrderQuantity: number;
    /**
     * 
     * @type {boolean}
     * @memberof GetCustomerOrdersData
     */
    hasReturns: boolean;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerOrdersData
     */
    productReceivedOrderQuantity: number;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerOrdersData
     */
    cancelledBy: string | null;
    /**
     * 
     * @type {CustomerForInvoice}
     * @memberof GetCustomerOrdersData
     */
    cancelledUser: CustomerForInvoice;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerOrdersData
     */
    returnableQuantity: number;
}
/**
 * 
 * @export
 * @interface GetCustomerOrdersListResponse
 */
export interface GetCustomerOrdersListResponse {
    /**
     * 
     * @type {number}
     * @memberof GetCustomerOrdersListResponse
     */
    nextCursor: number;
    /**
     * 
     * @type {Array<GetCustomerOrdersData>}
     * @memberof GetCustomerOrdersListResponse
     */
    data: Array<GetCustomerOrdersData>;
    /**
     * 
     * @type {number}
     * @memberof GetCustomerOrdersListResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetCustomerProfileResponse
 */
export interface GetCustomerProfileResponse {
    /**
     * 
     * @type {string}
     * @memberof GetCustomerProfileResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerProfileResponse
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerProfileResponse
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerProfileResponse
     */
    email: string;
    /**
     * 
     * @type {UserStatus}
     * @memberof GetCustomerProfileResponse
     */
    status: UserStatus;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerProfileResponse
     */
    programId: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerProfileResponse
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof GetCustomerProfileResponse
     */
    updatedAt: string;
}
/**
 * 
 * @export
 * @interface GetDirectAccessMediaFileResponse
 */
export interface GetDirectAccessMediaFileResponse {
    /**
     * 
     * @type {string}
     * @memberof GetDirectAccessMediaFileResponse
     */
    directUrl: string;
    /**
     * 
     * @type {string}
     * @memberof GetDirectAccessMediaFileResponse
     */
    type: string;
    /**
     * 
     * @type {MediaFileMetadata}
     * @memberof GetDirectAccessMediaFileResponse
     */
    metadata: MediaFileMetadata;
}
/**
 * 
 * @export
 * @interface GetGroupedOrdersCheckoutSummaryResponse
 */
export interface GetGroupedOrdersCheckoutSummaryResponse {
    /**
     * 
     * @type {number}
     * @memberof GetGroupedOrdersCheckoutSummaryResponse
     */
    storeCreditsApplied: number;
    /**
     * 
     * @type {number}
     * @memberof GetGroupedOrdersCheckoutSummaryResponse
     */
    tax: number;
    /**
     * 
     * @type {number}
     * @memberof GetGroupedOrdersCheckoutSummaryResponse
     */
    shipping: number;
    /**
     * 
     * @type {number}
     * @memberof GetGroupedOrdersCheckoutSummaryResponse
     */
    subTotal: number;
    /**
     * 
     * @type {number}
     * @memberof GetGroupedOrdersCheckoutSummaryResponse
     */
    total: number;
    /**
     * 
     * @type {number}
     * @memberof GetGroupedOrdersCheckoutSummaryResponse
     */
    cancelledAmount: number;
    /**
     * 
     * @type {number}
     * @memberof GetGroupedOrdersCheckoutSummaryResponse
     */
    balanceToPay: number;
    /**
     * 
     * @type {Array<GetOrderItemShippingAddress>}
     * @memberof GetGroupedOrdersCheckoutSummaryResponse
     */
    orderItemShippingDetailslist: Array<GetOrderItemShippingAddress>;
    /**
     * 
     * @type {OrderAddressForInvoice}
     * @memberof GetGroupedOrdersCheckoutSummaryResponse
     */
    bulkShippingAddress: OrderAddressForInvoice | null;
    /**
     * 
     * @type {OrderAddressForInvoice}
     * @memberof GetGroupedOrdersCheckoutSummaryResponse
     */
    individualShippingAddress: OrderAddressForInvoice | null;
}
/**
 * 
 * @export
 * @interface GetHistoryData
 */
export interface GetHistoryData {
    /**
     * 
     * @type {string}
     * @memberof GetHistoryData
     */
    id: string;
    /**
     * 
     * @type {number}
     * @memberof GetHistoryData
     */
    successCount: number;
    /**
     * 
     * @type {number}
     * @memberof GetHistoryData
     */
    failedCount: number;
    /**
     * 
     * @type {number}
     * @memberof GetHistoryData
     */
    skippedCount: number;
    /**
     * 
     * @type {string}
     * @memberof GetHistoryData
     */
    uploadedFileUrl: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetHistoryData
     */
    reportFileUrl: string | null;
}
/**
 * 
 * @export
 * @interface GetLayerDataResponse
 */
export interface GetLayerDataResponse {
    /**
     * 
     * @type {string}
     * @memberof GetLayerDataResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetLayerDataResponse
     */
    coloredProductId: string;
    /**
     * 
     * @type {string}
     * @memberof GetLayerDataResponse
     */
    layerId: string;
    /**
     * 
     * @type {string}
     * @memberof GetLayerDataResponse
     */
    color: string | null;
}
/**
 * 
 * @export
 * @interface GetMinOrderQuantityAndReceivedOrderQuantityResponse
 */
export interface GetMinOrderQuantityAndReceivedOrderQuantityResponse {
    /**
     * 
     * @type {number}
     * @memberof GetMinOrderQuantityAndReceivedOrderQuantityResponse
     */
    minimumOrderQuantity: number;
    /**
     * 
     * @type {number}
     * @memberof GetMinOrderQuantityAndReceivedOrderQuantityResponse
     */
    receivedOrderQuantity: number;
    /**
     * 
     * @type {boolean}
     * @memberof GetMinOrderQuantityAndReceivedOrderQuantityResponse
     */
    isMoqMet: boolean;
}
/**
 * 
 * @export
 * @interface GetMinimalColoredProductData
 */
export interface GetMinimalColoredProductData {
    /**
     * 
     * @type {string}
     * @memberof GetMinimalColoredProductData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetMinimalColoredProductData
     */
    sku: string;
    /**
     * 
     * @type {string}
     * @memberof GetMinimalColoredProductData
     */
    color: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetMinimalColoredProductData
     */
    swatchFirstColor: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetMinimalColoredProductData
     */
    swatchSecondColor: string | null;
    /**
     * 
     * @type {ProductStatus}
     * @memberof GetMinimalColoredProductData
     */
    status: ProductStatus;
    /**
     * 
     * @type {boolean}
     * @memberof GetMinimalColoredProductData
     */
    isSfActive: boolean;
    /**
     * 
     * @type {Array<GetLayerDataResponse>}
     * @memberof GetMinimalColoredProductData
     */
    layers: Array<GetLayerDataResponse>;
    /**
     * 
     * @type {number}
     * @memberof GetMinimalColoredProductData
     */
    productPriceOverride: number | null;
    /**
     * 
     * @type {number}
     * @memberof GetMinimalColoredProductData
     */
    minimumOrderQuantity: number | null;
}
/**
 * 
 * @export
 * @interface GetMinimalParentProductListData
 */
export interface GetMinimalParentProductListData {
    /**
     * 
     * @type {string}
     * @memberof GetMinimalParentProductListData
     */
    sku: string;
    /**
     * 
     * @type {string}
     * @memberof GetMinimalParentProductListData
     */
    name: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetMinimalParentProductListData
     */
    isPublished: boolean;
    /**
     * 
     * @type {number}
     * @memberof GetMinimalParentProductListData
     */
    logoPrice: number;
    /**
     * 
     * @type {boolean}
     * @memberof GetMinimalParentProductListData
     */
    isSfActive: boolean;
}
/**
 * 
 * @export
 * @interface GetMinimalParentProductListResponse
 */
export interface GetMinimalParentProductListResponse {
    /**
     * 
     * @type {number}
     * @memberof GetMinimalParentProductListResponse
     */
    nextCursor: number;
    /**
     * 
     * @type {Array<GetMinimalParentProductListData>}
     * @memberof GetMinimalParentProductListResponse
     */
    data: Array<GetMinimalParentProductListData>;
    /**
     * 
     * @type {number}
     * @memberof GetMinimalParentProductListResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetMinimalProgramColoredProductData
 */
export interface GetMinimalProgramColoredProductData {
    /**
     * 
     * @type {string}
     * @memberof GetMinimalProgramColoredProductData
     */
    programProductId: string;
    /**
     * 
     * @type {string}
     * @memberof GetMinimalProgramColoredProductData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetMinimalProgramColoredProductData
     */
    color: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetMinimalProgramColoredProductData
     */
    swatchFirstColor: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetMinimalProgramColoredProductData
     */
    swatchSecondColor: string | null;
    /**
     * 
     * @type {ProductStatus}
     * @memberof GetMinimalProgramColoredProductData
     */
    status: ProductStatus;
    /**
     * 
     * @type {boolean}
     * @memberof GetMinimalProgramColoredProductData
     */
    isSfActive: boolean;
    /**
     * 
     * @type {GetPrivateAccessMediaFileResponse}
     * @memberof GetMinimalProgramColoredProductData
     */
    thumbnail: GetPrivateAccessMediaFileResponse;
    /**
     * 
     * @type {number}
     * @memberof GetMinimalProgramColoredProductData
     */
    price: number;
}
/**
 * 
 * @export
 * @interface GetMinimalProgramProductData
 */
export interface GetMinimalProgramProductData {
    /**
     * 
     * @type {string}
     * @memberof GetMinimalProgramProductData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetMinimalProgramProductData
     */
    programParentProductId: string;
    /**
     * 
     * @type {string}
     * @memberof GetMinimalProgramProductData
     */
    coloredProductId: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetMinimalProgramProductData
     */
    isActive: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetMinimalProgramProductData
     */
    swatchFirstColor: string | null;
    /**
     * 
     * @type {number}
     * @memberof GetMinimalProgramProductData
     */
    price: number | null;
    /**
     * 
     * @type {string}
     * @memberof GetMinimalProgramProductData
     */
    swatchSecondColor: string | null;
    /**
     * 
     * @type {GetPrivateAccessMediaFileResponse}
     * @memberof GetMinimalProgramProductData
     */
    thumbnail: GetPrivateAccessMediaFileResponse | null;
    /**
     * 
     * @type {string}
     * @memberof GetMinimalProgramProductData
     */
    thumbnailId: string | null;
    /**
     * 
     * @type {GetMinimalColoredProductData}
     * @memberof GetMinimalProgramProductData
     */
    coloredProduct: GetMinimalColoredProductData | null;
    /**
     * 
     * @type {number}
     * @memberof GetMinimalProgramProductData
     */
    cost: number;
}
/**
 * 
 * @export
 * @interface GetMinimalPublishedColoredProductListResponse
 */
export interface GetMinimalPublishedColoredProductListResponse {
    /**
     * 
     * @type {Array<GetMinimalColoredProductData>}
     * @memberof GetMinimalPublishedColoredProductListResponse
     */
    data: Array<GetMinimalColoredProductData>;
    /**
     * 
     * @type {number}
     * @memberof GetMinimalPublishedColoredProductListResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetMinimalSFParentProduct
 */
export interface GetMinimalSFParentProduct {
    /**
     * 
     * @type {string}
     * @memberof GetMinimalSFParentProduct
     */
    sku: string;
    /**
     * 
     * @type {string}
     * @memberof GetMinimalSFParentProduct
     */
    name: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetMinimalSFParentProduct
     */
    description: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetMinimalSFParentProduct
     */
    isPublished: boolean;
    /**
     * 
     * @type {number}
     * @memberof GetMinimalSFParentProduct
     */
    logoPrice: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetMinimalSFParentProduct
     */
    isSfActive: boolean;
    /**
     * 
     * @type {Artwork}
     * @memberof GetMinimalSFParentProduct
     */
    artworkType: Artwork;
}
/**
 * 
 * @export
 * @interface GetMinimalSFParentProductWithMinimalColorData
 */
export interface GetMinimalSFParentProductWithMinimalColorData {
    /**
     * 
     * @type {string}
     * @memberof GetMinimalSFParentProductWithMinimalColorData
     */
    sku: string;
    /**
     * 
     * @type {string}
     * @memberof GetMinimalSFParentProductWithMinimalColorData
     */
    name: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetMinimalSFParentProductWithMinimalColorData
     */
    description: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetMinimalSFParentProductWithMinimalColorData
     */
    isPublished: boolean;
    /**
     * 
     * @type {number}
     * @memberof GetMinimalSFParentProductWithMinimalColorData
     */
    logoPrice: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetMinimalSFParentProductWithMinimalColorData
     */
    isSfActive: boolean;
    /**
     * 
     * @type {Array<GetMinimalColoredProductData>}
     * @memberof GetMinimalSFParentProductWithMinimalColorData
     */
    colors: Array<GetMinimalColoredProductData>;
    /**
     * 
     * @type {Artwork}
     * @memberof GetMinimalSFParentProductWithMinimalColorData
     */
    artworkType: Artwork;
    /**
     * 
     * @type {Array<GetParentTexturesListData>}
     * @memberof GetMinimalSFParentProductWithMinimalColorData
     */
    artworkTextures: Array<GetParentTexturesListData>;
}
/**
 * 
 * @export
 * @interface GetModel3DFileResponse
 */
export interface GetModel3DFileResponse {
    /**
     * 
     * @type {string}
     * @memberof GetModel3DFileResponse
     */
    url: string;
}
/**
 * 
 * @export
 * @interface GetMoqNotMetProductOrderData
 */
export interface GetMoqNotMetProductOrderData {
    /**
     * 
     * @type {string}
     * @memberof GetMoqNotMetProductOrderData
     */
    programProductId: string;
    /**
     * 
     * @type {string}
     * @memberof GetMoqNotMetProductOrderData
     */
    coloredProductId: string;
    /**
     * 
     * @type {string}
     * @memberof GetMoqNotMetProductOrderData
     */
    programId: string;
    /**
     * 
     * @type {string}
     * @memberof GetMoqNotMetProductOrderData
     */
    programName: string;
    /**
     * 
     * @type {number}
     * @memberof GetMoqNotMetProductOrderData
     */
    receivedOrderQuantity: number;
    /**
     * 
     * @type {number}
     * @memberof GetMoqNotMetProductOrderData
     */
    minimumOrderQuantity: number;
    /**
     * 
     * @type {string}
     * @memberof GetMoqNotMetProductOrderData
     */
    productTitle: string;
}
/**
 * 
 * @export
 * @interface GetMoqNotMetProductOrderListResponse
 */
export interface GetMoqNotMetProductOrderListResponse {
    /**
     * 
     * @type {number}
     * @memberof GetMoqNotMetProductOrderListResponse
     */
    nextCursor: number;
    /**
     * 
     * @type {Array<GetMoqNotMetProductOrderData>}
     * @memberof GetMoqNotMetProductOrderListResponse
     */
    data: Array<GetMoqNotMetProductOrderData>;
}
/**
 * 
 * @export
 * @interface GetMultipleFileUploadResponse
 */
export interface GetMultipleFileUploadResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetMultipleFileUploadResponse
     */
    ids: Array<string>;
}
/**
 * 
 * @export
 * @interface GetOrderData
 */
export interface GetOrderData {
    /**
     * 
     * @type {string}
     * @memberof GetOrderData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderData
     */
    displayId: string;
    /**
     * 
     * @type {Array<GetOrderItemData>}
     * @memberof GetOrderData
     */
    orderItems: Array<GetOrderItemData>;
}
/**
 * 
 * @export
 * @interface GetOrderDetailsResponse
 */
export interface GetOrderDetailsResponse {
    /**
     * 
     * @type {string}
     * @memberof GetOrderDetailsResponse
     */
    orderId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderDetailsResponse
     */
    orderDisplayId: string;
    /**
     * 
     * @type {object}
     * @memberof GetOrderDetailsResponse
     */
    sfOrderId: object;
    /**
     * 
     * @type {string}
     * @memberof GetOrderDetailsResponse
     */
    orderedDate: string;
    /**
     * 
     * @type {object}
     * @memberof GetOrderDetailsResponse
     */
    expectedDate: object;
    /**
     * 
     * @type {string}
     * @memberof GetOrderDetailsResponse
     */
    transactionId: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetOrderDetailsResponse
     */
    customerId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderDetailsResponse
     */
    customerCardId: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetOrderDetailsResponse
     */
    programId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderDetailsResponse
     */
    billingAddressId: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetOrderDetailsResponse
     */
    shippingAddressId: string;
    /**
     * 
     * @type {object}
     * @memberof GetOrderDetailsResponse
     */
    shippingLabelId: object;
    /**
     * 
     * @type {boolean}
     * @memberof GetOrderDetailsResponse
     */
    isSyncedToSalesforce: boolean;
    /**
     * 
     * @type {object}
     * @memberof GetOrderDetailsResponse
     */
    storeCreditsPaid: object;
    /**
     * 
     * @type {object}
     * @memberof GetOrderDetailsResponse
     */
    shippingLabelError: object;
    /**
     * 
     * @type {number}
     * @memberof GetOrderDetailsResponse
     */
    totalTax: number;
    /**
     * 
     * @type {number}
     * @memberof GetOrderDetailsResponse
     */
    shippingFee: number;
    /**
     * 
     * @type {number}
     * @memberof GetOrderDetailsResponse
     */
    subTotal: number;
    /**
     * 
     * @type {number}
     * @memberof GetOrderDetailsResponse
     */
    tax: number;
    /**
     * 
     * @type {number}
     * @memberof GetOrderDetailsResponse
     */
    grandTotal: number;
    /**
     * 
     * @type {OrderAddressForInvoice}
     * @memberof GetOrderDetailsResponse
     */
    billingAddress: OrderAddressForInvoice | null;
    /**
     * 
     * @type {OrderAddressForInvoice}
     * @memberof GetOrderDetailsResponse
     */
    shippingAddress: OrderAddressForInvoice;
    /**
     * 
     * @type {CustomerForInvoice}
     * @memberof GetOrderDetailsResponse
     */
    customer: CustomerForInvoice;
    /**
     * 
     * @type {Array<GetOrderItemData>}
     * @memberof GetOrderDetailsResponse
     */
    orderItems: Array<GetOrderItemData>;
}
/**
 * 
 * @export
 * @interface GetOrderFileResponse
 */
export interface GetOrderFileResponse {
    /**
     * 
     * @type {string}
     * @memberof GetOrderFileResponse
     */
    url: string;
}
/**
 * 
 * @export
 * @interface GetOrderGroupInvoiceResponse
 */
export interface GetOrderGroupInvoiceResponse {
    /**
     * 
     * @type {string}
     * @memberof GetOrderGroupInvoiceResponse
     */
    orderGroupId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderGroupInvoiceResponse
     */
    transactionId: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetOrderGroupInvoiceResponse
     */
    customerId: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetOrderGroupInvoiceResponse
     */
    customerCardId: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetOrderGroupInvoiceResponse
     */
    programId: string;
    /**
     * 
     * @type {number}
     * @memberof GetOrderGroupInvoiceResponse
     */
    subTotal: number;
    /**
     * 
     * @type {number}
     * @memberof GetOrderGroupInvoiceResponse
     */
    total: number;
    /**
     * 
     * @type {number}
     * @memberof GetOrderGroupInvoiceResponse
     */
    shippingFee: number;
    /**
     * 
     * @type {number}
     * @memberof GetOrderGroupInvoiceResponse
     */
    tax: number;
    /**
     * 
     * @type {number}
     * @memberof GetOrderGroupInvoiceResponse
     */
    amountPaidByCC: number;
    /**
     * 
     * @type {number}
     * @memberof GetOrderGroupInvoiceResponse
     */
    billingAddressId: number | null;
    /**
     * 
     * @type {string}
     * @memberof GetOrderGroupInvoiceResponse
     */
    createdAt: string;
    /**
     * 
     * @type {OrderAddressForInvoice}
     * @memberof GetOrderGroupInvoiceResponse
     */
    billingAddress: OrderAddressForInvoice;
    /**
     * 
     * @type {OrderAddressForInvoice}
     * @memberof GetOrderGroupInvoiceResponse
     */
    individualShippingAddress: OrderAddressForInvoice | null;
    /**
     * 
     * @type {OrderAddressForInvoice}
     * @memberof GetOrderGroupInvoiceResponse
     */
    bulkShippingAddress: OrderAddressForInvoice | null;
    /**
     * 
     * @type {OrderAddressForInvoice}
     * @memberof GetOrderGroupInvoiceResponse
     */
    customerCard: OrderAddressForInvoice | null;
    /**
     * 
     * @type {CustomerForInvoice}
     * @memberof GetOrderGroupInvoiceResponse
     */
    customer: CustomerForInvoice;
    /**
     * 
     * @type {number}
     * @memberof GetOrderGroupInvoiceResponse
     */
    storeCreditsPaid: number | null;
    /**
     * 
     * @type {string}
     * @memberof GetOrderGroupInvoiceResponse
     */
    invoiceCardType: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetOrderGroupInvoiceResponse
     */
    invoiceCardLast4Digits: string | null;
    /**
     * 
     * @type {Array<GetOrderInvoiceResponse>}
     * @memberof GetOrderGroupInvoiceResponse
     */
    orders: Array<GetOrderInvoiceResponse>;
}
/**
 * 
 * @export
 * @interface GetOrderInvoiceResponse
 */
export interface GetOrderInvoiceResponse {
    /**
     * 
     * @type {string}
     * @memberof GetOrderInvoiceResponse
     */
    orderId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderInvoiceResponse
     */
    orderDisplayId: string;
    /**
     * 
     * @type {number}
     * @memberof GetOrderInvoiceResponse
     */
    shippingFee: number | null;
    /**
     * 
     * @type {number}
     * @memberof GetOrderInvoiceResponse
     */
    subTotal: number;
    /**
     * 
     * @type {number}
     * @memberof GetOrderInvoiceResponse
     */
    tax: number;
    /**
     * 
     * @type {OrderAddressForInvoice}
     * @memberof GetOrderInvoiceResponse
     */
    shippingAddress: OrderAddressForInvoice;
    /**
     * 
     * @type {boolean}
     * @memberof GetOrderInvoiceResponse
     */
    isBulkShipping: boolean;
    /**
     * 
     * @type {Array<OrderItemForInvoice>}
     * @memberof GetOrderInvoiceResponse
     */
    orderItems: Array<OrderItemForInvoice>;
}
/**
 * 
 * @export
 * @interface GetOrderItemData
 */
export interface GetOrderItemData {
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemData
     */
    orderDisplayId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemData
     */
    orderItemId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemData
     */
    orderItemDisplayId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemData
     */
    orderedDate: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemData
     */
    programId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemData
     */
    programName: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemData
     */
    programProductId: string;
    /**
     * 
     * @type {number}
     * @memberof GetOrderItemData
     */
    cost: number;
    /**
     * 
     * @type {number}
     * @memberof GetOrderItemData
     */
    logoQuantity: number;
    /**
     * 
     * @type {number}
     * @memberof GetOrderItemData
     */
    logoPrice: number;
    /**
     * 
     * @type {number}
     * @memberof GetOrderItemData
     */
    total: number;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemData
     */
    productName: string;
    /**
     * 
     * @type {number}
     * @memberof GetOrderItemData
     */
    orderQuantity: number;
    /**
     * 
     * @type {number}
     * @memberof GetOrderItemData
     */
    paidAmount: number;
    /**
     * 
     * @type {number}
     * @memberof GetOrderItemData
     */
    profit: number;
    /**
     * 
     * @type {boolean}
     * @memberof GetOrderItemData
     */
    isCustom: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetOrderItemData
     */
    hasReturns: boolean;
    /**
     * 
     * @type {OrderStatus}
     * @memberof GetOrderItemData
     */
    status: OrderStatus;
    /**
     * 
     * @type {GetPrivateAccessMediaFileResponse}
     * @memberof GetOrderItemData
     */
    thumbnail: GetPrivateAccessMediaFileResponse | null;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemData
     */
    size: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemData
     */
    color: string | null;
}
/**
 * 
 * @export
 * @interface GetOrderItemDetailsResponse
 */
export interface GetOrderItemDetailsResponse {
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemDetailsResponse
     */
    orderId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemDetailsResponse
     */
    orderDisplayId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemDetailsResponse
     */
    sfOrderId: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemDetailsResponse
     */
    orderItemId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemDetailsResponse
     */
    orderItemDisplayId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemDetailsResponse
     */
    orderedDate: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemDetailsResponse
     */
    programId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemDetailsResponse
     */
    programName: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemDetailsResponse
     */
    programProductId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemDetailsResponse
     */
    productName: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemDetailsResponse
     */
    customerFirstName: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemDetailsResponse
     */
    customerLastName: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemDetailsResponse
     */
    customerPhone: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemDetailsResponse
     */
    customerEmail: string;
    /**
     * 
     * @type {number}
     * @memberof GetOrderItemDetailsResponse
     */
    orderQuantity: number;
    /**
     * 
     * @type {number}
     * @memberof GetOrderItemDetailsResponse
     */
    taxFee: number;
    /**
     * 
     * @type {number}
     * @memberof GetOrderItemDetailsResponse
     */
    paidAmount: number;
    /**
     * 
     * @type {number}
     * @memberof GetOrderItemDetailsResponse
     */
    orderTotal: number;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemDetailsResponse
     */
    salesRepName: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemDetailsResponse
     */
    athleteName: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemDetailsResponse
     */
    couponRule: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemDetailsResponse
     */
    orderSource: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemDetailsResponse
     */
    currentWeek: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemDetailsResponse
     */
    orderComments: string | null;
    /**
     * 
     * @type {OrderStatus}
     * @memberof GetOrderItemDetailsResponse
     */
    status: OrderStatus;
}
/**
 * 
 * @export
 * @interface GetOrderItemShippingAddress
 */
export interface GetOrderItemShippingAddress {
    /**
     * 
     * @type {OrderAddressForInvoice}
     * @memberof GetOrderItemShippingAddress
     */
    shippingAddress: OrderAddressForInvoice;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemShippingAddress
     */
    orderId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderItemShippingAddress
     */
    orderItemId: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetOrderItemShippingAddress
     */
    isBulkShipping: boolean;
}
/**
 * 
 * @export
 * @interface GetOrderReturnImageData
 */
export interface GetOrderReturnImageData {
    /**
     * 
     * @type {string}
     * @memberof GetOrderReturnImageData
     */
    imageId: string;
    /**
     * 
     * @type {GetPrivateAccessMediaFileResponse}
     * @memberof GetOrderReturnImageData
     */
    image: GetPrivateAccessMediaFileResponse;
}
/**
 * 
 * @export
 * @interface GetOrderReturnImageResponse
 */
export interface GetOrderReturnImageResponse {
    /**
     * 
     * @type {string}
     * @memberof GetOrderReturnImageResponse
     */
    url: string;
}
/**
 * 
 * @export
 * @interface GetOrderReturnItemData
 */
export interface GetOrderReturnItemData {
    /**
     * 
     * @type {string}
     * @memberof GetOrderReturnItemData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderReturnItemData
     */
    displayId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderReturnItemData
     */
    orderItemId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderReturnItemData
     */
    reasonId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderReturnItemData
     */
    reason: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderReturnItemData
     */
    productName: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderReturnItemData
     */
    paymentType: string;
    /**
     * 
     * @type {OrderItemReturnStatus}
     * @memberof GetOrderReturnItemData
     */
    status: OrderItemReturnStatus;
    /**
     * 
     * @type {string}
     * @memberof GetOrderReturnItemData
     */
    statusText: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderReturnItemData
     */
    explanation: string | null;
    /**
     * 
     * @type {number}
     * @memberof GetOrderReturnItemData
     */
    quantity: number;
    /**
     * 
     * @type {boolean}
     * @memberof GetOrderReturnItemData
     */
    customerCanKeepProduct: boolean;
    /**
     * 
     * @type {Array<GetOrderReturnImageData>}
     * @memberof GetOrderReturnItemData
     */
    images: Array<GetOrderReturnImageData>;
}
/**
 * 
 * @export
 * @interface GetOrderReturnItemResponse
 */
export interface GetOrderReturnItemResponse {
    /**
     * 
     * @type {string}
     * @memberof GetOrderReturnItemResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderReturnItemResponse
     */
    displayId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderReturnItemResponse
     */
    orderItemId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderReturnItemResponse
     */
    reasonId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderReturnItemResponse
     */
    reason: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderReturnItemResponse
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrderReturnItemResponse
     */
    explanation: string | null;
    /**
     * 
     * @type {number}
     * @memberof GetOrderReturnItemResponse
     */
    quantity: number;
    /**
     * 
     * @type {Array<GetOrderReturnImageData>}
     * @memberof GetOrderReturnItemResponse
     */
    images: Array<GetOrderReturnImageData>;
}
/**
 * 
 * @export
 * @interface GetOrderReturnRequestResponse
 */
export interface GetOrderReturnRequestResponse {
    /**
     * 
     * @type {string}
     * @memberof GetOrderReturnRequestResponse
     */
    orderReturnRequestStatus: string;
}
/**
 * 
 * @export
 * @interface GetOrdersData
 */
export interface GetOrdersData {
    /**
     * 
     * @type {string}
     * @memberof GetOrdersData
     */
    orderId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrdersData
     */
    orderGroupId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrdersData
     */
    orderDisplayId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrdersData
     */
    sfOrderId: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetOrdersData
     */
    orderItemId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrdersData
     */
    orderItemDisplayId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrdersData
     */
    orderedDate: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrdersData
     */
    programId: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrdersData
     */
    programName: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrdersData
     */
    programProductId: string;
    /**
     * 
     * @type {number}
     * @memberof GetOrdersData
     */
    cost: number;
    /**
     * 
     * @type {number}
     * @memberof GetOrdersData
     */
    logoQuantity: number;
    /**
     * 
     * @type {number}
     * @memberof GetOrdersData
     */
    logoPrice: number;
    /**
     * 
     * @type {number}
     * @memberof GetOrdersData
     */
    total: number;
    /**
     * 
     * @type {string}
     * @memberof GetOrdersData
     */
    productName: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrdersData
     */
    customerFirstName: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrdersData
     */
    customerLastName: string;
    /**
     * 
     * @type {number}
     * @memberof GetOrdersData
     */
    orderQuantity: number;
    /**
     * 
     * @type {number}
     * @memberof GetOrdersData
     */
    paidAmount: number;
    /**
     * 
     * @type {number}
     * @memberof GetOrdersData
     */
    priceSold: number;
    /**
     * 
     * @type {number}
     * @memberof GetOrdersData
     */
    profit: number;
    /**
     * 
     * @type {boolean}
     * @memberof GetOrdersData
     */
    isCustom: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetOrdersData
     */
    hasReturns: boolean;
    /**
     * 
     * @type {OrderStatus}
     * @memberof GetOrdersData
     */
    status: OrderStatus;
    /**
     * 
     * @type {GetPrivateAccessMediaFileResponse}
     * @memberof GetOrdersData
     */
    thumbnail: GetPrivateAccessMediaFileResponse | null;
    /**
     * 
     * @type {string}
     * @memberof GetOrdersData
     */
    size: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetOrdersData
     */
    color: string | null;
    /**
     * 
     * @type {OrderItemReturnStatus}
     * @memberof GetOrdersData
     */
    returnStatus: OrderItemReturnStatus;
}
/**
 * 
 * @export
 * @interface GetOrdersListResponse
 */
export interface GetOrdersListResponse {
    /**
     * 
     * @type {number}
     * @memberof GetOrdersListResponse
     */
    nextCursor: number;
    /**
     * 
     * @type {Array<GetOrdersData>}
     * @memberof GetOrdersListResponse
     */
    data: Array<GetOrdersData>;
    /**
     * 
     * @type {number}
     * @memberof GetOrdersListResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetOrdersResponse
 */
export interface GetOrdersResponse {
    /**
     * 
     * @type {Array<GetOrderData>}
     * @memberof GetOrdersResponse
     */
    data: Array<GetOrderData>;
}
/**
 * 
 * @export
 * @interface GetParentColoursListData
 */
export interface GetParentColoursListData {
    /**
     * 
     * @type {string}
     * @memberof GetParentColoursListData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetParentColoursListData
     */
    color: string | null;
    /**
     * 
     * @type {ProductStatus}
     * @memberof GetParentColoursListData
     */
    status: ProductStatus;
    /**
     * 
     * @type {string}
     * @memberof GetParentColoursListData
     */
    swatchFirstColor: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetParentColoursListData
     */
    swatchSecondColor: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetParentColoursListData
     */
    isSfActive: boolean;
    /**
     * 
     * @type {number}
     * @memberof GetParentColoursListData
     */
    productPriceOverride: number | null;
    /**
     * 
     * @type {number}
     * @memberof GetParentColoursListData
     */
    minimumOrderQuantity: number | null;
}
/**
 * 
 * @export
 * @interface GetParentOrderReturnReasonListResponse
 */
export interface GetParentOrderReturnReasonListResponse {
    /**
     * 
     * @type {Array<GetParentOrderReturnReasonResponse>}
     * @memberof GetParentOrderReturnReasonListResponse
     */
    data: Array<GetParentOrderReturnReasonResponse>;
    /**
     * 
     * @type {number}
     * @memberof GetParentOrderReturnReasonListResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetParentOrderReturnReasonResponse
 */
export interface GetParentOrderReturnReasonResponse {
    /**
     * 
     * @type {string}
     * @memberof GetParentOrderReturnReasonResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetParentOrderReturnReasonResponse
     */
    reason: string;
    /**
     * 
     * @type {object}
     * @memberof GetParentOrderReturnReasonResponse
     */
    forItemType: object | null;
    /**
     * 
     * @type {object}
     * @memberof GetParentOrderReturnReasonResponse
     */
    manualApproval: object | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetParentOrderReturnReasonResponse
     */
    requireEvidence: boolean;
    /**
     * 
     * @type {object}
     * @memberof GetParentOrderReturnReasonResponse
     */
    elgibleForFullRefund: object | null;
}
/**
 * 
 * @export
 * @interface GetParentProduct3DColorLayersResponse
 */
export interface GetParentProduct3DColorLayersResponse {
    /**
     * 
     * @type {string}
     * @memberof GetParentProduct3DColorLayersResponse
     */
    sku: string;
    /**
     * 
     * @type {Get3DModelResponse}
     * @memberof GetParentProduct3DColorLayersResponse
     */
    base3DModel: Get3DModelResponse;
    /**
     * 
     * @type {Array<GetColoredProductLayersListData>}
     * @memberof GetParentProduct3DColorLayersResponse
     */
    colors: Array<GetColoredProductLayersListData>;
}
/**
 * 
 * @export
 * @interface GetParentProductDetailResponse
 */
export interface GetParentProductDetailResponse {
    /**
     * 
     * @type {string}
     * @memberof GetParentProductDetailResponse
     */
    sku: string;
    /**
     * 
     * @type {string}
     * @memberof GetParentProductDetailResponse
     */
    name: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetParentProductDetailResponse
     */
    description: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetParentProductDetailResponse
     */
    isPublished: boolean;
    /**
     * 
     * @type {number}
     * @memberof GetParentProductDetailResponse
     */
    logoPrice: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetParentProductDetailResponse
     */
    isSfActive: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetParentProductDetailResponse
     */
    isCustomProduct: boolean;
    /**
     * 
     * @type {number}
     * @memberof GetParentProductDetailResponse
     */
    recommendedPrice: number | null;
    /**
     * 
     * @type {number}
     * @memberof GetParentProductDetailResponse
     */
    minimumPrice: number | null;
    /**
     * 
     * @type {number}
     * @memberof GetParentProductDetailResponse
     */
    maxLimitPerOrder: number | null;
    /**
     * 
     * @type {string}
     * @memberof GetParentProductDetailResponse
     */
    category: string | null;
    /**
     * 
     * @type {Artwork}
     * @memberof GetParentProductDetailResponse
     */
    artworkType: Artwork;
    /**
     * 
     * @type {string}
     * @memberof GetParentProductDetailResponse
     */
    model3DId: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetParentProductDetailResponse
     */
    sizeChartId: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetParentProductDetailResponse
     */
    isPublishedOnce: boolean;
    /**
     * 
     * @type {Array<GetParentColoursListData>}
     * @memberof GetParentProductDetailResponse
     */
    colors: Array<GetParentColoursListData>;
    /**
     * 
     * @type {Array<GetParentTexturesListData>}
     * @memberof GetParentProductDetailResponse
     */
    artworkTextures: Array<GetParentTexturesListData>;
    /**
     * 
     * @type {GetSizeChartResponse}
     * @memberof GetParentProductDetailResponse
     */
    sizeChart?: GetSizeChartResponse;
}
/**
 * 
 * @export
 * @interface GetParentTexturesListData
 */
export interface GetParentTexturesListData {
    /**
     * 
     * @type {string}
     * @memberof GetParentTexturesListData
     */
    sku: string;
    /**
     * 
     * @type {string}
     * @memberof GetParentTexturesListData
     */
    textureId: string;
    /**
     * 
     * @type {string}
     * @memberof GetParentTexturesListData
     */
    textureName: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetParentTexturesListData
     */
    canCombine: boolean;
}
/**
 * 
 * @export
 * @interface GetPaymentSecretValues
 */
export interface GetPaymentSecretValues {
    /**
     * 
     * @type {string}
     * @memberof GetPaymentSecretValues
     */
    accountId: string;
    /**
     * 
     * @type {string}
     * @memberof GetPaymentSecretValues
     */
    apiSignature: string;
}
/**
 * 
 * @export
 * @interface GetPrivateAccessMediaFileResponse
 */
export interface GetPrivateAccessMediaFileResponse {
    /**
     * 
     * @type {PrivateUrlsData}
     * @memberof GetPrivateAccessMediaFileResponse
     */
    privateUrls: PrivateUrlsData;
    /**
     * 
     * @type {string}
     * @memberof GetPrivateAccessMediaFileResponse
     */
    type: string;
    /**
     * 
     * @type {MediaFileMetadata}
     * @memberof GetPrivateAccessMediaFileResponse
     */
    metadata: MediaFileMetadata;
}
/**
 * 
 * @export
 * @interface GetProduct3DColorLayersResponse
 */
export interface GetProduct3DColorLayersResponse {
    /**
     * 
     * @type {Array<GetLayerDataResponse>}
     * @memberof GetProduct3DColorLayersResponse
     */
    layers: Array<GetLayerDataResponse>;
}
/**
 * 
 * @export
 * @interface GetProductCategoryListData
 */
export interface GetProductCategoryListData {
    /**
     * 
     * @type {number}
     * @memberof GetProductCategoryListData
     */
    order: number;
    /**
     * 
     * @type {string}
     * @memberof GetProductCategoryListData
     */
    name: string;
}
/**
 * 
 * @export
 * @interface GetProductCategoryListResponse
 */
export interface GetProductCategoryListResponse {
    /**
     * 
     * @type {Array<GetProductCategoryListData>}
     * @memberof GetProductCategoryListResponse
     */
    data: Array<GetProductCategoryListData>;
    /**
     * 
     * @type {number}
     * @memberof GetProductCategoryListResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetProductImageData
 */
export interface GetProductImageData {
    /**
     * 
     * @type {string}
     * @memberof GetProductImageData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetProductImageData
     */
    imageId: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetProductImageData
     */
    isManualUpload: boolean;
    /**
     * 
     * @type {GetDirectAccessMediaFileResponse | GetPrivateAccessMediaFileResponse}
     * @memberof GetProductImageData
     */
    image: GetDirectAccessMediaFileResponse | GetPrivateAccessMediaFileResponse | null;
}
/**
 * 
 * @export
 * @interface GetProductImageResponse
 */
export interface GetProductImageResponse {
    /**
     * 
     * @type {string}
     * @memberof GetProductImageResponse
     */
    url: string;
}
/**
 * 
 * @export
 * @interface GetProductImagesResponse
 */
export interface GetProductImagesResponse {
    /**
     * 
     * @type {string}
     * @memberof GetProductImagesResponse
     */
    coloredProductId: string | null;
    /**
     * 
     * @type {Array<GetProductImageData>}
     * @memberof GetProductImagesResponse
     */
    productImages: Array<GetProductImageData>;
}
/**
 * 
 * @export
 * @interface GetProductInventoryListData
 */
export interface GetProductInventoryListData {
    /**
     * 
     * @type {string}
     * @memberof GetProductInventoryListData
     */
    sku: string;
    /**
     * 
     * @type {string}
     * @memberof GetProductInventoryListData
     */
    parentSku: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetProductInventoryListData
     */
    isSfActive: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetProductInventoryListData
     */
    size: string | null;
    /**
     * 
     * @type {number}
     * @memberof GetProductInventoryListData
     */
    count: number | null;
}
/**
 * 
 * @export
 * @interface GetProductSettingsListData
 */
export interface GetProductSettingsListData {
    /**
     * 
     * @type {string}
     * @memberof GetProductSettingsListData
     */
    coloredProductId: string;
    /**
     * 
     * @type {string}
     * @memberof GetProductSettingsListData
     */
    productName: string;
    /**
     * 
     * @type {number}
     * @memberof GetProductSettingsListData
     */
    productPrice: number;
    /**
     * 
     * @type {number}
     * @memberof GetProductSettingsListData
     */
    productMinOrderQuantity: number;
    /**
     * 
     * @type {string}
     * @memberof GetProductSettingsListData
     */
    productShipTo: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProductSettingsListData
     */
    productShipping: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProductSettingsListData
     */
    productSettingOverrideId: string | null;
    /**
     * 
     * @type {number}
     * @memberof GetProductSettingsListData
     */
    productPriceOverride: number;
    /**
     * 
     * @type {number}
     * @memberof GetProductSettingsListData
     */
    productMinOrderQuantityOverride: number;
    /**
     * 
     * @type {boolean}
     * @memberof GetProductSettingsListData
     */
    isIndividualShipping: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetProductSettingsListData
     */
    productShippingOverride: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetProductSettingsListData
     */
    isSfActive: boolean;
}
/**
 * 
 * @export
 * @interface GetProductSettingsListResponse
 */
export interface GetProductSettingsListResponse {
    /**
     * 
     * @type {number}
     * @memberof GetProductSettingsListResponse
     */
    nextCursor: number;
    /**
     * 
     * @type {Array<GetProductSettingsListData>}
     * @memberof GetProductSettingsListResponse
     */
    data: Array<GetProductSettingsListData>;
    /**
     * 
     * @type {number}
     * @memberof GetProductSettingsListResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetProfileResponse
 */
export interface GetProfileResponse {
    /**
     * 
     * @type {string}
     * @memberof GetProfileResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetProfileResponse
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof GetProfileResponse
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof GetProfileResponse
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof GetProfileResponse
     */
    phone: string | null;
    /**
     * 
     * @type {UserStatus}
     * @memberof GetProfileResponse
     */
    status: UserStatus;
    /**
     * 
     * @type {string}
     * @memberof GetProfileResponse
     */
    programId: string | null;
    /**
     * 
     * @type {Array<UserPermission>}
     * @memberof GetProfileResponse
     */
    permissionList: Array<UserPermission>;
}
/**
 * 
 * @export
 * @interface GetProgramAdminListData
 */
export interface GetProgramAdminListData {
    /**
     * 
     * @type {string}
     * @memberof GetProgramAdminListData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramAdminListData
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramAdminListData
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramAdminListData
     */
    email: string;
    /**
     * 
     * @type {UserStatus}
     * @memberof GetProgramAdminListData
     */
    status: UserStatus;
    /**
     * 
     * @type {Array<UserPermission>}
     * @memberof GetProgramAdminListData
     */
    permissionList: Array<UserPermission>;
    /**
     * 
     * @type {boolean}
     * @memberof GetProgramAdminListData
     */
    isProgramOwner: boolean;
}
/**
 * 
 * @export
 * @interface GetProgramAdminListResponse
 */
export interface GetProgramAdminListResponse {
    /**
     * 
     * @type {number}
     * @memberof GetProgramAdminListResponse
     */
    nextCursor: number;
    /**
     * 
     * @type {Array<GetProgramAdminListData>}
     * @memberof GetProgramAdminListResponse
     */
    data: Array<GetProgramAdminListData>;
    /**
     * 
     * @type {number}
     * @memberof GetProgramAdminListResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetProgramArtworkColorData
 */
export interface GetProgramArtworkColorData {
    /**
     * 
     * @type {string}
     * @memberof GetProgramArtworkColorData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramArtworkColorData
     */
    color: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramArtworkColorData
     */
    programArtworkId: string;
}
/**
 * 
 * @export
 * @interface GetProgramArtworkColorListResponse
 */
export interface GetProgramArtworkColorListResponse {
    /**
     * 
     * @type {Array<GetProgramArtworkColorData>}
     * @memberof GetProgramArtworkColorListResponse
     */
    data: Array<GetProgramArtworkColorData>;
    /**
     * 
     * @type {number}
     * @memberof GetProgramArtworkColorListResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetProgramArtworkData
 */
export interface GetProgramArtworkData {
    /**
     * 
     * @type {string}
     * @memberof GetProgramArtworkData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramArtworkData
     */
    programId: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramArtworkData
     */
    imageId: string;
    /**
     * 
     * @type {GetPrivateAccessMediaFileResponse}
     * @memberof GetProgramArtworkData
     */
    image: GetPrivateAccessMediaFileResponse;
    /**
     * 
     * @type {number}
     * @memberof GetProgramArtworkData
     */
    sensitivity: number;
}
/**
 * 
 * @export
 * @interface GetProgramArtworkListResponse
 */
export interface GetProgramArtworkListResponse {
    /**
     * 
     * @type {number}
     * @memberof GetProgramArtworkListResponse
     */
    nextCursor: number;
    /**
     * 
     * @type {Array<GetProgramArtworkData>}
     * @memberof GetProgramArtworkListResponse
     */
    data: Array<GetProgramArtworkData>;
    /**
     * 
     * @type {number}
     * @memberof GetProgramArtworkListResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetProgramArtworkResponse
 */
export interface GetProgramArtworkResponse {
    /**
     * 
     * @type {string}
     * @memberof GetProgramArtworkResponse
     */
    url: string;
}
/**
 * 
 * @export
 * @interface GetProgramByDomainResponse
 */
export interface GetProgramByDomainResponse {
    /**
     * 
     * @type {string}
     * @memberof GetProgramByDomainResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramByDomainResponse
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramByDomainResponse
     */
    primaryColor: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramByDomainResponse
     */
    secondaryColor: string;
    /**
     * 
     * @type {GetDirectAccessMediaFileResponse | GetPrivateAccessMediaFileResponse}
     * @memberof GetProgramByDomainResponse
     */
    bannerImage: GetDirectAccessMediaFileResponse | GetPrivateAccessMediaFileResponse | null;
    /**
     * 
     * @type {GetDirectAccessMediaFileResponse | GetPrivateAccessMediaFileResponse}
     * @memberof GetProgramByDomainResponse
     */
    logoImage: GetDirectAccessMediaFileResponse | GetPrivateAccessMediaFileResponse | null;
}
/**
 * 
 * @export
 * @interface GetProgramCustomerListData
 */
export interface GetProgramCustomerListData {
    /**
     * 
     * @type {string}
     * @memberof GetProgramCustomerListData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramCustomerListData
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramCustomerListData
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramCustomerListData
     */
    email: string;
    /**
     * 
     * @type {UserStatus}
     * @memberof GetProgramCustomerListData
     */
    status: UserStatus;
    /**
     * 
     * @type {string}
     * @memberof GetProgramCustomerListData
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramCustomerListData
     */
    updatedAt: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramCustomerListData
     */
    deletedAt: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramCustomerListData
     */
    requestedAt: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramCustomerListData
     */
    deactivatedAt: string | null;
}
/**
 * 
 * @export
 * @interface GetProgramCustomersListResponse
 */
export interface GetProgramCustomersListResponse {
    /**
     * 
     * @type {number}
     * @memberof GetProgramCustomersListResponse
     */
    nextCursor: number;
    /**
     * 
     * @type {Array<GetProgramCustomerListData>}
     * @memberof GetProgramCustomersListResponse
     */
    data: Array<GetProgramCustomerListData>;
    /**
     * 
     * @type {number}
     * @memberof GetProgramCustomersListResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetProgramFileResponse
 */
export interface GetProgramFileResponse {
    /**
     * 
     * @type {string}
     * @memberof GetProgramFileResponse
     */
    url: string;
}
/**
 * 
 * @export
 * @interface GetProgramListData
 */
export interface GetProgramListData {
    /**
     * 
     * @type {string}
     * @memberof GetProgramListData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramListData
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramListData
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramListData
     */
    ownerId: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramListData
     */
    ownerFirstName: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramListData
     */
    ownerLastName: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramListData
     */
    ownerEmail: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramListData
     */
    phone: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramListData
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramListData
     */
    storeUrlPath: string;
    /**
     * 
     * @type {StoreStatus}
     * @memberof GetProgramListData
     */
    storeStatus: StoreStatus;
}
/**
 * 
 * @export
 * @interface GetProgramListResponse
 */
export interface GetProgramListResponse {
    /**
     * 
     * @type {number}
     * @memberof GetProgramListResponse
     */
    nextCursor: number;
    /**
     * 
     * @type {Array<GetProgramListData>}
     * @memberof GetProgramListResponse
     */
    data: Array<GetProgramListData>;
    /**
     * 
     * @type {number}
     * @memberof GetProgramListResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetProgramParentProduct3DModelResponse
 */
export interface GetProgramParentProduct3DModelResponse {
    /**
     * 
     * @type {string}
     * @memberof GetProgramParentProduct3DModelResponse
     */
    id: string;
    /**
     * 
     * @type {Get3DModelResponse}
     * @memberof GetProgramParentProduct3DModelResponse
     */
    base3DModel: Get3DModelResponse | null;
}
/**
 * 
 * @export
 * @interface GetProgramParentProductDetailResponse
 */
export interface GetProgramParentProductDetailResponse {
    /**
     * 
     * @type {string}
     * @memberof GetProgramParentProductDetailResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramParentProductDetailResponse
     */
    sku: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramParentProductDetailResponse
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramParentProductDetailResponse
     */
    note: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramParentProductDetailResponse
     */
    description: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramParentProductDetailResponse
     */
    status: string;
    /**
     * 
     * @type {number}
     * @memberof GetProgramParentProductDetailResponse
     */
    price: number;
    /**
     * 
     * @type {number}
     * @memberof GetProgramParentProductDetailResponse
     */
    logoQuantity: number;
    /**
     * 
     * @type {number}
     * @memberof GetProgramParentProductDetailResponse
     */
    logoPrice: number;
    /**
     * 
     * @type {Array<GetMinimalProgramProductData>}
     * @memberof GetProgramParentProductDetailResponse
     */
    programProducts: Array<GetMinimalProgramProductData>;
    /**
     * 
     * @type {GetMinimalSFParentProductWithMinimalColorData}
     * @memberof GetProgramParentProductDetailResponse
     */
    sfParentProduct: GetMinimalSFParentProductWithMinimalColorData;
    /**
     * 
     * @type {boolean}
     * @memberof GetProgramParentProductDetailResponse
     */
    isCustom: boolean;
    /**
     * 
     * @type {number}
     * @memberof GetProgramParentProductDetailResponse
     */
    recommendedPrice: number | null;
    /**
     * 
     * @type {number}
     * @memberof GetProgramParentProductDetailResponse
     */
    minimumPrice: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetProgramParentProductDetailResponse
     */
    isPublishedOnce: boolean;
    /**
     * 
     * @type {Get3DModelResponse}
     * @memberof GetProgramParentProductDetailResponse
     */
    base3DModel: Get3DModelResponse | null;
    /**
     * 
     * @type {Array<GetProgramProductAppliedArtworkData>}
     * @memberof GetProgramParentProductDetailResponse
     */
    appliedArtworks: Array<GetProgramProductAppliedArtworkData>;
}
/**
 * 
 * @export
 * @interface GetProgramParentProductListData
 */
export interface GetProgramParentProductListData {
    /**
     * 
     * @type {string}
     * @memberof GetProgramParentProductListData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramParentProductListData
     */
    sku: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramParentProductListData
     */
    title: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramParentProductListData
     */
    programId: string;
    /**
     * 
     * @type {ProgramParentProductStatus}
     * @memberof GetProgramParentProductListData
     */
    status: ProgramParentProductStatus;
    /**
     * 
     * @type {boolean}
     * @memberof GetProgramParentProductListData
     */
    isCustom: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetProgramParentProductListData
     */
    note: string;
    /**
     * 
     * @type {number}
     * @memberof GetProgramParentProductListData
     */
    logoQuantity?: number;
    /**
     * 
     * @type {number}
     * @memberof GetProgramParentProductListData
     */
    logoPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof GetProgramParentProductListData
     */
    price?: number;
    /**
     * 
     * @type {Array<GetProgramProductData>}
     * @memberof GetProgramParentProductListData
     */
    programProducts: Array<GetProgramProductData>;
    /**
     * 
     * @type {GetPrivateAccessMediaFileResponse}
     * @memberof GetProgramParentProductListData
     */
    thumbnail: GetPrivateAccessMediaFileResponse | null;
    /**
     * 
     * @type {GetMinimalSFParentProduct}
     * @memberof GetProgramParentProductListData
     */
    sfParentProduct: GetMinimalSFParentProduct;
    /**
     * 
     * @type {GetTechPackData}
     * @memberof GetProgramParentProductListData
     */
    techPack: GetTechPackData | null;
}
/**
 * 
 * @export
 * @interface GetProgramParentProductListResponse
 */
export interface GetProgramParentProductListResponse {
    /**
     * 
     * @type {number}
     * @memberof GetProgramParentProductListResponse
     */
    nextCursor: number;
    /**
     * 
     * @type {Array<GetProgramParentProductListData>}
     * @memberof GetProgramParentProductListResponse
     */
    data: Array<GetProgramParentProductListData>;
    /**
     * 
     * @type {number}
     * @memberof GetProgramParentProductListResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetProgramParentProductsSkuStatusCountResponse
 */
export interface GetProgramParentProductsSkuStatusCountResponse {
    /**
     * 
     * @type {number}
     * @memberof GetProgramParentProductsSkuStatusCountResponse
     */
    activeProgramParentProductsSkuCount: number;
    /**
     * 
     * @type {number}
     * @memberof GetProgramParentProductsSkuStatusCountResponse
     */
    draftProgramParentProductsSkuCount: number;
    /**
     * 
     * @type {number}
     * @memberof GetProgramParentProductsSkuStatusCountResponse
     */
    inactiveProgramParentProductsSkuCount: number;
}
/**
 * 
 * @export
 * @interface GetProgramPaymentInfoResponse
 */
export interface GetProgramPaymentInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof GetProgramPaymentInfoResponse
     */
    programId: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramPaymentInfoResponse
     */
    bankAccountNumber: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramPaymentInfoResponse
     */
    bankRoutingNumber: string | null;
}
/**
 * 
 * @export
 * @interface GetProgramProduct3DModelResponse
 */
export interface GetProgramProduct3DModelResponse {
    /**
     * 
     * @type {string}
     * @memberof GetProgramProduct3DModelResponse
     */
    id: string;
    /**
     * 
     * @type {Get3DModelResponse}
     * @memberof GetProgramProduct3DModelResponse
     */
    base3DModel: Get3DModelResponse | null;
    /**
     * 
     * @type {Array<GetColoredProductLayersListData>}
     * @memberof GetProgramProduct3DModelResponse
     */
    colors: Array<GetColoredProductLayersListData>;
    /**
     * 
     * @type {Array<GetProgramProductAppliedArtworkData>}
     * @memberof GetProgramProduct3DModelResponse
     */
    appliedArtworks: Array<GetProgramProductAppliedArtworkData>;
}
/**
 * 
 * @export
 * @interface GetProgramProductAppliedArtworkData
 */
export interface GetProgramProductAppliedArtworkData {
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductAppliedArtworkData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductAppliedArtworkData
     */
    programArtworkId: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductAppliedArtworkData
     */
    boundaryId: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductAppliedArtworkData
     */
    programParentProductId: string;
    /**
     * 
     * @type {number}
     * @memberof GetProgramProductAppliedArtworkData
     */
    sizeRatio: number;
    /**
     * 
     * @type {number}
     * @memberof GetProgramProductAppliedArtworkData
     */
    xRatio: number;
    /**
     * 
     * @type {number}
     * @memberof GetProgramProductAppliedArtworkData
     */
    yRatio: number;
    /**
     * 
     * @type {number}
     * @memberof GetProgramProductAppliedArtworkData
     */
    whRatio: number;
    /**
     * 
     * @type {number}
     * @memberof GetProgramProductAppliedArtworkData
     */
    rotation: number;
    /**
     * 
     * @type {number}
     * @memberof GetProgramProductAppliedArtworkData
     */
    sensitivity: number;
    /**
     * 
     * @type {Array<GetProgramProductAppliedTextureData>}
     * @memberof GetProgramProductAppliedArtworkData
     */
    appliedTextures: Array<GetProgramProductAppliedTextureData>;
    /**
     * 
     * @type {GetProgramArtworkData}
     * @memberof GetProgramProductAppliedArtworkData
     */
    programArtworkImage: GetProgramArtworkData;
}
/**
 * 
 * @export
 * @interface GetProgramProductAppliedArtworkResponse
 */
export interface GetProgramProductAppliedArtworkResponse {
    /**
     * 
     * @type {Array<GetProgramProductAppliedArtworkData>}
     * @memberof GetProgramProductAppliedArtworkResponse
     */
    appliedArtwork: Array<GetProgramProductAppliedArtworkData>;
    /**
     * 
     * @type {number}
     * @memberof GetProgramProductAppliedArtworkResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetProgramProductAppliedTextureData
 */
export interface GetProgramProductAppliedTextureData {
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductAppliedTextureData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductAppliedTextureData
     */
    appliedArtworkId: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductAppliedTextureData
     */
    programArtworkColorId: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductAppliedTextureData
     */
    textureId: string;
    /**
     * 
     * @type {object}
     * @memberof GetProgramProductAppliedTextureData
     */
    texture: object;
    /**
     * 
     * @type {object}
     * @memberof GetProgramProductAppliedTextureData
     */
    programArtworkColor: object;
}
/**
 * 
 * @export
 * @interface GetProgramProductCategoryListData
 */
export interface GetProgramProductCategoryListData {
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductCategoryListData
     */
    category: string | null;
}
/**
 * 
 * @export
 * @interface GetProgramProductCategoryListResponse
 */
export interface GetProgramProductCategoryListResponse {
    /**
     * 
     * @type {Array<GetProgramProductCategoryListData>}
     * @memberof GetProgramProductCategoryListResponse
     */
    data: Array<GetProgramProductCategoryListData>;
}
/**
 * 
 * @export
 * @interface GetProgramProductColorListData
 */
export interface GetProgramProductColorListData {
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductColorListData
     */
    color: string | null;
}
/**
 * 
 * @export
 * @interface GetProgramProductColorListResponse
 */
export interface GetProgramProductColorListResponse {
    /**
     * 
     * @type {Array<GetProgramProductColorListData>}
     * @memberof GetProgramProductColorListResponse
     */
    data: Array<GetProgramProductColorListData>;
}
/**
 * 
 * @export
 * @interface GetProgramProductData
 */
export interface GetProgramProductData {
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductData
     */
    programParentProductId: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductData
     */
    coloredProductId: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetProgramProductData
     */
    isActive: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductData
     */
    title: string;
    /**
     * 
     * @type {number}
     * @memberof GetProgramProductData
     */
    maxLimitPerOrder: number | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductData
     */
    thumbnailId: string | null;
    /**
     * 
     * @type {number}
     * @memberof GetProgramProductData
     */
    cost: number;
    /**
     * 
     * @type {number}
     * @memberof GetProgramProductData
     */
    price: number;
    /**
     * 
     * @type {GetDirectAccessMediaFileResponse | GetPrivateAccessMediaFileResponse}
     * @memberof GetProgramProductData
     */
    thumbnail: GetDirectAccessMediaFileResponse | GetPrivateAccessMediaFileResponse | null;
    /**
     * 
     * @type {GetColoredProductListData}
     * @memberof GetProgramProductData
     */
    coloredProduct: GetColoredProductListData;
}
/**
 * 
 * @export
 * @interface GetProgramProductDetailsResponse
 */
export interface GetProgramProductDetailsResponse {
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductDetailsResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductDetailsResponse
     */
    name: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductDetailsResponse
     */
    category: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductDetailsResponse
     */
    swatchFirstColor: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductDetailsResponse
     */
    swatchSecondColor: string | null;
    /**
     * 
     * @type {number}
     * @memberof GetProgramProductDetailsResponse
     */
    price: number | null;
    /**
     * 
     * @type {number}
     * @memberof GetProgramProductDetailsResponse
     */
    minimumOrderQuantity: number;
    /**
     * 
     * @type {number}
     * @memberof GetProgramProductDetailsResponse
     */
    receivedOrderQuantity: number;
    /**
     * 
     * @type {number}
     * @memberof GetProgramProductDetailsResponse
     */
    maxLimitPerOrder: number | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductDetailsResponse
     */
    note: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductDetailsResponse
     */
    color: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductDetailsResponse
     */
    coloredProductId: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductDetailsResponse
     */
    parentSku: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetProgramProductDetailsResponse
     */
    isFavorite: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetProgramProductDetailsResponse
     */
    isMoqMet: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductDetailsResponse
     */
    description: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductDetailsResponse
     */
    thumbnailId: string | null;
    /**
     * 
     * @type {GetDirectAccessMediaFileResponse | GetPrivateAccessMediaFileResponse}
     * @memberof GetProgramProductDetailsResponse
     */
    thumbnail: GetDirectAccessMediaFileResponse | GetPrivateAccessMediaFileResponse | null;
    /**
     * 
     * @type {Array<GetProgramProductImageData>}
     * @memberof GetProgramProductDetailsResponse
     */
    images: Array<GetProgramProductImageData>;
}
/**
 * 
 * @export
 * @interface GetProgramProductImageData
 */
export interface GetProgramProductImageData {
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductImageData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductImageData
     */
    programProductId: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductImageData
     */
    imageId: string;
    /**
     * 
     * @type {GetPrivateAccessMediaFileResponse}
     * @memberof GetProgramProductImageData
     */
    image: GetPrivateAccessMediaFileResponse;
}
/**
 * 
 * @export
 * @interface GetProgramProductImageListResponse
 */
export interface GetProgramProductImageListResponse {
    /**
     * 
     * @type {number}
     * @memberof GetProgramProductImageListResponse
     */
    nextCursor: number;
    /**
     * 
     * @type {Array<GetProgramProductImageData>}
     * @memberof GetProgramProductImageListResponse
     */
    data: Array<GetProgramProductImageData>;
    /**
     * 
     * @type {number}
     * @memberof GetProgramProductImageListResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetProgramProductImageResponse
 */
export interface GetProgramProductImageResponse {
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductImageResponse
     */
    url: string;
}
/**
 * 
 * @export
 * @interface GetProgramProductListData
 */
export interface GetProgramProductListData {
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductListData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductListData
     */
    name: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductListData
     */
    coloredProductId: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductListData
     */
    color: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductListData
     */
    category: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductListData
     */
    swatchFirstColor: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductListData
     */
    swatchSecondColor: string | null;
    /**
     * 
     * @type {number}
     * @memberof GetProgramProductListData
     */
    price: number | null;
    /**
     * 
     * @type {number}
     * @memberof GetProgramProductListData
     */
    maxLimitPerOrder: number | null;
    /**
     * 
     * @type {GetPrivateAccessMediaFileResponse}
     * @memberof GetProgramProductListData
     */
    thumbnail: GetPrivateAccessMediaFileResponse | null;
    /**
     * 
     * @type {Array<GetMinimalProgramColoredProductData>}
     * @memberof GetProgramProductListData
     */
    availableColors: Array<GetMinimalProgramColoredProductData>;
}
/**
 * 
 * @export
 * @interface GetProgramProductListForProgramParentProductResponse
 */
export interface GetProgramProductListForProgramParentProductResponse {
    /**
     * 
     * @type {Array<GetProgramProductListData>}
     * @memberof GetProgramProductListForProgramParentProductResponse
     */
    data: Array<GetProgramProductListData>;
}
/**
 * 
 * @export
 * @interface GetProgramProductResponse
 */
export interface GetProgramProductResponse {
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductResponse
     */
    name: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductResponse
     */
    category: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductResponse
     */
    swatchFirstColor: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductResponse
     */
    swatchSecondColor: string | null;
    /**
     * 
     * @type {number}
     * @memberof GetProgramProductResponse
     */
    price: number | null;
    /**
     * 
     * @type {number}
     * @memberof GetProgramProductResponse
     */
    minimumOrderQuantity: number;
    /**
     * 
     * @type {number}
     * @memberof GetProgramProductResponse
     */
    receivedOrderQuantity: number;
    /**
     * 
     * @type {number}
     * @memberof GetProgramProductResponse
     */
    maxLimitPerOrder: number | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductResponse
     */
    note: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductResponse
     */
    color: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductResponse
     */
    coloredProductId: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductResponse
     */
    parentSku: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetProgramProductResponse
     */
    isFavorite: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetProgramProductResponse
     */
    isMoqMet: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductResponse
     */
    description: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductResponse
     */
    thumbnailId: string | null;
    /**
     * 
     * @type {GetDirectAccessMediaFileResponse | GetPrivateAccessMediaFileResponse}
     * @memberof GetProgramProductResponse
     */
    thumbnail: GetDirectAccessMediaFileResponse | GetPrivateAccessMediaFileResponse | null;
    /**
     * 
     * @type {Array<GetProductInventoryListData>}
     * @memberof GetProgramProductResponse
     */
    inventories: Array<GetProductInventoryListData>;
    /**
     * 
     * @type {Array<GetProgramProductImageData>}
     * @memberof GetProgramProductResponse
     */
    images: Array<GetProgramProductImageData>;
    /**
     * 
     * @type {Array<GetMinimalColoredProductData>}
     * @memberof GetProgramProductResponse
     */
    availableColors: Array<GetMinimalColoredProductData>;
    /**
     * 
     * @type {Array<GetLayerDataResponse>}
     * @memberof GetProgramProductResponse
     */
    layers: Array<GetLayerDataResponse>;
}
/**
 * 
 * @export
 * @interface GetProgramProductSizeListData
 */
export interface GetProgramProductSizeListData {
    /**
     * 
     * @type {string}
     * @memberof GetProgramProductSizeListData
     */
    size: string | null;
}
/**
 * 
 * @export
 * @interface GetProgramProductSizeListResponse
 */
export interface GetProgramProductSizeListResponse {
    /**
     * 
     * @type {Array<GetProgramProductSizeListData>}
     * @memberof GetProgramProductSizeListResponse
     */
    data: Array<GetProgramProductSizeListData>;
    /**
     * 
     * @type {number}
     * @memberof GetProgramProductSizeListResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetProgramResponse
 */
export interface GetProgramResponse {
    /**
     * 
     * @type {string}
     * @memberof GetProgramResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramResponse
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramResponse
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramResponse
     */
    phone: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramResponse
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramResponse
     */
    ownerFirstName: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramResponse
     */
    ownerLastName: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramResponse
     */
    ownerEmail: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramResponse
     */
    storeUrlPath: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramResponse
     */
    bulkShippingStreet: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramResponse
     */
    bulkShippingCity: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramResponse
     */
    bulkShippingState: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramResponse
     */
    bulkShippingZipCode: string | null;
    /**
     * 
     * @type {GetDirectAccessMediaFileResponse | GetPrivateAccessMediaFileResponse}
     * @memberof GetProgramResponse
     */
    bannerImage: GetDirectAccessMediaFileResponse | GetPrivateAccessMediaFileResponse | null;
    /**
     * 
     * @type {GetDirectAccessMediaFileResponse | GetPrivateAccessMediaFileResponse}
     * @memberof GetProgramResponse
     */
    logoImage: GetDirectAccessMediaFileResponse | GetPrivateAccessMediaFileResponse | null;
    /**
     * 
     * @type {StoreStatus}
     * @memberof GetProgramResponse
     */
    storeStatus: StoreStatus;
    /**
     * 
     * @type {string}
     * @memberof GetProgramResponse
     */
    primaryColor: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramResponse
     */
    secondaryColor: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetProgramResponse
     */
    shippingId: string | null;
    /**
     * 
     * @type {GetProgramShipping}
     * @memberof GetProgramResponse
     */
    programShipping?: GetProgramShipping;
}
/**
 * 
 * @export
 * @interface GetProgramShipping
 */
export interface GetProgramShipping {
    /**
     * 
     * @type {string}
     * @memberof GetProgramShipping
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramShipping
     */
    shippingId: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramShipping
     */
    shipping: string;
}
/**
 * 
 * @export
 * @interface GetProgramsListData
 */
export interface GetProgramsListData {
    /**
     * 
     * @type {string}
     * @memberof GetProgramsListData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramsListData
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramsListData
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramsListData
     */
    ownerId: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramsListData
     */
    ownerFirstName: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramsListData
     */
    ownerLastName: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramsListData
     */
    ownerEmail: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramsListData
     */
    phone: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramsListData
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramsListData
     */
    storeUrlPath: string;
    /**
     * 
     * @type {StoreStatus}
     * @memberof GetProgramsListData
     */
    storeStatus: StoreStatus;
    /**
     * 
     * @type {number}
     * @memberof GetProgramsListData
     */
    globalProductsCount: number;
    /**
     * 
     * @type {number}
     * @memberof GetProgramsListData
     */
    customProductsCount: number;
}
/**
 * 
 * @export
 * @interface GetProgramsProductSettingsListData
 */
export interface GetProgramsProductSettingsListData {
    /**
     * 
     * @type {string}
     * @memberof GetProgramsProductSettingsListData
     */
    programId: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramsProductSettingsListData
     */
    programName: string;
    /**
     * 
     * @type {string}
     * @memberof GetProgramsProductSettingsListData
     */
    productSettingId: string | null;
    /**
     * 
     * @type {number}
     * @memberof GetProgramsProductSettingsListData
     */
    productPrice: number;
    /**
     * 
     * @type {number}
     * @memberof GetProgramsProductSettingsListData
     */
    productMinOrderQuantity: number;
    /**
     * 
     * @type {boolean}
     * @memberof GetProgramsProductSettingsListData
     */
    isIndividualShipping: boolean;
    /**
     * 
     * @type {number}
     * @memberof GetProgramsProductSettingsListData
     */
    productShipping: number | null;
}
/**
 * 
 * @export
 * @interface GetProgramsProductSettingsListResponse
 */
export interface GetProgramsProductSettingsListResponse {
    /**
     * 
     * @type {number}
     * @memberof GetProgramsProductSettingsListResponse
     */
    nextCursor: number;
    /**
     * 
     * @type {Array<GetProgramsProductSettingsListData>}
     * @memberof GetProgramsProductSettingsListResponse
     */
    data: Array<GetProgramsProductSettingsListData>;
    /**
     * 
     * @type {GetSFColoredProductSettingsListData}
     * @memberof GetProgramsProductSettingsListResponse
     */
    productSettings: GetSFColoredProductSettingsListData;
    /**
     * 
     * @type {number}
     * @memberof GetProgramsProductSettingsListResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetProgramsWithProductsCountResponse
 */
export interface GetProgramsWithProductsCountResponse {
    /**
     * 
     * @type {number}
     * @memberof GetProgramsWithProductsCountResponse
     */
    nextCursor: number;
    /**
     * 
     * @type {Array<GetProgramsListData>}
     * @memberof GetProgramsWithProductsCountResponse
     */
    data: Array<GetProgramsListData>;
    /**
     * 
     * @type {number}
     * @memberof GetProgramsWithProductsCountResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetPublishedRebelProductListData
 */
export interface GetPublishedRebelProductListData {
    /**
     * 
     * @type {string}
     * @memberof GetPublishedRebelProductListData
     */
    sku: string;
    /**
     * 
     * @type {string}
     * @memberof GetPublishedRebelProductListData
     */
    name: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetPublishedRebelProductListData
     */
    isPublished: boolean;
    /**
     * 
     * @type {number}
     * @memberof GetPublishedRebelProductListData
     */
    logoPrice: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetPublishedRebelProductListData
     */
    isSfActive: boolean;
    /**
     * 
     * @type {number}
     * @memberof GetPublishedRebelProductListData
     */
    recommendedPrice: number | null;
    /**
     * 
     * @type {number}
     * @memberof GetPublishedRebelProductListData
     */
    minimumPrice: number | null;
    /**
     * 
     * @type {string}
     * @memberof GetPublishedRebelProductListData
     */
    category: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetPublishedRebelProductListData
     */
    programId: string | null;
    /**
     * 
     * @type {GetDirectAccessMediaFileResponse | GetPrivateAccessMediaFileResponse}
     * @memberof GetPublishedRebelProductListData
     */
    thumbnail: GetDirectAccessMediaFileResponse | GetPrivateAccessMediaFileResponse | null;
}
/**
 * 
 * @export
 * @interface GetPublishedRebelProductListResponse
 */
export interface GetPublishedRebelProductListResponse {
    /**
     * 
     * @type {number}
     * @memberof GetPublishedRebelProductListResponse
     */
    nextCursor: number;
    /**
     * 
     * @type {Array<GetPublishedRebelProductListData>}
     * @memberof GetPublishedRebelProductListResponse
     */
    data: Array<GetPublishedRebelProductListData>;
    /**
     * 
     * @type {number}
     * @memberof GetPublishedRebelProductListResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetReturnOrderRefundEstimatesResponse
 */
export interface GetReturnOrderRefundEstimatesResponse {
    /**
     * 
     * @type {number}
     * @memberof GetReturnOrderRefundEstimatesResponse
     */
    storeCredit: number;
    /**
     * 
     * @type {OriginalMethodRefundData}
     * @memberof GetReturnOrderRefundEstimatesResponse
     */
    originalPayment: OriginalMethodRefundData;
}
/**
 * 
 * @export
 * @interface GetReturnRefundDetailsData
 */
export interface GetReturnRefundDetailsData {
    /**
     * 
     * @type {string}
     * @memberof GetReturnRefundDetailsData
     */
    method: string;
    /**
     * 
     * @type {number}
     * @memberof GetReturnRefundDetailsData
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof GetReturnRefundDetailsData
     */
    methodDetail: string;
}
/**
 * 
 * @export
 * @interface GetReturnRefundDetailsResponse
 */
export interface GetReturnRefundDetailsResponse {
    /**
     * 
     * @type {Array<GetReturnRefundDetailsData>}
     * @memberof GetReturnRefundDetailsResponse
     */
    data: Array<GetReturnRefundDetailsData>;
}
/**
 * 
 * @export
 * @interface GetSFColoredProductSettingsListData
 */
export interface GetSFColoredProductSettingsListData {
    /**
     * 
     * @type {string}
     * @memberof GetSFColoredProductSettingsListData
     */
    coloredProductId: string;
    /**
     * 
     * @type {string}
     * @memberof GetSFColoredProductSettingsListData
     */
    productName: string;
    /**
     * 
     * @type {number}
     * @memberof GetSFColoredProductSettingsListData
     */
    productPrice: number | null;
    /**
     * 
     * @type {number}
     * @memberof GetSFColoredProductSettingsListData
     */
    productMinOrderQuantity: number;
    /**
     * 
     * @type {string}
     * @memberof GetSFColoredProductSettingsListData
     */
    productShipTo: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetSFColoredProductSettingsListData
     */
    productShipping: string | null;
}
/**
 * 
 * @export
 * @interface GetShippingCostListResponse
 */
export interface GetShippingCostListResponse {
    /**
     * 
     * @type {Array<GetShippingCostResponse>}
     * @memberof GetShippingCostListResponse
     */
    data: Array<GetShippingCostResponse>;
    /**
     * 
     * @type {number}
     * @memberof GetShippingCostListResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetShippingCostResponse
 */
export interface GetShippingCostResponse {
    /**
     * 
     * @type {string}
     * @memberof GetShippingCostResponse
     */
    id: string;
    /**
     * 
     * @type {number}
     * @memberof GetShippingCostResponse
     */
    minOrderLimit: number;
    /**
     * 
     * @type {number}
     * @memberof GetShippingCostResponse
     */
    maxOrderLimit: number;
    /**
     * 
     * @type {number}
     * @memberof GetShippingCostResponse
     */
    shippingCost: number;
}
/**
 * 
 * @export
 * @interface GetShippingInfoListResponse
 */
export interface GetShippingInfoListResponse {
    /**
     * 
     * @type {Array<GetShippingInfoResponse>}
     * @memberof GetShippingInfoListResponse
     */
    data: Array<GetShippingInfoResponse>;
    /**
     * 
     * @type {number}
     * @memberof GetShippingInfoListResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetShippingInfoResponse
 */
export interface GetShippingInfoResponse {
    /**
     * 
     * @type {string}
     * @memberof GetShippingInfoResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetShippingInfoResponse
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof GetShippingInfoResponse
     */
    rate: number;
}
/**
 * 
 * @export
 * @interface GetShippingLabelPDFResponse
 */
export interface GetShippingLabelPDFResponse {
    /**
     * 
     * @type {string}
     * @memberof GetShippingLabelPDFResponse
     */
    url: string;
}
/**
 * 
 * @export
 * @interface GetSizeChartFileResponse
 */
export interface GetSizeChartFileResponse {
    /**
     * 
     * @type {string}
     * @memberof GetSizeChartFileResponse
     */
    url: string;
}
/**
 * 
 * @export
 * @interface GetSizeChartResponse
 */
export interface GetSizeChartResponse {
    /**
     * 
     * @type {string}
     * @memberof GetSizeChartResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetSizeChartResponse
     */
    sku: string;
    /**
     * 
     * @type {string}
     * @memberof GetSizeChartResponse
     */
    fileId: string;
    /**
     * 
     * @type {GetDirectAccessMediaFileResponse | GetPrivateAccessMediaFileResponse}
     * @memberof GetSizeChartResponse
     */
    file: GetDirectAccessMediaFileResponse | GetPrivateAccessMediaFileResponse | null;
}
/**
 * 
 * @export
 * @interface GetStoreCreditsResponse
 */
export interface GetStoreCreditsResponse {
    /**
     * 
     * @type {string}
     * @memberof GetStoreCreditsResponse
     */
    id: string;
    /**
     * 
     * @type {number}
     * @memberof GetStoreCreditsResponse
     */
    storeCredits: number | null;
}
/**
 * 
 * @export
 * @interface GetTechPackData
 */
export interface GetTechPackData {
    /**
     * 
     * @type {string}
     * @memberof GetTechPackData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetTechPackData
     */
    programParentProductId: string;
    /**
     * 
     * @type {string}
     * @memberof GetTechPackData
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof GetTechPackData
     */
    createdDate: string;
    /**
     * 
     * @type {string}
     * @memberof GetTechPackData
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof GetTechPackData
     */
    imageId: string | null;
    /**
     * 
     * @type {GetDirectAccessMediaFileResponse | GetPrivateAccessMediaFileResponse}
     * @memberof GetTechPackData
     */
    image: GetDirectAccessMediaFileResponse | GetPrivateAccessMediaFileResponse | null;
}
/**
 * 
 * @export
 * @interface GetTechPackImageResponse
 */
export interface GetTechPackImageResponse {
    /**
     * 
     * @type {string}
     * @memberof GetTechPackImageResponse
     */
    url: string;
}
/**
 * 
 * @export
 * @interface GetTechPackListResponse
 */
export interface GetTechPackListResponse {
    /**
     * 
     * @type {number}
     * @memberof GetTechPackListResponse
     */
    nextCursor: number;
    /**
     * 
     * @type {Array<GetTechPackData>}
     * @memberof GetTechPackListResponse
     */
    techPacks: Array<GetTechPackData>;
    /**
     * 
     * @type {number}
     * @memberof GetTechPackListResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetTextureListData
 */
export interface GetTextureListData {
    /**
     * 
     * @type {string}
     * @memberof GetTextureListData
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof GetTextureListData
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetTextureListData
     */
    canCombine: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetTextureListData
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof GetTextureListData
     */
    updatedAt: string;
    /**
     * 
     * @type {string}
     * @memberof GetTextureListData
     */
    deletedAt: string | null;
}
/**
 * 
 * @export
 * @interface GetTextureListResponse
 */
export interface GetTextureListResponse {
    /**
     * 
     * @type {Array<GetTextureListData>}
     * @memberof GetTextureListResponse
     */
    data: Array<GetTextureListData>;
    /**
     * 
     * @type {number}
     * @memberof GetTextureListResponse
     */
    total: number;
}
/**
 * 
 * @export
 * @interface GetTotalCartQuantityResponse
 */
export interface GetTotalCartQuantityResponse {
    /**
     * 
     * @type {number}
     * @memberof GetTotalCartQuantityResponse
     */
    totalCount: number;
}
/**
 * 
 * @export
 * @interface HealthReponse
 */
export interface HealthReponse {
    /**
     * 
     * @type {string}
     * @memberof HealthReponse
     */
    status: string;
}
/**
 * 
 * @export
 * @interface ImageAndColoredProductNotRelatedError
 */
export interface ImageAndColoredProductNotRelatedError {
    /**
     * 
     * @type {string}
     * @memberof ImageAndColoredProductNotRelatedError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ImageAndColoredProductNotRelatedError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ImageAndProgramProductNotRelatedError
 */
export interface ImageAndProgramProductNotRelatedError {
    /**
     * 
     * @type {string}
     * @memberof ImageAndProgramProductNotRelatedError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ImageAndProgramProductNotRelatedError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ImagesRequiredForReturnError
 */
export interface ImagesRequiredForReturnError {
    /**
     * 
     * @type {string}
     * @memberof ImagesRequiredForReturnError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ImagesRequiredForReturnError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface InlineResponse400
 */
export interface InlineResponse400 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse400
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse400
     */
    message?: string;
    /**
     * 
     * @type {Array<InternalServerError | ForbiddenError | UnauthorizedError>}
     * @memberof InlineResponse400
     */
    errors?: Array<InternalServerError | ForbiddenError | UnauthorizedError>;
}
/**
 * 
 * @export
 * @interface InlineResponse4001
 */
export interface InlineResponse4001 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse4001
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4001
     */
    message?: string;
    /**
     * 
     * @type {Array<FailedToGetResourceError | InternalServerError | ForbiddenError | UnauthorizedError>}
     * @memberof InlineResponse4001
     */
    errors?: Array<FailedToGetResourceError | InternalServerError | ForbiddenError | UnauthorizedError>;
}
/**
 * 
 * @export
 * @interface InlineResponse4002
 */
export interface InlineResponse4002 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse4002
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4002
     */
    message?: string;
    /**
     * 
     * @type {Array<ProgramNotFoundError | ProgramNotActiveError | InternalServerError>}
     * @memberof InlineResponse4002
     */
    errors?: Array<ProgramNotFoundError | ProgramNotActiveError | InternalServerError>;
}
/**
 * 
 * @export
 * @interface InlineResponse4003
 */
export interface InlineResponse4003 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse4003
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4003
     */
    message?: string;
    /**
     * 
     * @type {Array<ProgramNotFoundError | InternalServerError | ForbiddenError | UnauthorizedError>}
     * @memberof InlineResponse4003
     */
    errors?: Array<ProgramNotFoundError | InternalServerError | ForbiddenError | UnauthorizedError>;
}
/**
 * 
 * @export
 * @interface InlineResponse4004
 */
export interface InlineResponse4004 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse4004
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4004
     */
    message?: string;
    /**
     * 
     * @type {Array<ProgramNotFoundError | FailedToGetResourceError | InternalServerError | ForbiddenError | UnauthorizedError>}
     * @memberof InlineResponse4004
     */
    errors?: Array<ProgramNotFoundError | FailedToGetResourceError | InternalServerError | ForbiddenError | UnauthorizedError>;
}
/**
 * 
 * @export
 * @interface InlineResponse4005
 */
export interface InlineResponse4005 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse4005
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4005
     */
    message?: string;
    /**
     * 
     * @type {Array<InternalServerError>}
     * @memberof InlineResponse4005
     */
    errors?: Array<InternalServerError>;
}
/**
 * 
 * @export
 * @interface InlineResponse4006
 */
export interface InlineResponse4006 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse4006
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4006
     */
    message?: string;
    /**
     * 
     * @type {Array<UserDoesNotHavePrivilegesError | FailedToGetResourceError | OrderNotFoundError | InternalServerError | ForbiddenError | UnauthorizedError>}
     * @memberof InlineResponse4006
     */
    errors?: Array<UserDoesNotHavePrivilegesError | FailedToGetResourceError | OrderNotFoundError | InternalServerError | ForbiddenError | UnauthorizedError>;
}
/**
 * 
 * @export
 * @interface InlineResponse4007
 */
export interface InlineResponse4007 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse4007
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4007
     */
    message?: string;
    /**
     * 
     * @type {Array<ProgramNotFoundError | UserIsNotEligibleForAccessProgramError | UserIsNotEligibleForAccessError | FailedToGetResourceError | InternalServerError | ForbiddenError | UnauthorizedError>}
     * @memberof InlineResponse4007
     */
    errors?: Array<ProgramNotFoundError | UserIsNotEligibleForAccessProgramError | UserIsNotEligibleForAccessError | FailedToGetResourceError | InternalServerError | ForbiddenError | UnauthorizedError>;
}
/**
 * 
 * @export
 * @interface InlineResponse4008
 */
export interface InlineResponse4008 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse4008
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4008
     */
    message?: string;
    /**
     * 
     * @type {Array<UserNotFoundError | WrongPasswordError | SameAsOneOfPreviousPasswordsError | InternalServerError | ForbiddenError | UnauthorizedError>}
     * @memberof InlineResponse4008
     */
    errors?: Array<UserNotFoundError | WrongPasswordError | SameAsOneOfPreviousPasswordsError | InternalServerError | ForbiddenError | UnauthorizedError>;
}
/**
 * 
 * @export
 * @interface InlineResponse4009
 */
export interface InlineResponse4009 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse4009
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse4009
     */
    message?: string;
    /**
     * 
     * @type {Array<ProgramNotFoundError | UserNotActiveError | UserNotFoundError | InternalServerError>}
     * @memberof InlineResponse4009
     */
    errors?: Array<ProgramNotFoundError | UserNotActiveError | UserNotFoundError | InternalServerError>;
}
/**
 * 
 * @export
 * @interface InternalServerError
 */
export interface InternalServerError {
    /**
     * 
     * @type {string}
     * @memberof InternalServerError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof InternalServerError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface Invalid3dModelError
 */
export interface Invalid3dModelError {
    /**
     * 
     * @type {string}
     * @memberof Invalid3dModelError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof Invalid3dModelError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface InvalidBoolValidationError
 */
export interface InvalidBoolValidationError {
    /**
     * 
     * @type {string}
     * @memberof InvalidBoolValidationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof InvalidBoolValidationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface InvalidDateRangeError
 */
export interface InvalidDateRangeError {
    /**
     * 
     * @type {string}
     * @memberof InvalidDateRangeError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof InvalidDateRangeError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface InvalidDateValidationError
 */
export interface InvalidDateValidationError {
    /**
     * 
     * @type {string}
     * @memberof InvalidDateValidationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof InvalidDateValidationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface InvalidDecimalValidationError
 */
export interface InvalidDecimalValidationError {
    /**
     * 
     * @type {string}
     * @memberof InvalidDecimalValidationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof InvalidDecimalValidationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface InvalidEmailValidationError
 */
export interface InvalidEmailValidationError {
    /**
     * 
     * @type {string}
     * @memberof InvalidEmailValidationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof InvalidEmailValidationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface InvalidEnumValidationError
 */
export interface InvalidEnumValidationError {
    /**
     * 
     * @type {string}
     * @memberof InvalidEnumValidationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof InvalidEnumValidationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface InvalidIntValidationError
 */
export interface InvalidIntValidationError {
    /**
     * 
     * @type {string}
     * @memberof InvalidIntValidationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof InvalidIntValidationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface InvalidNumberValidationError
 */
export interface InvalidNumberValidationError {
    /**
     * 
     * @type {string}
     * @memberof InvalidNumberValidationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof InvalidNumberValidationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface InvalidOverrideRefundAmountError
 */
export interface InvalidOverrideRefundAmountError {
    /**
     * 
     * @type {string}
     * @memberof InvalidOverrideRefundAmountError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof InvalidOverrideRefundAmountError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface InvalidPasswordError
 */
export interface InvalidPasswordError {
    /**
     * 
     * @type {string}
     * @memberof InvalidPasswordError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof InvalidPasswordError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface InvalidPaymentAmountError
 */
export interface InvalidPaymentAmountError {
    /**
     * 
     * @type {string}
     * @memberof InvalidPaymentAmountError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof InvalidPaymentAmountError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface InvalidPermissionForUserTypeError
 */
export interface InvalidPermissionForUserTypeError {
    /**
     * 
     * @type {string}
     * @memberof InvalidPermissionForUserTypeError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof InvalidPermissionForUserTypeError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface InvalidPermissionNameError
 */
export interface InvalidPermissionNameError {
    /**
     * 
     * @type {string}
     * @memberof InvalidPermissionNameError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof InvalidPermissionNameError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface InvalidPhoneNumberError
 */
export interface InvalidPhoneNumberError {
    /**
     * 
     * @type {string}
     * @memberof InvalidPhoneNumberError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof InvalidPhoneNumberError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface InvalidPricesFortheProgramProductsError
 */
export interface InvalidPricesFortheProgramProductsError {
    /**
     * 
     * @type {string}
     * @memberof InvalidPricesFortheProgramProductsError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof InvalidPricesFortheProgramProductsError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface InvalidStringValidationError
 */
export interface InvalidStringValidationError {
    /**
     * 
     * @type {string}
     * @memberof InvalidStringValidationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof InvalidStringValidationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface InvalidValueValidationError
 */
export interface InvalidValueValidationError {
    /**
     * 
     * @type {string}
     * @memberof InvalidValueValidationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof InvalidValueValidationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface InviteProgramDto
 */
export interface InviteProgramDto {
    /**
     * 
     * @type {string}
     * @memberof InviteProgramDto
     */
    domain: string;
}
/**
 * 
 * @export
 * @interface InviteProgramUserDto
 */
export interface InviteProgramUserDto {
    /**
     * 
     * @type {string}
     * @memberof InviteProgramUserDto
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof InviteProgramUserDto
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof InviteProgramUserDto
     */
    lastName: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InviteProgramUserDto
     */
    permissions: Array<InviteProgramUserDtoPermissionsEnum>;
    /**
     * 
     * @type {string}
     * @memberof InviteProgramUserDto
     */
    programId: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InviteProgramUserDtoPermissionsEnum {
    Pc = 'PC',
    Pf = 'PF',
    Pp = 'PP',
    Ps = 'PS',
    Pa = 'PA'
}

/**
 * 
 * @export
 * @interface InviteRebelAdminDto
 */
export interface InviteRebelAdminDto {
    /**
     * 
     * @type {string}
     * @memberof InviteRebelAdminDto
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof InviteRebelAdminDto
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof InviteRebelAdminDto
     */
    lastName: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InviteRebelAdminDto
     */
    permissions: Array<InviteRebelAdminDtoPermissionsEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum InviteRebelAdminDtoPermissionsEnum {
    Sa = 'SA',
    So = 'SO',
    Sd = 'SD',
    Sr = 'SR',
    Sp = 'SP'
}

/**
 * 
 * @export
 * @interface ItemReturnRequestDTO
 */
export interface ItemReturnRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof ItemReturnRequestDTO
     */
    reasonId: string;
    /**
     * 
     * @type {string}
     * @memberof ItemReturnRequestDTO
     */
    orderItemId: string;
    /**
     * 
     * @type {number}
     * @memberof ItemReturnRequestDTO
     */
    quantity: number;
    /**
     * 
     * @type {string}
     * @memberof ItemReturnRequestDTO
     */
    explanation?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemReturnRequestDTO
     */
    images?: Array<string>;
}
/**
 * 
 * @export
 * @interface Layer3DNotFoundError
 */
export interface Layer3DNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof Layer3DNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof Layer3DNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface LimitExceedBulkCustomersUpdate
 */
export interface LimitExceedBulkCustomersUpdate {
    /**
     * 
     * @type {string}
     * @memberof LimitExceedBulkCustomersUpdate
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof LimitExceedBulkCustomersUpdate
     */
    type: string;
}
/**
 * 
 * @export
 * @interface MarkDeliveredRequestDTO
 */
export interface MarkDeliveredRequestDTO {
    /**
     * 
     * @type {Array<string>}
     * @memberof MarkDeliveredRequestDTO
     */
    orderDisplayIds: Array<string>;
}
/**
 * 
 * @export
 * @interface MaxNumberValidationError
 */
export interface MaxNumberValidationError {
    /**
     * 
     * @type {string}
     * @memberof MaxNumberValidationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof MaxNumberValidationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface MaxStringLengthValidationError
 */
export interface MaxStringLengthValidationError {
    /**
     * 
     * @type {string}
     * @memberof MaxStringLengthValidationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof MaxStringLengthValidationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface MediaFileFailedToProcessError
 */
export interface MediaFileFailedToProcessError {
    /**
     * 
     * @type {string}
     * @memberof MediaFileFailedToProcessError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof MediaFileFailedToProcessError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface MediaFileInvalidError
 */
export interface MediaFileInvalidError {
    /**
     * 
     * @type {string}
     * @memberof MediaFileInvalidError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof MediaFileInvalidError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface MediaFileMetadata
 */
export interface MediaFileMetadata {
    /**
     * 
     * @type {string}
     * @memberof MediaFileMetadata
     */
    mimeType: string;
    /**
     * 
     * @type {number}
     * @memberof MediaFileMetadata
     */
    fileSize: number;
    /**
     * 
     * @type {number}
     * @memberof MediaFileMetadata
     */
    ratio: number | null;
}
/**
 * 
 * @export
 * @interface MediaFileNotFoundError
 */
export interface MediaFileNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof MediaFileNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof MediaFileNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface MediaFileTypeMetaDataNotFoundError
 */
export interface MediaFileTypeMetaDataNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof MediaFileTypeMetaDataNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof MediaFileTypeMetaDataNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface MinNumberValidationError
 */
export interface MinNumberValidationError {
    /**
     * 
     * @type {string}
     * @memberof MinNumberValidationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof MinNumberValidationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface MinStringLengthValidationError
 */
export interface MinStringLengthValidationError {
    /**
     * 
     * @type {string}
     * @memberof MinStringLengthValidationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof MinStringLengthValidationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface Model3DAndProductNotRelatedError
 */
export interface Model3DAndProductNotRelatedError {
    /**
     * 
     * @type {string}
     * @memberof Model3DAndProductNotRelatedError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof Model3DAndProductNotRelatedError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface Model3DNotFoundError
 */
export interface Model3DNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof Model3DNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof Model3DNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ModelShouldBeUploadedForTheChosenArtworkTypeError
 */
export interface ModelShouldBeUploadedForTheChosenArtworkTypeError {
    /**
     * 
     * @type {string}
     * @memberof ModelShouldBeUploadedForTheChosenArtworkTypeError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ModelShouldBeUploadedForTheChosenArtworkTypeError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface MultipleItemReturnRequestDTO
 */
export interface MultipleItemReturnRequestDTO {
    /**
     * 
     * @type {string}
     * @memberof MultipleItemReturnRequestDTO
     */
    paymentMethod: string;
    /**
     * 
     * @type {Array<ItemReturnRequestDTO>}
     * @memberof MultipleItemReturnRequestDTO
     */
    items: Array<ItemReturnRequestDTO>;
}
/**
 * 
 * @export
 * @interface MultipleItemReturnRespondDTO
 */
export interface MultipleItemReturnRespondDTO {
    /**
     * 
     * @type {Array<ReturnOrderItemDTO>}
     * @memberof MultipleItemReturnRespondDTO
     */
    items: Array<ReturnOrderItemDTO>;
    /**
     * 
     * @type {string}
     * @memberof MultipleItemReturnRespondDTO
     */
    overrideRefundMethod?: string;
    /**
     * 
     * @type {number}
     * @memberof MultipleItemReturnRespondDTO
     */
    overrideRefundAmount?: number;
}
/**
 * 
 * @export
 * @interface MultiplePricesFoundFortheProgramProductsError
 */
export interface MultiplePricesFoundFortheProgramProductsError {
    /**
     * 
     * @type {string}
     * @memberof MultiplePricesFoundFortheProgramProductsError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof MultiplePricesFoundFortheProgramProductsError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface NoProductsFoundForOrderCheckout
 */
export interface NoProductsFoundForOrderCheckout {
    /**
     * 
     * @type {string}
     * @memberof NoProductsFoundForOrderCheckout
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof NoProductsFoundForOrderCheckout
     */
    type: string;
}
/**
 * 
 * @export
 * @interface NoProductsInCart
 */
export interface NoProductsInCart {
    /**
     * 
     * @type {string}
     * @memberof NoProductsInCart
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof NoProductsInCart
     */
    type: string;
}
/**
 * 
 * @export
 * @interface NoTextureOptionsSelectedError
 */
export interface NoTextureOptionsSelectedError {
    /**
     * 
     * @type {string}
     * @memberof NoTextureOptionsSelectedError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof NoTextureOptionsSelectedError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface NotEligibleForRefundApprovalDenialError
 */
export interface NotEligibleForRefundApprovalDenialError {
    /**
     * 
     * @type {string}
     * @memberof NotEligibleForRefundApprovalDenialError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof NotEligibleForRefundApprovalDenialError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface NotEnoughStoreCreditsError
 */
export interface NotEnoughStoreCreditsError {
    /**
     * 
     * @type {string}
     * @memberof NotEnoughStoreCreditsError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof NotEnoughStoreCreditsError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface NotMatchingRegexValidationError
 */
export interface NotMatchingRegexValidationError {
    /**
     * 
     * @type {string}
     * @memberof NotMatchingRegexValidationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof NotMatchingRegexValidationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface NotOneOfValuesValidationError
 */
export interface NotOneOfValuesValidationError {
    /**
     * 
     * @type {string}
     * @memberof NotOneOfValuesValidationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof NotOneOfValuesValidationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface OneOeMoreImagesDoesNotBelongToTheProgramProduct
 */
export interface OneOeMoreImagesDoesNotBelongToTheProgramProduct {
    /**
     * 
     * @type {string}
     * @memberof OneOeMoreImagesDoesNotBelongToTheProgramProduct
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof OneOeMoreImagesDoesNotBelongToTheProgramProduct
     */
    type: string;
}
/**
 * 
 * @export
 * @interface OneOrAllCategoriesNotFoundError
 */
export interface OneOrAllCategoriesNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof OneOrAllCategoriesNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof OneOrAllCategoriesNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface OneOrAllProgramParentProductsNotFoundError
 */
export interface OneOrAllProgramParentProductsNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof OneOrAllProgramParentProductsNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof OneOrAllProgramParentProductsNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface OneOrAllSFProductsNotFoundError
 */
export interface OneOrAllSFProductsNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof OneOrAllSFProductsNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof OneOrAllSFProductsNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface OneOrManyofTheChosenProgramProductsDonotBelongToProgramParentProductError
 */
export interface OneOrManyofTheChosenProgramProductsDonotBelongToProgramParentProductError {
    /**
     * 
     * @type {string}
     * @memberof OneOrManyofTheChosenProgramProductsDonotBelongToProgramParentProductError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof OneOrManyofTheChosenProgramProductsDonotBelongToProgramParentProductError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface OrderAddressForInvoice
 */
export interface OrderAddressForInvoice {
    /**
     * 
     * @type {string}
     * @memberof OrderAddressForInvoice
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof OrderAddressForInvoice
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof OrderAddressForInvoice
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof OrderAddressForInvoice
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof OrderAddressForInvoice
     */
    phone: string;
    /**
     * 
     * @type {string}
     * @memberof OrderAddressForInvoice
     */
    addressLine1: string;
    /**
     * 
     * @type {string}
     * @memberof OrderAddressForInvoice
     */
    addressLine2: string;
    /**
     * 
     * @type {string}
     * @memberof OrderAddressForInvoice
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof OrderAddressForInvoice
     */
    state: string;
    /**
     * 
     * @type {string}
     * @memberof OrderAddressForInvoice
     */
    zipCode: string;
}
/**
 * 
 * @export
 * @interface OrderAddressNotFoundError
 */
export interface OrderAddressNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof OrderAddressNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof OrderAddressNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface OrderAlreadyPaidError
 */
export interface OrderAlreadyPaidError {
    /**
     * 
     * @type {string}
     * @memberof OrderAlreadyPaidError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof OrderAlreadyPaidError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface OrderCheckoutDTO
 */
export interface OrderCheckoutDTO {
    /**
     * 
     * @type {string}
     * @memberof OrderCheckoutDTO
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof OrderCheckoutDTO
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof OrderCheckoutDTO
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof OrderCheckoutDTO
     */
    phone: string;
    /**
     * 
     * @type {string}
     * @memberof OrderCheckoutDTO
     */
    addressLine1: string;
    /**
     * 
     * @type {string}
     * @memberof OrderCheckoutDTO
     */
    addressLine2: string;
    /**
     * 
     * @type {string}
     * @memberof OrderCheckoutDTO
     */
    zipCode: string;
    /**
     * 
     * @type {string}
     * @memberof OrderCheckoutDTO
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof OrderCheckoutDTO
     */
    state: string;
    /**
     * 
     * @type {string}
     * @memberof OrderCheckoutDTO
     */
    billingAddressLine1: string;
    /**
     * 
     * @type {string}
     * @memberof OrderCheckoutDTO
     */
    billingAddressLine2: string;
    /**
     * 
     * @type {string}
     * @memberof OrderCheckoutDTO
     */
    billingAddressZipCode: string;
    /**
     * 
     * @type {string}
     * @memberof OrderCheckoutDTO
     */
    billingAddressCity: string;
    /**
     * 
     * @type {string}
     * @memberof OrderCheckoutDTO
     */
    billingAddressState: string;
    /**
     * 
     * @type {string}
     * @memberof OrderCheckoutDTO
     */
    transactionId: string;
    /**
     * 
     * @type {string}
     * @memberof OrderCheckoutDTO
     */
    customerCardId?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderCheckoutDTO
     */
    amount: number;
    /**
     * 
     * @type {boolean}
     * @memberof OrderCheckoutDTO
     */
    includeStoreCredits?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrderCheckoutDTO
     */
    saveForFuturePurchase?: boolean;
}
/**
 * 
 * @export
 * @interface OrderGroupNotFoundError
 */
export interface OrderGroupNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof OrderGroupNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof OrderGroupNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface OrderItemForInvoice
 */
export interface OrderItemForInvoice {
    /**
     * 
     * @type {string}
     * @memberof OrderItemForInvoice
     */
    orderItemId: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemForInvoice
     */
    orderItemDisplayId: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemForInvoice
     */
    programProductId: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemForInvoice
     */
    productName: string;
    /**
     * 
     * @type {number}
     * @memberof OrderItemForInvoice
     */
    quantity: number;
    /**
     * 
     * @type {number}
     * @memberof OrderItemForInvoice
     */
    price: number;
    /**
     * 
     * @type {number}
     * @memberof OrderItemForInvoice
     */
    taxFee: number | null;
    /**
     * 
     * @type {number}
     * @memberof OrderItemForInvoice
     */
    subTotal: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof OrderItemForInvoice
     */
    isCustom: boolean;
    /**
     * 
     * @type {OrderStatus}
     * @memberof OrderItemForInvoice
     */
    status: OrderStatus;
    /**
     * 
     * @type {string}
     * @memberof OrderItemForInvoice
     */
    size: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderItemForInvoice
     */
    color: string | null;
    /**
     * 
     * @type {string}
     * @memberof OrderItemForInvoice
     */
    sku: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrderItemForInvoice
     */
    isMoqMet: boolean;
    /**
     * 
     * @type {number}
     * @memberof OrderItemForInvoice
     */
    minimumOrderQuantity: number;
    /**
     * 
     * @type {number}
     * @memberof OrderItemForInvoice
     */
    receivedOrderQuantity: number;
}
/**
 * 
 * @export
 * @interface OrderItemNotFoundError
 */
export interface OrderItemNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof OrderItemNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface OrderItemReturnDetails
 */
export interface OrderItemReturnDetails {
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnDetails
     */
    orderItemReturnId: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnDetails
     */
    orderReturnId: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnDetails
     */
    orderItemId: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnDetails
     */
    orderId: string;
    /**
     * 
     * @type {OrderItemReturnStatus}
     * @memberof OrderItemReturnDetails
     */
    status: OrderItemReturnStatus;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnDetails
     */
    statusText: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnDetails
     */
    programId: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnDetails
     */
    programName: string;
    /**
     * 
     * @type {number}
     * @memberof OrderItemReturnDetails
     */
    paidAmount: number;
    /**
     * 
     * @type {number}
     * @memberof OrderItemReturnDetails
     */
    profit: number;
    /**
     * 
     * @type {number}
     * @memberof OrderItemReturnDetails
     */
    priceSold: number;
    /**
     * 
     * @type {number}
     * @memberof OrderItemReturnDetails
     */
    cost: number;
    /**
     * 
     * @type {number}
     * @memberof OrderItemReturnDetails
     */
    logoQuantity: number;
    /**
     * 
     * @type {number}
     * @memberof OrderItemReturnDetails
     */
    logoPrice: number;
    /**
     * 
     * @type {number}
     * @memberof OrderItemReturnDetails
     */
    total: number;
    /**
     * 
     * @type {number}
     * @memberof OrderItemReturnDetails
     */
    quantity: number;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnDetails
     */
    customerFirstName: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnDetails
     */
    customerLastName: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnDetails
     */
    productName: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnDetails
     */
    orderItemDisplayId: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnDetails
     */
    orderDisplayId: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnDetails
     */
    orderItemReturnDisplayId: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnDetails
     */
    returnRequestedDate: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnDetails
     */
    orderedDate: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrderItemReturnDetails
     */
    customerCanKeepProduct: boolean;
}
/**
 * 
 * @export
 * @interface OrderItemReturnImageNotFoundError
 */
export interface OrderItemReturnImageNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnImageNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnImageNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface OrderItemReturnListResponse
 */
export interface OrderItemReturnListResponse {
    /**
     * 
     * @type {Array<OrderItemReturnDetails>}
     * @memberof OrderItemReturnListResponse
     */
    data: Array<OrderItemReturnDetails>;
    /**
     * 
     * @type {number}
     * @memberof OrderItemReturnListResponse
     */
    total: number;
    /**
     * 
     * @type {number}
     * @memberof OrderItemReturnListResponse
     */
    nextCursor: number;
}
/**
 * 
 * @export
 * @interface OrderItemReturnNotFoundError
 */
export interface OrderItemReturnNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface OrderItemReturnReceipt
 */
export interface OrderItemReturnReceipt {
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnReceipt
     */
    orderItemReturnId: string;
    /**
     * 
     * @type {OrderItemReturnStatus}
     * @memberof OrderItemReturnReceipt
     */
    status: OrderItemReturnStatus;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnReceipt
     */
    statusText: string;
    /**
     * 
     * @type {number}
     * @memberof OrderItemReturnReceipt
     */
    quantity: number;
    /**
     * 
     * @type {number}
     * @memberof OrderItemReturnReceipt
     */
    refundOriginalShippingFee: number;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnReceipt
     */
    productName: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrderItemReturnReceipt
     */
    customerCanKeepProduct: boolean;
}
/**
 * 
 * @export
 * @interface OrderItemReturnReceiptResponse
 */
export interface OrderItemReturnReceiptResponse {
    /**
     * 
     * @type {number}
     * @memberof OrderItemReturnReceiptResponse
     */
    restockingFeeApplied: number;
    /**
     * 
     * @type {Array<OrderReturnReceipt>}
     * @memberof OrderItemReturnReceiptResponse
     */
    orderReturn: Array<OrderReturnReceipt>;
}
/**
 * 
 * @export
 * @interface OrderItemReturnRequestAlreadySubmittedError
 */
export interface OrderItemReturnRequestAlreadySubmittedError {
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnRequestAlreadySubmittedError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnRequestAlreadySubmittedError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface OrderItemReturnRequestList
 */
export interface OrderItemReturnRequestList {
    /**
     * 
     * @type {Array<GetOrderReturnItemData>}
     * @memberof OrderItemReturnRequestList
     */
    data: Array<GetOrderReturnItemData>;
    /**
     * 
     * @type {number}
     * @memberof OrderItemReturnRequestList
     */
    total: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum OrderItemReturnStatus {
    ReturnRequested = 'return_requested',
    ReturnApproved = 'return_approved',
    ReturnDeclined = 'return_declined',
    RefundApproved = 'refund_approved',
    RefundDeclined = 'refund_declined'
}

/**
 * 
 * @export
 * @interface OrderItemReturnStatusList
 */
export interface OrderItemReturnStatusList {
    /**
     * 
     * @type {Array<OrderItemReturnStatusResponse>}
     * @memberof OrderItemReturnStatusList
     */
    data: Array<OrderItemReturnStatusResponse>;
    /**
     * 
     * @type {number}
     * @memberof OrderItemReturnStatusList
     */
    total: number;
}
/**
 * 
 * @export
 * @interface OrderItemReturnStatusResponse
 */
export interface OrderItemReturnStatusResponse {
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnStatusResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnStatusResponse
     */
    displayId: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnStatusResponse
     */
    orderItemId: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnStatusResponse
     */
    reasonId: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnStatusResponse
     */
    reason: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnStatusResponse
     */
    rma: string;
    /**
     * 
     * @type {OrderItemReturnStatus}
     * @memberof OrderItemReturnStatusResponse
     */
    status: OrderItemReturnStatus;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnStatusResponse
     */
    statusText: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReturnStatusResponse
     */
    explanation: string | null;
    /**
     * 
     * @type {number}
     * @memberof OrderItemReturnStatusResponse
     */
    quantity: number;
    /**
     * 
     * @type {number}
     * @memberof OrderItemReturnStatusResponse
     */
    refundSubTotal: number;
    /**
     * 
     * @type {number}
     * @memberof OrderItemReturnStatusResponse
     */
    refundTax: number;
    /**
     * 
     * @type {number}
     * @memberof OrderItemReturnStatusResponse
     */
    refundOriginalShippingFee: number;
    /**
     * 
     * @type {boolean}
     * @memberof OrderItemReturnStatusResponse
     */
    customerCanKeepProduct: boolean;
}
/**
 * 
 * @export
 * @interface OrderItemReviewRequestResponse
 */
export interface OrderItemReviewRequestResponse {
    /**
     * 
     * @type {string}
     * @memberof OrderItemReviewRequestResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReviewRequestResponse
     */
    displayId: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReviewRequestResponse
     */
    orderItemId: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReviewRequestResponse
     */
    reasonId: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReviewRequestResponse
     */
    reason: string;
    /**
     * 
     * @type {OrderItemReturnStatus}
     * @memberof OrderItemReviewRequestResponse
     */
    status: OrderItemReturnStatus;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReviewRequestResponse
     */
    statusText: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReviewRequestResponse
     */
    explanation: string | null;
    /**
     * 
     * @type {number}
     * @memberof OrderItemReviewRequestResponse
     */
    quantity: number;
    /**
     * 
     * @type {Array<GetOrderReturnImageData>}
     * @memberof OrderItemReviewRequestResponse
     */
    images: Array<GetOrderReturnImageData>;
    /**
     * 
     * @type {number}
     * @memberof OrderItemReviewRequestResponse
     */
    refundAmount: number;
    /**
     * 
     * @type {string}
     * @memberof OrderItemReviewRequestResponse
     */
    refundPaymentMethod: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrderItemReviewRequestResponse
     */
    customerCanKeepProduct: boolean;
}
/**
 * 
 * @export
 * @interface OrderNotFoundError
 */
export interface OrderNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof OrderNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof OrderNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum OrderPaidStatus {
    Pending = 'pending',
    Partial = 'partial',
    Paid = 'paid'
}

/**
 * 
 * @export
 * @interface OrderRefundDeclinedError
 */
export interface OrderRefundDeclinedError {
    /**
     * 
     * @type {string}
     * @memberof OrderRefundDeclinedError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof OrderRefundDeclinedError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface OrderRefundedError
 */
export interface OrderRefundedError {
    /**
     * 
     * @type {string}
     * @memberof OrderRefundedError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof OrderRefundedError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface OrderReturnNotFoundError
 */
export interface OrderReturnNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof OrderReturnNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof OrderReturnNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface OrderReturnReasonNotFoundError
 */
export interface OrderReturnReasonNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof OrderReturnReasonNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof OrderReturnReasonNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface OrderReturnReceipt
 */
export interface OrderReturnReceipt {
    /**
     * 
     * @type {number}
     * @memberof OrderReturnReceipt
     */
    refundAmount: number;
    /**
     * 
     * @type {string}
     * @memberof OrderReturnReceipt
     */
    refundPaymentMethod: string;
    /**
     * 
     * @type {number}
     * @memberof OrderReturnReceipt
     */
    returnShippingFee: number;
    /**
     * 
     * @type {string}
     * @memberof OrderReturnReceipt
     */
    returnInitiatedDate: string;
    /**
     * 
     * @type {OrderReturnRefundStatus}
     * @memberof OrderReturnReceipt
     */
    refundStatus: OrderReturnRefundStatus;
    /**
     * 
     * @type {Array<OrderItemReturnReceipt>}
     * @memberof OrderReturnReceipt
     */
    OrderItemReturnDetails: Array<OrderItemReturnReceipt>;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum OrderReturnRefundStatus {
    Pending = 'pending',
    Refunded = 'refunded',
    Partial = 'partial',
    Failed = 'failed'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum OrderStatus {
    Ordered = 'ordered',
    Shipped = 'shipped',
    Delivered = 'delivered',
    Cancelled = 'cancelled',
    Returned = 'returned',
    UnderReview = 'under_review',
    Requested = 'requested',
    Approved = 'approved',
    Declined = 'declined',
    Refunded = 'refunded',
    RefundFailed = 'refund_failed',
    RefundDeclined = 'refund_declined',
    MoqCancelled = 'moq_cancelled',
    MoqCancelRefundFailed = 'moq_cancel_refund_failed'
}

/**
 * 
 * @export
 * @interface OriginalMethodRefundData
 */
export interface OriginalMethodRefundData {
    /**
     * 
     * @type {number}
     * @memberof OriginalMethodRefundData
     */
    storeCredit: number;
    /**
     * 
     * @type {number}
     * @memberof OriginalMethodRefundData
     */
    total: number;
    /**
     * 
     * @type {number}
     * @memberof OriginalMethodRefundData
     */
    creditCard: number;
    /**
     * 
     * @type {string}
     * @memberof OriginalMethodRefundData
     */
    cardLast4Digit: string;
    /**
     * 
     * @type {string}
     * @memberof OriginalMethodRefundData
     */
    cardType: string;
    /**
     * 
     * @type {number}
     * @memberof OriginalMethodRefundData
     */
    restockingFee: number;
    /**
     * 
     * @type {number}
     * @memberof OriginalMethodRefundData
     */
    returnShippingFee: number;
}
/**
 * 
 * @export
 * @interface ParentInactiveInSFError
 */
export interface ParentInactiveInSFError {
    /**
     * 
     * @type {string}
     * @memberof ParentInactiveInSFError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ParentInactiveInSFError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface PasswordTokenExpiredError
 */
export interface PasswordTokenExpiredError {
    /**
     * 
     * @type {string}
     * @memberof PasswordTokenExpiredError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof PasswordTokenExpiredError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface PasswordTokenNotFoundError
 */
export interface PasswordTokenNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof PasswordTokenNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof PasswordTokenNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface PaymentDeclinedError
 */
export interface PaymentDeclinedError {
    /**
     * 
     * @type {string}
     * @memberof PaymentDeclinedError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentDeclinedError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface PaymentFailedError
 */
export interface PaymentFailedError {
    /**
     * 
     * @type {string}
     * @memberof PaymentFailedError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof PaymentFailedError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface PendingMoqNotMetOrdersNotFoundForApprovalOrDenialError
 */
export interface PendingMoqNotMetOrdersNotFoundForApprovalOrDenialError {
    /**
     * 
     * @type {string}
     * @memberof PendingMoqNotMetOrdersNotFoundForApprovalOrDenialError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof PendingMoqNotMetOrdersNotFoundForApprovalOrDenialError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface PermissionsRequiredError
 */
export interface PermissionsRequiredError {
    /**
     * 
     * @type {string}
     * @memberof PermissionsRequiredError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof PermissionsRequiredError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface PostalServiceServiceError
 */
export interface PostalServiceServiceError {
    /**
     * 
     * @type {string}
     * @memberof PostalServiceServiceError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof PostalServiceServiceError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface PriceShouldNotBeLessThanRecommendedPriceError
 */
export interface PriceShouldNotBeLessThanRecommendedPriceError {
    /**
     * 
     * @type {string}
     * @memberof PriceShouldNotBeLessThanRecommendedPriceError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof PriceShouldNotBeLessThanRecommendedPriceError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface PrivateUrlsData
 */
export interface PrivateUrlsData {
    /**
     * 
     * @type {string}
     * @memberof PrivateUrlsData
     */
    redirectUrl: string;
    /**
     * 
     * @type {string}
     * @memberof PrivateUrlsData
     */
    getUrl: string;
}
/**
 * 
 * @export
 * @interface Product3DColorLayerDTO
 */
export interface Product3DColorLayerDTO {
    /**
     * 
     * @type {string}
     * @memberof Product3DColorLayerDTO
     */
    layerId: string;
    /**
     * 
     * @type {string}
     * @memberof Product3DColorLayerDTO
     */
    color: string;
}
/**
 * 
 * @export
 * @interface Product3DColorNotFoundError
 */
export interface Product3DColorNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof Product3DColorNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof Product3DColorNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ProductImageNotFoundError
 */
export interface ProductImageNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof ProductImageNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ProductImageNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ProductIsNotActiveError
 */
export interface ProductIsNotActiveError {
    /**
     * 
     * @type {string}
     * @memberof ProductIsNotActiveError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ProductIsNotActiveError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ProductNotInStockError
 */
export interface ProductNotInStockError {
    /**
     * 
     * @type {string}
     * @memberof ProductNotInStockError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ProductNotInStockError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ProductSettingOverrideNotFound
 */
export interface ProductSettingOverrideNotFound {
    /**
     * 
     * @type {string}
     * @memberof ProductSettingOverrideNotFound
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ProductSettingOverrideNotFound
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ProductSettingsDataNotFoundToUpdate
 */
export interface ProductSettingsDataNotFoundToUpdate {
    /**
     * 
     * @type {string}
     * @memberof ProductSettingsDataNotFoundToUpdate
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ProductSettingsDataNotFoundToUpdate
     */
    type: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ProductStatus {
    Active = 'Active',
    Inactive = 'Inactive',
    Draft = 'Draft',
    Idle = 'Idle'
}

/**
 * 
 * @export
 * @interface ProductsPriceNotAvailable
 */
export interface ProductsPriceNotAvailable {
    /**
     * 
     * @type {string}
     * @memberof ProductsPriceNotAvailable
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ProductsPriceNotAvailable
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ProfitForProgramForLast12MonthsResponse
 */
export interface ProfitForProgramForLast12MonthsResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof ProfitForProgramForLast12MonthsResponse
     */
    data: Array<string>;
}
/**
 * 
 * @export
 * @interface ProgramArtworkColorNotFoundError
 */
export interface ProgramArtworkColorNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof ProgramArtworkColorNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramArtworkColorNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ProgramArtworkColorValidationError
 */
export interface ProgramArtworkColorValidationError {
    /**
     * 
     * @type {string}
     * @memberof ProgramArtworkColorValidationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramArtworkColorValidationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ProgramArtworkNotFoundError
 */
export interface ProgramArtworkNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof ProgramArtworkNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramArtworkNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ProgramBannerNotFoundError
 */
export interface ProgramBannerNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof ProgramBannerNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramBannerNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ProgramCannotAcceptNewCustomerError
 */
export interface ProgramCannotAcceptNewCustomerError {
    /**
     * 
     * @type {string}
     * @memberof ProgramCannotAcceptNewCustomerError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramCannotAcceptNewCustomerError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ProgramLogoNotFoundError
 */
export interface ProgramLogoNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof ProgramLogoNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramLogoNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ProgramNotActiveError
 */
export interface ProgramNotActiveError {
    /**
     * 
     * @type {string}
     * @memberof ProgramNotActiveError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramNotActiveError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ProgramNotFoundError
 */
export interface ProgramNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof ProgramNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ProgramOwnerAlreadyAssociatedWithOtherProgramError
 */
export interface ProgramOwnerAlreadyAssociatedWithOtherProgramError {
    /**
     * 
     * @type {string}
     * @memberof ProgramOwnerAlreadyAssociatedWithOtherProgramError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramOwnerAlreadyAssociatedWithOtherProgramError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ProgramOwnerNotFoundError
 */
export interface ProgramOwnerNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof ProgramOwnerNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramOwnerNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ProgramOwnerOnboardDto
 */
export interface ProgramOwnerOnboardDto {
    /**
     * 
     * @type {string}
     * @memberof ProgramOwnerOnboardDto
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramOwnerOnboardDto
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramOwnerOnboardDto
     */
    password: string;
}
/**
 * 
 * @export
 * @interface ProgramParentProductAndTechpackNotRelatedError
 */
export interface ProgramParentProductAndTechpackNotRelatedError {
    /**
     * 
     * @type {string}
     * @memberof ProgramParentProductAndTechpackNotRelatedError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramParentProductAndTechpackNotRelatedError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ProgramParentProductNotFoundError
 */
export interface ProgramParentProductNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof ProgramParentProductNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramParentProductNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ProgramParentProductNotPublishedError
 */
export interface ProgramParentProductNotPublishedError {
    /**
     * 
     * @type {string}
     * @memberof ProgramParentProductNotPublishedError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramParentProductNotPublishedError
     */
    type: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ProgramParentProductStatus {
    Active = 'Active',
    Inactive = 'Inactive',
    Draft = 'Draft'
}

/**
 * 
 * @export
 * @interface ProgramProductImageNotFoundError
 */
export interface ProgramProductImageNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof ProgramProductImageNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramProductImageNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ProgramProductNotFoundError
 */
export interface ProgramProductNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof ProgramProductNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramProductNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ProgramProductNotPublishedError
 */
export interface ProgramProductNotPublishedError {
    /**
     * 
     * @type {string}
     * @memberof ProgramProductNotPublishedError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramProductNotPublishedError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ProgramProductShouldHaveAtleastOneImageError
 */
export interface ProgramProductShouldHaveAtleastOneImageError {
    /**
     * 
     * @type {string}
     * @memberof ProgramProductShouldHaveAtleastOneImageError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramProductShouldHaveAtleastOneImageError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ProgramProfitResponse
 */
export interface ProgramProfitResponse {
    /**
     * 
     * @type {number}
     * @memberof ProgramProfitResponse
     */
    programProfit: number;
}
/**
 * 
 * @export
 * @interface ProgramRevenueResponse
 */
export interface ProgramRevenueResponse {
    /**
     * 
     * @type {number}
     * @memberof ProgramRevenueResponse
     */
    programRevenue: number;
}
/**
 * 
 * @export
 * @interface ProgramShippingNotFoundError
 */
export interface ProgramShippingNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof ProgramShippingNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ProgramShippingNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ProgramUserCountResponse
 */
export interface ProgramUserCountResponse {
    /**
     * 
     * @type {number}
     * @memberof ProgramUserCountResponse
     */
    adminCount: number;
    /**
     * 
     * @type {number}
     * @memberof ProgramUserCountResponse
     */
    customerCount: number;
    /**
     * 
     * @type {number}
     * @memberof ProgramUserCountResponse
     */
    requestCount: number;
}
/**
 * 
 * @export
 * @interface ProvideAllArtworkColorsToApplyArtworkValidationError
 */
export interface ProvideAllArtworkColorsToApplyArtworkValidationError {
    /**
     * 
     * @type {string}
     * @memberof ProvideAllArtworkColorsToApplyArtworkValidationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ProvideAllArtworkColorsToApplyArtworkValidationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ProvideTwoUniqueValuesToSwapValidationError
 */
export interface ProvideTwoUniqueValuesToSwapValidationError {
    /**
     * 
     * @type {string}
     * @memberof ProvideTwoUniqueValuesToSwapValidationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ProvideTwoUniqueValuesToSwapValidationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface PublishProgramProductsDTO
 */
export interface PublishProgramProductsDTO {
    /**
     * 
     * @type {Array<string>}
     * @memberof PublishProgramProductsDTO
     */
    coloredProductIds: Array<string>;
}
/**
 * 
 * @export
 * @interface PublishProgramProductsValidationError
 */
export interface PublishProgramProductsValidationError {
    /**
     * 
     * @type {string}
     * @memberof PublishProgramProductsValidationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof PublishProgramProductsValidationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ReasonNotAllowedForReturnError
 */
export interface ReasonNotAllowedForReturnError {
    /**
     * 
     * @type {string}
     * @memberof ReasonNotAllowedForReturnError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ReasonNotAllowedForReturnError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ReceivedOrderQuantityMoreThanInventoryCount
 */
export interface ReceivedOrderQuantityMoreThanInventoryCount {
    /**
     * 
     * @type {string}
     * @memberof ReceivedOrderQuantityMoreThanInventoryCount
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ReceivedOrderQuantityMoreThanInventoryCount
     */
    type: string;
}
/**
 * 
 * @export
 * @interface RefreshTokenDto
 */
export interface RefreshTokenDto {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenDto
     */
    refreshToken: string;
}
/**
 * 
 * @export
 * @interface RefreshTokenExpiredOrNotActiveError
 */
export interface RefreshTokenExpiredOrNotActiveError {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenExpiredOrNotActiveError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenExpiredOrNotActiveError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface RefundFailedError
 */
export interface RefundFailedError {
    /**
     * 
     * @type {string}
     * @memberof RefundFailedError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof RefundFailedError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface RespondReturnOrderDTO
 */
export interface RespondReturnOrderDTO {
    /**
     * 
     * @type {boolean}
     * @memberof RespondReturnOrderDTO
     */
    createRefund?: boolean;
}
/**
 * 
 * @export
 * @interface RetryPaymentDTO
 */
export interface RetryPaymentDTO {
    /**
     * 
     * @type {string}
     * @memberof RetryPaymentDTO
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof RetryPaymentDTO
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof RetryPaymentDTO
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof RetryPaymentDTO
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof RetryPaymentDTO
     */
    billingAddressLine1?: string;
    /**
     * 
     * @type {string}
     * @memberof RetryPaymentDTO
     */
    billingAddressLine2?: string;
    /**
     * 
     * @type {string}
     * @memberof RetryPaymentDTO
     */
    billingAddressZipCode?: string;
    /**
     * 
     * @type {string}
     * @memberof RetryPaymentDTO
     */
    billingAddressCity?: string;
    /**
     * 
     * @type {string}
     * @memberof RetryPaymentDTO
     */
    billingAddressState?: string;
    /**
     * 
     * @type {string}
     * @memberof RetryPaymentDTO
     */
    transactionId?: string;
    /**
     * 
     * @type {string}
     * @memberof RetryPaymentDTO
     */
    customerCardId?: string;
    /**
     * 
     * @type {number}
     * @memberof RetryPaymentDTO
     */
    amount: number;
    /**
     * 
     * @type {boolean}
     * @memberof RetryPaymentDTO
     */
    includeStoreCredits?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RetryPaymentDTO
     */
    saveForFuturePurchase?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RetryPaymentDTO
     */
    billingSameAsShipping?: boolean;
}
/**
 * 
 * @export
 * @interface ReturnOrderDeliveredStatusError
 */
export interface ReturnOrderDeliveredStatusError {
    /**
     * 
     * @type {string}
     * @memberof ReturnOrderDeliveredStatusError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ReturnOrderDeliveredStatusError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ReturnOrderItemDTO
 */
export interface ReturnOrderItemDTO {
    /**
     * 
     * @type {boolean}
     * @memberof ReturnOrderItemDTO
     */
    createRefund?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ReturnOrderItemDTO
     */
    orderItemReturnId: string;
    /**
     * 
     * @type {string}
     * @memberof ReturnOrderItemDTO
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ReturnOrderRequestedStatusError
 */
export interface ReturnOrderRequestedStatusError {
    /**
     * 
     * @type {string}
     * @memberof ReturnOrderRequestedStatusError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ReturnOrderRequestedStatusError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ReturnOrderStatusError
 */
export interface ReturnOrderStatusError {
    /**
     * 
     * @type {string}
     * @memberof ReturnOrderStatusError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ReturnOrderStatusError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ReturnOrderTimeWindowExpiredError
 */
export interface ReturnOrderTimeWindowExpiredError {
    /**
     * 
     * @type {string}
     * @memberof ReturnOrderTimeWindowExpiredError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ReturnOrderTimeWindowExpiredError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ReturnRequestInvalidOrderItemError
 */
export interface ReturnRequestInvalidOrderItemError {
    /**
     * 
     * @type {string}
     * @memberof ReturnRequestInvalidOrderItemError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ReturnRequestInvalidOrderItemError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ReturnRequestInvalidReasonError
 */
export interface ReturnRequestInvalidReasonError {
    /**
     * 
     * @type {string}
     * @memberof ReturnRequestInvalidReasonError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ReturnRequestInvalidReasonError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ReturnRequestInvalidResponseError
 */
export interface ReturnRequestInvalidResponseError {
    /**
     * 
     * @type {string}
     * @memberof ReturnRequestInvalidResponseError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ReturnRequestInvalidResponseError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ReturnRequestRefundEstimatesDTO
 */
export interface ReturnRequestRefundEstimatesDTO {
    /**
     * 
     * @type {Array<ItemReturnRequestDTO>}
     * @memberof ReturnRequestRefundEstimatesDTO
     */
    items: Array<ItemReturnRequestDTO>;
}
/**
 * 
 * @export
 * @interface ReturnableOrderItemData
 */
export interface ReturnableOrderItemData {
    /**
     * 
     * @type {string}
     * @memberof ReturnableOrderItemData
     */
    orderId: string;
    /**
     * 
     * @type {string}
     * @memberof ReturnableOrderItemData
     */
    orderDisplayId: string;
    /**
     * 
     * @type {string}
     * @memberof ReturnableOrderItemData
     */
    sfOrderId: string | null;
    /**
     * 
     * @type {string}
     * @memberof ReturnableOrderItemData
     */
    orderItemId: string;
    /**
     * 
     * @type {string}
     * @memberof ReturnableOrderItemData
     */
    orderItemDisplayId: string;
    /**
     * 
     * @type {string}
     * @memberof ReturnableOrderItemData
     */
    orderedDate: string;
    /**
     * 
     * @type {string}
     * @memberof ReturnableOrderItemData
     */
    programProductId: string;
    /**
     * 
     * @type {string}
     * @memberof ReturnableOrderItemData
     */
    productName: string;
    /**
     * 
     * @type {number}
     * @memberof ReturnableOrderItemData
     */
    price: number;
    /**
     * 
     * @type {number}
     * @memberof ReturnableOrderItemData
     */
    paidAmount: number;
    /**
     * 
     * @type {number}
     * @memberof ReturnableOrderItemData
     */
    taxFee: number;
    /**
     * 
     * @type {string}
     * @memberof ReturnableOrderItemData
     */
    size: string | null;
    /**
     * 
     * @type {string}
     * @memberof ReturnableOrderItemData
     */
    color: string | null;
    /**
     * 
     * @type {OrderStatus}
     * @memberof ReturnableOrderItemData
     */
    status: OrderStatus;
    /**
     * 
     * @type {OrderPaidStatus}
     * @memberof ReturnableOrderItemData
     */
    orderPaidStatus: OrderPaidStatus;
    /**
     * 
     * @type {number}
     * @memberof ReturnableOrderItemData
     */
    quantity: number;
    /**
     * 
     * @type {string}
     * @memberof ReturnableOrderItemData
     */
    expectedDate: string;
    /**
     * 
     * @type {string}
     * @memberof ReturnableOrderItemData
     */
    deliveredDate: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ReturnableOrderItemData
     */
    isCustom: boolean;
    /**
     * 
     * @type {string}
     * @memberof ReturnableOrderItemData
     */
    inventorySku: string;
    /**
     * 
     * @type {boolean}
     * @memberof ReturnableOrderItemData
     */
    isReturnable: boolean;
    /**
     * 
     * @type {object}
     * @memberof ReturnableOrderItemData
     */
    returnableDate: object;
    /**
     * 
     * @type {boolean}
     * @memberof ReturnableOrderItemData
     */
    isCancelable: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ReturnableOrderItemData
     */
    isMoqMet: boolean;
    /**
     * 
     * @type {object}
     * @memberof ReturnableOrderItemData
     */
    cancelledAt: object;
    /**
     * 
     * @type {boolean}
     * @memberof ReturnableOrderItemData
     */
    isCustomizableProduct: boolean;
    /**
     * 
     * @type {GetPrivateAccessMediaFileResponse}
     * @memberof ReturnableOrderItemData
     */
    thumbnail: GetPrivateAccessMediaFileResponse | null;
    /**
     * 
     * @type {number}
     * @memberof ReturnableOrderItemData
     */
    productMinimumOrderQuantity: number;
    /**
     * 
     * @type {number}
     * @memberof ReturnableOrderItemData
     */
    productReceivedOrderQuantity: number;
    /**
     * 
     * @type {string}
     * @memberof ReturnableOrderItemData
     */
    cancelledBy: string | null;
    /**
     * 
     * @type {CustomerForInvoice}
     * @memberof ReturnableOrderItemData
     */
    cancelledUser: CustomerForInvoice;
    /**
     * 
     * @type {string}
     * @memberof ReturnableOrderItemData
     */
    orderGroupId: string;
    /**
     * 
     * @type {number}
     * @memberof ReturnableOrderItemData
     */
    returnableQuantity: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ReturnableOrderItemData
     */
    availableReasons: Array<string>;
}
/**
 * 
 * @export
 * @interface ReturnableOrderItemsResponse
 */
export interface ReturnableOrderItemsResponse {
    /**
     * 
     * @type {Array<ReturnableOrderItemData>}
     * @memberof ReturnableOrderItemsResponse
     */
    data: Array<ReturnableOrderItemData>;
}
/**
 * 
 * @export
 * @interface RevenueForProgramForLast12MonthsResponse
 */
export interface RevenueForProgramForLast12MonthsResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof RevenueForProgramForLast12MonthsResponse
     */
    data: Array<string>;
}
/**
 * 
 * @export
 * @interface SFColoredProductAndProgramParentNotRelatedError
 */
export interface SFColoredProductAndProgramParentNotRelatedError {
    /**
     * 
     * @type {string}
     * @memberof SFColoredProductAndProgramParentNotRelatedError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof SFColoredProductAndProgramParentNotRelatedError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface SFColoredProductNotActiveError
 */
export interface SFColoredProductNotActiveError {
    /**
     * 
     * @type {string}
     * @memberof SFColoredProductNotActiveError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof SFColoredProductNotActiveError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface SFColoredProductNotFound
 */
export interface SFColoredProductNotFound {
    /**
     * 
     * @type {string}
     * @memberof SFColoredProductNotFound
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof SFColoredProductNotFound
     */
    type: string;
}
/**
 * 
 * @export
 * @interface SFParentProductDescriptionIsEmptyError
 */
export interface SFParentProductDescriptionIsEmptyError {
    /**
     * 
     * @type {string}
     * @memberof SFParentProductDescriptionIsEmptyError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof SFParentProductDescriptionIsEmptyError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface SFParentProductNotEligibleForArtworkCustomizationError
 */
export interface SFParentProductNotEligibleForArtworkCustomizationError {
    /**
     * 
     * @type {string}
     * @memberof SFParentProductNotEligibleForArtworkCustomizationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof SFParentProductNotEligibleForArtworkCustomizationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface SFParentProductNotEligibleForArtworkTextureCustomizationError
 */
export interface SFParentProductNotEligibleForArtworkTextureCustomizationError {
    /**
     * 
     * @type {string}
     * @memberof SFParentProductNotEligibleForArtworkTextureCustomizationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof SFParentProductNotEligibleForArtworkTextureCustomizationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface SFParentProductTexturesNotChosenError
 */
export interface SFParentProductTexturesNotChosenError {
    /**
     * 
     * @type {string}
     * @memberof SFParentProductTexturesNotChosenError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof SFParentProductTexturesNotChosenError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface SFProductNotFoundError
 */
export interface SFProductNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof SFProductNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof SFProductNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface SameAsOneOfPreviousPasswordsError
 */
export interface SameAsOneOfPreviousPasswordsError {
    /**
     * 
     * @type {string}
     * @memberof SameAsOneOfPreviousPasswordsError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof SameAsOneOfPreviousPasswordsError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface SaveAddressDto
 */
export interface SaveAddressDto {
    /**
     * 
     * @type {string}
     * @memberof SaveAddressDto
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof SaveAddressDto
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof SaveAddressDto
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof SaveAddressDto
     */
    phone: string;
    /**
     * 
     * @type {string}
     * @memberof SaveAddressDto
     */
    addressLine1: string;
    /**
     * 
     * @type {string}
     * @memberof SaveAddressDto
     */
    addressLine2: string;
    /**
     * 
     * @type {string}
     * @memberof SaveAddressDto
     */
    zipCode: string;
    /**
     * 
     * @type {string}
     * @memberof SaveAddressDto
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof SaveAddressDto
     */
    state: string;
    /**
     * 
     * @type {boolean}
     * @memberof SaveAddressDto
     */
    setAsDefault: boolean;
}
/**
 * 
 * @export
 * @interface SaveCardDto
 */
export interface SaveCardDto {
    /**
     * 
     * @type {string}
     * @memberof SaveCardDto
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SaveCardDto
     */
    transactionId: string;
    /**
     * 
     * @type {string}
     * @memberof SaveCardDto
     */
    cardMask: string;
    /**
     * 
     * @type {string}
     * @memberof SaveCardDto
     */
    cardType: string;
}
/**
 * 
 * @export
 * @interface SelectAtleastOnepaymentMethod
 */
export interface SelectAtleastOnepaymentMethod {
    /**
     * 
     * @type {string}
     * @memberof SelectAtleastOnepaymentMethod
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof SelectAtleastOnepaymentMethod
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ServiceError
 */
export interface ServiceError {
    /**
     * 
     * @type {string}
     * @memberof ServiceError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface SetUserPasswordDto
 */
export interface SetUserPasswordDto {
    /**
     * 
     * @type {string}
     * @memberof SetUserPasswordDto
     */
    userId: string;
    /**
     * 
     * @type {string}
     * @memberof SetUserPasswordDto
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof SetUserPasswordDto
     */
    password: string;
}
/**
 * 
 * @export
 * @interface ShippingCostNotFoundError
 */
export interface ShippingCostNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof ShippingCostNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingCostNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ShippingInfoNotFoundError
 */
export interface ShippingInfoNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof ShippingInfoNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingInfoNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ShippingLabelAlreadyCreatedForOrder
 */
export interface ShippingLabelAlreadyCreatedForOrder {
    /**
     * 
     * @type {string}
     * @memberof ShippingLabelAlreadyCreatedForOrder
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingLabelAlreadyCreatedForOrder
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ShippingLabelGenerationError
 */
export interface ShippingLabelGenerationError {
    /**
     * 
     * @type {string}
     * @memberof ShippingLabelGenerationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ShippingLabelGenerationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ShoulHaveAtleastOneActiveSFColorProductError
 */
export interface ShoulHaveAtleastOneActiveSFColorProductError {
    /**
     * 
     * @type {string}
     * @memberof ShoulHaveAtleastOneActiveSFColorProductError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ShoulHaveAtleastOneActiveSFColorProductError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ShouldHaveAtleastOneColorSelectedForParentProductPublishingError
 */
export interface ShouldHaveAtleastOneColorSelectedForParentProductPublishingError {
    /**
     * 
     * @type {string}
     * @memberof ShouldHaveAtleastOneColorSelectedForParentProductPublishingError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ShouldHaveAtleastOneColorSelectedForParentProductPublishingError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ShouldHaveAtleastOneImageForSelectedColorForParentProductPublishingError
 */
export interface ShouldHaveAtleastOneImageForSelectedColorForParentProductPublishingError {
    /**
     * 
     * @type {string}
     * @memberof ShouldHaveAtleastOneImageForSelectedColorForParentProductPublishingError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ShouldHaveAtleastOneImageForSelectedColorForParentProductPublishingError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ShouldHaveOne2DAssetError
 */
export interface ShouldHaveOne2DAssetError {
    /**
     * 
     * @type {string}
     * @memberof ShouldHaveOne2DAssetError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ShouldHaveOne2DAssetError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ShouldHavePriceSetForSelectedColorForParentProductPublishingError
 */
export interface ShouldHavePriceSetForSelectedColorForParentProductPublishingError {
    /**
     * 
     * @type {string}
     * @memberof ShouldHavePriceSetForSelectedColorForParentProductPublishingError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ShouldHavePriceSetForSelectedColorForParentProductPublishingError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface ShouldHaveSwatchColorsError
 */
export interface ShouldHaveSwatchColorsError {
    /**
     * 
     * @type {string}
     * @memberof ShouldHaveSwatchColorsError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ShouldHaveSwatchColorsError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface SignInDto
 */
export interface SignInDto {
    /**
     * 
     * @type {string}
     * @memberof SignInDto
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof SignInDto
     */
    password: string;
}
/**
 * 
 * @export
 * @interface SignInResponse
 */
export interface SignInResponse {
    /**
     * 
     * @type {string}
     * @memberof SignInResponse
     */
    accessToken: string;
    /**
     * 
     * @type {string}
     * @memberof SignInResponse
     */
    refreshToken: string;
    /**
     * 
     * @type {string}
     * @memberof SignInResponse
     */
    userId: string;
}
/**
 * 
 * @export
 * @interface SignUpResponse
 */
export interface SignUpResponse {
    /**
     * 
     * @type {string}
     * @memberof SignUpResponse
     */
    userId: string;
}
/**
 * 
 * @export
 * @interface SizeChartNotFoundError
 */
export interface SizeChartNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof SizeChartNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof SizeChartNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface SoldProductsCountForProgramResponse
 */
export interface SoldProductsCountForProgramResponse {
    /**
     * 
     * @type {number}
     * @memberof SoldProductsCountForProgramResponse
     */
    soldProgramProductsCount: number;
}
/**
 * 
 * @export
 * @interface SoldProductsCountResponse
 */
export interface SoldProductsCountResponse {
    /**
     * 
     * @type {number}
     * @memberof SoldProductsCountResponse
     */
    soldProductsCount: number;
}
/**
 * 
 * @export
 * @interface StoreCreditsNotAvailableToPlaceOrder
 */
export interface StoreCreditsNotAvailableToPlaceOrder {
    /**
     * 
     * @type {string}
     * @memberof StoreCreditsNotAvailableToPlaceOrder
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof StoreCreditsNotAvailableToPlaceOrder
     */
    type: string;
}
/**
 * 
 * @export
 * @interface StoreDomainAvailabilityReponse
 */
export interface StoreDomainAvailabilityReponse {
    /**
     * 
     * @type {boolean}
     * @memberof StoreDomainAvailabilityReponse
     */
    isAvailable: boolean;
}
/**
 * 
 * @export
 * @interface StoreDomainUrlNotAvailableError
 */
export interface StoreDomainUrlNotAvailableError {
    /**
     * 
     * @type {string}
     * @memberof StoreDomainUrlNotAvailableError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof StoreDomainUrlNotAvailableError
     */
    type: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum StoreStatus {
    Active = 'Active',
    Inactive = 'Inactive',
    Deactivated = 'Deactivated',
    Invited = 'Invited',
    Onboarding = 'Onboarding'
}

/**
 * 
 * @export
 * @interface SwapCategoriesDTO
 */
export interface SwapCategoriesDTO {
    /**
     * 
     * @type {Array<string>}
     * @memberof SwapCategoriesDTO
     */
    categories: Array<string>;
}
/**
 * 
 * @export
 * @interface SwapProgramParentProductsDTO
 */
export interface SwapProgramParentProductsDTO {
    /**
     * 
     * @type {Array<string>}
     * @memberof SwapProgramParentProductsDTO
     */
    programParentProductIds: Array<string>;
}
/**
 * 
 * @export
 * @interface SwapSystemProductsDTO
 */
export interface SwapSystemProductsDTO {
    /**
     * 
     * @type {Array<string>}
     * @memberof SwapSystemProductsDTO
     */
    skus: Array<string>;
}
/**
 * 
 * @export
 * @interface SwatchColorValidationError
 */
export interface SwatchColorValidationError {
    /**
     * 
     * @type {string}
     * @memberof SwatchColorValidationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof SwatchColorValidationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface SystemAdminUserExistsError
 */
export interface SystemAdminUserExistsError {
    /**
     * 
     * @type {string}
     * @memberof SystemAdminUserExistsError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof SystemAdminUserExistsError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface SystemProductNotPublishedError
 */
export interface SystemProductNotPublishedError {
    /**
     * 
     * @type {string}
     * @memberof SystemProductNotPublishedError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof SystemProductNotPublishedError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface SystemVariableNotFoundError
 */
export interface SystemVariableNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof SystemVariableNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof SystemVariableNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface TaxCalculationError
 */
export interface TaxCalculationError {
    /**
     * 
     * @type {string}
     * @memberof TaxCalculationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof TaxCalculationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface TechPackAlreadyExistsForTheProgramProductError
 */
export interface TechPackAlreadyExistsForTheProgramProductError {
    /**
     * 
     * @type {string}
     * @memberof TechPackAlreadyExistsForTheProgramProductError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof TechPackAlreadyExistsForTheProgramProductError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface TechPackNotFoundError
 */
export interface TechPackNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof TechPackNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof TechPackNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface TextureAndProductNotRelatedError
 */
export interface TextureAndProductNotRelatedError {
    /**
     * 
     * @type {string}
     * @memberof TextureAndProductNotRelatedError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof TextureAndProductNotRelatedError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface TextureExistsError
 */
export interface TextureExistsError {
    /**
     * 
     * @type {string}
     * @memberof TextureExistsError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof TextureExistsError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface TextureNotFoundError
 */
export interface TextureNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof TextureNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof TextureNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface TexturesMandatoryForTheArtworkType
 */
export interface TexturesMandatoryForTheArtworkType {
    /**
     * 
     * @type {string}
     * @memberof TexturesMandatoryForTheArtworkType
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof TexturesMandatoryForTheArtworkType
     */
    type: string;
}
/**
 * 
 * @export
 * @interface TexturesNotFoundForSFParentProductError
 */
export interface TexturesNotFoundForSFParentProductError {
    /**
     * 
     * @type {string}
     * @memberof TexturesNotFoundForSFParentProductError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof TexturesNotFoundForSFParentProductError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface TopRevenueProductsResponse
 */
export interface TopRevenueProductsResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof TopRevenueProductsResponse
     */
    data: Array<string>;
}
/**
 * 
 * @export
 * @interface TopRevenueProgramsResponse
 */
export interface TopRevenueProgramsResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof TopRevenueProgramsResponse
     */
    data: Array<string>;
}
/**
 * 
 * @export
 * @interface TransactionIdRequiredForPayment
 */
export interface TransactionIdRequiredForPayment {
    /**
     * 
     * @type {string}
     * @memberof TransactionIdRequiredForPayment
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionIdRequiredForPayment
     */
    type: string;
}
/**
 * 
 * @export
 * @interface UnauthorizedError
 */
export interface UnauthorizedError {
    /**
     * 
     * @type {string}
     * @memberof UnauthorizedError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof UnauthorizedError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface UniqueProductsSoldForLast12MonthsResponse
 */
export interface UniqueProductsSoldForLast12MonthsResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof UniqueProductsSoldForLast12MonthsResponse
     */
    data: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateAddressDto
 */
export interface UpdateAddressDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressDto
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressDto
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressDto
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressDto
     */
    phone: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressDto
     */
    addressLine1: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressDto
     */
    addressLine2: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressDto
     */
    zipCode: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressDto
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAddressDto
     */
    state: string;
}
/**
 * 
 * @export
 * @interface UpdateBulkShippingAddressDto
 */
export interface UpdateBulkShippingAddressDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateBulkShippingAddressDto
     */
    bulkShippingStreet: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBulkShippingAddressDto
     */
    bulkShippingCity: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBulkShippingAddressDto
     */
    bulkShippingState: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateBulkShippingAddressDto
     */
    bulkShippingZipCode: string;
}
/**
 * 
 * @export
 * @interface UpdateCartItemDTO
 */
export interface UpdateCartItemDTO {
    /**
     * 
     * @type {number}
     * @memberof UpdateCartItemDTO
     */
    quantity: number;
}
/**
 * 
 * @export
 * @interface UpdateCustomerProfileDto
 */
export interface UpdateCustomerProfileDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomerProfileDto
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomerProfileDto
     */
    lastName: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateCustomerProfileDto
     */
    canBuyProducts?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateCustomerProfileDto
     */
    deactivate?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateGlobalShippingDataDTO
 */
export interface UpdateGlobalShippingDataDTO {
    /**
     * 
     * @type {string}
     * @memberof UpdateGlobalShippingDataDTO
     */
    shipping: string;
}
/**
 * 
 * @export
 * @interface UpdateLogoPriceDTO
 */
export interface UpdateLogoPriceDTO {
    /**
     * 
     * @type {number}
     * @memberof UpdateLogoPriceDTO
     */
    logoPrice: number;
}
/**
 * 
 * @export
 * @interface UpdateMyProfileDto
 */
export interface UpdateMyProfileDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateMyProfileDto
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMyProfileDto
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMyProfileDto
     */
    phone?: string;
}
/**
 * 
 * @export
 * @interface UpdateProductArtworkTypeDTO
 */
export interface UpdateProductArtworkTypeDTO {
    /**
     * 
     * @type {string}
     * @memberof UpdateProductArtworkTypeDTO
     */
    artworkType: string;
}
/**
 * 
 * @export
 * @interface UpdateProductDescriptionDTO
 */
export interface UpdateProductDescriptionDTO {
    /**
     * 
     * @type {string}
     * @memberof UpdateProductDescriptionDTO
     */
    description: string;
}
/**
 * 
 * @export
 * @interface UpdateProductTextureDTO
 */
export interface UpdateProductTextureDTO {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateProductTextureDTO
     */
    textureIds: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateProgramColorsDto
 */
export interface UpdateProgramColorsDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateProgramColorsDto
     */
    primaryColor: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProgramColorsDto
     */
    secondaryColor: string;
}
/**
 * 
 * @export
 * @interface UpdateProgramParentProductDTO
 */
export interface UpdateProgramParentProductDTO {
    /**
     * 
     * @type {string}
     * @memberof UpdateProgramParentProductDTO
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProgramParentProductDTO
     */
    note?: string;
}
/**
 * 
 * @export
 * @interface UpdateProgramPaymentDto
 */
export interface UpdateProgramPaymentDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateProgramPaymentDto
     */
    bankAccountNumber: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProgramPaymentDto
     */
    bankRoutingNumber: string;
}
/**
 * 
 * @export
 * @interface UpdateProgramProductColorNotUniqueValidationError
 */
export interface UpdateProgramProductColorNotUniqueValidationError {
    /**
     * 
     * @type {string}
     * @memberof UpdateProgramProductColorNotUniqueValidationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProgramProductColorNotUniqueValidationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface UpdateProgramProductColorsDTO
 */
export interface UpdateProgramProductColorsDTO {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateProgramProductColorsDTO
     */
    chosenColorProductIds: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateProgramProductColorsDTO
     */
    deletedColorProductIds: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateProgramProductColorsValidationError
 */
export interface UpdateProgramProductColorsValidationError {
    /**
     * 
     * @type {string}
     * @memberof UpdateProgramProductColorsValidationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProgramProductColorsValidationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface UpdateProgramProductPriceDTO
 */
export interface UpdateProgramProductPriceDTO {
    /**
     * 
     * @type {string}
     * @memberof UpdateProgramProductPriceDTO
     */
    programProductId: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateProgramProductPriceDTO
     */
    price: number;
}
/**
 * 
 * @export
 * @interface UpdateSwatchColorsDto
 */
export interface UpdateSwatchColorsDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateSwatchColorsDto
     */
    firstColor: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSwatchColorsDto
     */
    secondColor?: string;
}
/**
 * 
 * @export
 * @interface UpdateSystemVariablesDTO
 */
export interface UpdateSystemVariablesDTO {
    /**
     * 
     * @type {number}
     * @memberof UpdateSystemVariablesDTO
     */
    cancel_order_window_time_hours?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateSystemVariablesDTO
     */
    return_order_window_time_days?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateSystemVariablesDTO
     */
    return_order_restocking_fee?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateSystemVariablesDTO
     */
    company_name?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSystemVariablesDTO
     */
    company_street?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSystemVariablesDTO
     */
    company_city?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSystemVariablesDTO
     */
    company_state?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSystemVariablesDTO
     */
    company_country?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSystemVariablesDTO
     */
    company_postal_code?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSystemVariablesDTO
     */
    company_phone?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSystemVariablesDTO
     */
    ups_carrier_code?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSystemVariablesDTO
     */
    ups_service_code?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSystemVariablesDTO
     */
    ups_package_code?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSystemVariablesDTO
     */
    ups_confirmation?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSystemVariablesDTO
     */
    tech_email?: string;
}
/**
 * 
 * @export
 * @interface UpdateUserProfileDto
 */
export interface UpdateUserProfileDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileDto
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserProfileDto
     */
    lastName: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateUserProfileDto
     */
    permissions?: Array<UpdateUserProfileDtoPermissionsEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum UpdateUserProfileDtoPermissionsEnum {
    Pc = 'PC',
    Pf = 'PF',
    Pp = 'PP',
    Ps = 'PS',
    Pa = 'PA',
    Sa = 'SA',
    So = 'SO',
    Sd = 'SD',
    Sr = 'SR',
    Sp = 'SP'
}

/**
 * 
 * @export
 * @interface UserAlreadyAssociatedWithOtherProgramError
 */
export interface UserAlreadyAssociatedWithOtherProgramError {
    /**
     * 
     * @type {string}
     * @memberof UserAlreadyAssociatedWithOtherProgramError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof UserAlreadyAssociatedWithOtherProgramError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface UserCannotAddMoreThanInventoryCount
 */
export interface UserCannotAddMoreThanInventoryCount {
    /**
     * 
     * @type {string}
     * @memberof UserCannotAddMoreThanInventoryCount
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof UserCannotAddMoreThanInventoryCount
     */
    type: string;
}
/**
 * 
 * @export
 * @interface UserDoesNotHavePrivilegesError
 */
export interface UserDoesNotHavePrivilegesError {
    /**
     * 
     * @type {string}
     * @memberof UserDoesNotHavePrivilegesError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof UserDoesNotHavePrivilegesError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface UserExistsWithEmailError
 */
export interface UserExistsWithEmailError {
    /**
     * 
     * @type {string}
     * @memberof UserExistsWithEmailError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof UserExistsWithEmailError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface UserIsNotEligibleForAccessError
 */
export interface UserIsNotEligibleForAccessError {
    /**
     * 
     * @type {string}
     * @memberof UserIsNotEligibleForAccessError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof UserIsNotEligibleForAccessError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface UserIsNotEligibleForAccessProgramError
 */
export interface UserIsNotEligibleForAccessProgramError {
    /**
     * 
     * @type {string}
     * @memberof UserIsNotEligibleForAccessProgramError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof UserIsNotEligibleForAccessProgramError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface UserIsNotEligibleForInvitationError
 */
export interface UserIsNotEligibleForInvitationError {
    /**
     * 
     * @type {string}
     * @memberof UserIsNotEligibleForInvitationError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof UserIsNotEligibleForInvitationError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface UserNotActiveError
 */
export interface UserNotActiveError {
    /**
     * 
     * @type {string}
     * @memberof UserNotActiveError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof UserNotActiveError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface UserNotFoundError
 */
export interface UserNotFoundError {
    /**
     * 
     * @type {string}
     * @memberof UserNotFoundError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof UserNotFoundError
     */
    type: string;
}
/**
 * 
 * @export
 * @interface UserNotSystemAdmin
 */
export interface UserNotSystemAdmin {
    /**
     * 
     * @type {string}
     * @memberof UserNotSystemAdmin
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof UserNotSystemAdmin
     */
    type: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum UserPermission {
    Pp = 'PP',
    Pc = 'PC',
    Ps = 'PS',
    Pf = 'PF',
    Pa = 'PA',
    Sd = 'SD',
    Sp = 'SP',
    Sr = 'SR',
    So = 'SO',
    Sa = 'SA'
}

/**
 * 
 * @export
 * @enum {string}
 */
export enum UserStatus {
    Active = 'Active',
    Deactivated = 'Deactivated',
    Inactive = 'Inactive',
    Invited = 'Invited',
    Requested = 'Requested'
}

/**
 * 
 * @export
 * @interface ValidateAddressDto
 */
export interface ValidateAddressDto {
    /**
     * 
     * @type {string}
     * @memberof ValidateAddressDto
     */
    streetAddress: string;
    /**
     * 
     * @type {string}
     * @memberof ValidateAddressDto
     */
    streetAddress2?: string;
    /**
     * 
     * @type {string}
     * @memberof ValidateAddressDto
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof ValidateAddressDto
     */
    state: string;
    /**
     * 
     * @type {string}
     * @memberof ValidateAddressDto
     */
    zipCode?: string;
}
/**
 * 
 * @export
 * @interface ValidatedAddressResponse
 */
export interface ValidatedAddressResponse {
    /**
     * 
     * @type {string}
     * @memberof ValidatedAddressResponse
     */
    streetAddress: string;
    /**
     * 
     * @type {string}
     * @memberof ValidatedAddressResponse
     */
    streetAddress2: string | null;
    /**
     * 
     * @type {string}
     * @memberof ValidatedAddressResponse
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof ValidatedAddressResponse
     */
    state: string;
    /**
     * 
     * @type {string}
     * @memberof ValidatedAddressResponse
     */
    zipCode: string;
}
/**
 * 
 * @export
 * @interface ValidationErrorOnDeleteMultipleProgramProductImages
 */
export interface ValidationErrorOnDeleteMultipleProgramProductImages {
    /**
     * 
     * @type {string}
     * @memberof ValidationErrorOnDeleteMultipleProgramProductImages
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof ValidationErrorOnDeleteMultipleProgramProductImages
     */
    type: string;
}
/**
 * 
 * @export
 * @interface WrongPasswordError
 */
export interface WrongPasswordError {
    /**
     * 
     * @type {string}
     * @memberof WrongPasswordError
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof WrongPasswordError
     */
    type: string;
}

/**
 * AddressApi - axios parameter creator
 * @export
 */
export const AddressApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} userId 
         * @param {SaveAddressDto} saveAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddress: async (userId: string, saveAddressDto: SaveAddressDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createAddress', 'userId', userId)
            // verify required parameter 'saveAddressDto' is not null or undefined
            assertParamExists('createAddress', 'saveAddressDto', saveAddressDto)
            const localVarPath = `/v1/user/{userId}/address`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveAddressDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} addressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAddress: async (userId: string, addressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteAddress', 'userId', userId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('deleteAddress', 'addressId', addressId)
            const localVarPath = `/v1/user/{userId}/address/{addressId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} addressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddress: async (userId: string, addressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getAddress', 'userId', userId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('getAddress', 'addressId', addressId)
            const localVarPath = `/v1/user/{userId}/address/{addressId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressList: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getAddressList', 'userId', userId)
            const localVarPath = `/v1/user/{userId}/addresses`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} addressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultAddress: async (userId: string, addressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('setDefaultAddress', 'userId', userId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('setDefaultAddress', 'addressId', addressId)
            const localVarPath = `/v1/user/{userId}/address/{addressId}/set-default`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} addressId 
         * @param {UpdateAddressDto} updateAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAddress: async (userId: string, addressId: string, updateAddressDto: UpdateAddressDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateAddress', 'userId', userId)
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('updateAddress', 'addressId', addressId)
            // verify required parameter 'updateAddressDto' is not null or undefined
            assertParamExists('updateAddress', 'updateAddressDto', updateAddressDto)
            const localVarPath = `/v1/user/{userId}/address/{addressId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAddressDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ValidateAddressDto} validateAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAddress: async (validateAddressDto: ValidateAddressDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'validateAddressDto' is not null or undefined
            assertParamExists('validateAddress', 'validateAddressDto', validateAddressDto)
            const localVarPath = `/v1/user/validate-address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validateAddressDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressApi - functional programming interface
 * @export
 */
export const AddressApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} userId 
         * @param {SaveAddressDto} saveAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAddress(userId: string, saveAddressDto: SaveAddressDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAddress(userId, saveAddressDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} addressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAddress(userId: string, addressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAddress(userId, addressId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} addressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddress(userId: string, addressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddress(userId, addressId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddressList(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAddressListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressList(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} addressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDefaultAddress(userId: string, addressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDefaultAddress(userId, addressId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} addressId 
         * @param {UpdateAddressDto} updateAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAddress(userId: string, addressId: string, updateAddressDto: UpdateAddressDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAddress(userId, addressId, updateAddressDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ValidateAddressDto} validateAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateAddress(validateAddressDto: ValidateAddressDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidatedAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateAddress(validateAddressDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AddressApi - factory interface
 * @export
 */
export const AddressApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressApiFp(configuration)
    return {
        /**
         * 
         * @param {string} userId 
         * @param {SaveAddressDto} saveAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAddress(userId: string, saveAddressDto: SaveAddressDto, options?: any): AxiosPromise<void> {
            return localVarFp.createAddress(userId, saveAddressDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} addressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAddress(userId: string, addressId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAddress(userId, addressId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} addressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddress(userId: string, addressId: string, options?: any): AxiosPromise<GetAddressResponse> {
            return localVarFp.getAddress(userId, addressId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressList(userId: string, options?: any): AxiosPromise<GetAddressListResponse> {
            return localVarFp.getAddressList(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} addressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultAddress(userId: string, addressId: string, options?: any): AxiosPromise<void> {
            return localVarFp.setDefaultAddress(userId, addressId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} addressId 
         * @param {UpdateAddressDto} updateAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAddress(userId: string, addressId: string, updateAddressDto: UpdateAddressDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateAddress(userId, addressId, updateAddressDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ValidateAddressDto} validateAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAddress(validateAddressDto: ValidateAddressDto, options?: any): AxiosPromise<ValidatedAddressResponse> {
            return localVarFp.validateAddress(validateAddressDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressApi - object-oriented interface
 * @export
 * @class AddressApi
 * @extends {BaseAPI}
 */
export class AddressApi extends BaseAPI {
    /**
     * 
     * @param {string} userId 
     * @param {SaveAddressDto} saveAddressDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public createAddress(userId: string, saveAddressDto: SaveAddressDto, options?: any) {
        return AddressApiFp(this.configuration).createAddress(userId, saveAddressDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {string} addressId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public deleteAddress(userId: string, addressId: string, options?: any) {
        return AddressApiFp(this.configuration).deleteAddress(userId, addressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {string} addressId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public getAddress(userId: string, addressId: string, options?: any) {
        return AddressApiFp(this.configuration).getAddress(userId, addressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public getAddressList(userId: string, options?: any) {
        return AddressApiFp(this.configuration).getAddressList(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {string} addressId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public setDefaultAddress(userId: string, addressId: string, options?: any) {
        return AddressApiFp(this.configuration).setDefaultAddress(userId, addressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {string} addressId 
     * @param {UpdateAddressDto} updateAddressDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public updateAddress(userId: string, addressId: string, updateAddressDto: UpdateAddressDto, options?: any) {
        return AddressApiFp(this.configuration).updateAddress(userId, addressId, updateAddressDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ValidateAddressDto} validateAddressDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public validateAddress(validateAddressDto: ValidateAddressDto, options?: any) {
        return AddressApiFp(this.configuration).validateAddress(validateAddressDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AddCustomerDto} addCustomerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCustomer: async (addCustomerDto: AddCustomerDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'addCustomerDto' is not null or undefined
            assertParamExists('addCustomer', 'addCustomerDto', addCustomerDto)
            const localVarPath = `/v1/auth/customer/add-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addCustomerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ForgotPasswordDto} forgotPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminForgotPassword: async (forgotPasswordDto: ForgotPasswordDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgotPasswordDto' is not null or undefined
            assertParamExists('adminForgotPassword', 'forgotPasswordDto', forgotPasswordDto)
            const localVarPath = `/v1/auth/admin/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgotPasswordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignInDto} signInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminSignIn: async (signInDto: SignInDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'signInDto' is not null or undefined
            assertParamExists('adminSignIn', 'signInDto', signInDto)
            const localVarPath = `/v1/auth/admin/sign-in`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} [file] 
         * @param {string} [programId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUploadCustomers: async (file?: any, programId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth/customer/bulk-upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (programId !== undefined) { 
                localVarFormParams.append('programId', programId as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword: async (changePasswordDto: ChangePasswordDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'changePasswordDto' is not null or undefined
            assertParamExists('changePassword', 'changePasswordDto', changePasswordDto)
            const localVarPath = `/v1/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changePasswordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CustomerForgotPasswordDto} customerForgotPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerForgotPassword: async (customerForgotPasswordDto: CustomerForgotPasswordDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerForgotPasswordDto' is not null or undefined
            assertParamExists('customerForgotPassword', 'customerForgotPasswordDto', customerForgotPasswordDto)
            const localVarPath = `/v1/auth/customer/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerForgotPasswordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CustomerSignInDto} customerSignInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerSignIn: async (customerSignInDto: CustomerSignInDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerSignInDto' is not null or undefined
            assertParamExists('customerSignIn', 'customerSignInDto', customerSignInDto)
            const localVarPath = `/v1/auth/customer/sign-in`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerSignInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CustomerSignUpDto} customerSignUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerSignUp: async (customerSignUpDto: CustomerSignUpDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerSignUpDto' is not null or undefined
            assertParamExists('customerSignUp', 'customerSignUpDto', customerSignUpDto)
            const localVarPath = `/v1/auth/customer/sign-up`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerSignUpDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InviteRebelAdminDto} inviteRebelAdminDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteAdmin: async (inviteRebelAdminDto: InviteRebelAdminDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inviteRebelAdminDto' is not null or undefined
            assertParamExists('inviteAdmin', 'inviteRebelAdminDto', inviteRebelAdminDto)
            const localVarPath = `/v1/auth/admin/invite-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteRebelAdminDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InviteProgramUserDto} inviteProgramUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteProgramAdmin: async (inviteProgramUserDto: InviteProgramUserDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inviteProgramUserDto' is not null or undefined
            assertParamExists('inviteProgramAdmin', 'inviteProgramUserDto', inviteProgramUserDto)
            const localVarPath = `/v1/auth/program/invite-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteProgramUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ProgramOwnerOnboardDto} programOwnerOnboardDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        onboardProgramOwner: async (programOwnerOnboardDto: ProgramOwnerOnboardDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programOwnerOnboardDto' is not null or undefined
            assertParamExists('onboardProgramOwner', 'programOwnerOnboardDto', programOwnerOnboardDto)
            const localVarPath = `/v1/auth/program/onboard-owner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(programOwnerOnboardDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ForgotPasswordDto} forgotPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programForgotPassword: async (forgotPasswordDto: ForgotPasswordDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgotPasswordDto' is not null or undefined
            assertParamExists('programForgotPassword', 'forgotPasswordDto', forgotPasswordDto)
            const localVarPath = `/v1/auth/program/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgotPasswordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SignInDto} signInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programSignIn: async (signInDto: SignInDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'signInDto' is not null or undefined
            assertParamExists('programSignIn', 'signInDto', signInDto)
            const localVarPath = `/v1/auth/program/sign-in`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signInDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RefreshTokenDto} refreshTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (refreshTokenDto: RefreshTokenDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenDto' is not null or undefined
            assertParamExists('refreshToken', 'refreshTokenDto', refreshTokenDto)
            const localVarPath = `/v1/auth/refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetUserPasswordDto} setUserPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserPassword: async (setUserPasswordDto: SetUserPasswordDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'setUserPasswordDto' is not null or undefined
            assertParamExists('setUserPassword', 'setUserPasswordDto', setUserPasswordDto)
            const localVarPath = `/v1/auth/set-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setUserPasswordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AddCustomerDto} addCustomerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCustomer(addCustomerDto: AddCustomerDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCustomer(addCustomerDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ForgotPasswordDto} forgotPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminForgotPassword(forgotPasswordDto: ForgotPasswordDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminForgotPassword(forgotPasswordDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SignInDto} signInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminSignIn(signInDto: SignInDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignInResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminSignIn(signInDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {any} [file] 
         * @param {string} [programId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkUploadCustomers(file?: any, programId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomerBulkUploadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkUploadCustomers(file, programId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePassword(changePasswordDto: ChangePasswordDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePassword(changePasswordDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CustomerForgotPasswordDto} customerForgotPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerForgotPassword(customerForgotPasswordDto: CustomerForgotPasswordDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerForgotPassword(customerForgotPasswordDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CustomerSignInDto} customerSignInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerSignIn(customerSignInDto: CustomerSignInDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignInResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerSignIn(customerSignInDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CustomerSignUpDto} customerSignUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerSignUp(customerSignUpDto: CustomerSignUpDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignUpResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerSignUp(customerSignUpDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {InviteRebelAdminDto} inviteRebelAdminDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteAdmin(inviteRebelAdminDto: InviteRebelAdminDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignUpResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteAdmin(inviteRebelAdminDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {InviteProgramUserDto} inviteProgramUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteProgramAdmin(inviteProgramUserDto: InviteProgramUserDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignUpResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteProgramAdmin(inviteProgramUserDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ProgramOwnerOnboardDto} programOwnerOnboardDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async onboardProgramOwner(programOwnerOnboardDto: ProgramOwnerOnboardDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.onboardProgramOwner(programOwnerOnboardDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ForgotPasswordDto} forgotPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async programForgotPassword(forgotPasswordDto: ForgotPasswordDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.programForgotPassword(forgotPasswordDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SignInDto} signInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async programSignIn(signInDto: SignInDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignInResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.programSignIn(signInDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RefreshTokenDto} refreshTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(refreshTokenDto: RefreshTokenDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignInResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(refreshTokenDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SetUserPasswordDto} setUserPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setUserPassword(setUserPasswordDto: SetUserPasswordDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setUserPassword(setUserPasswordDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {AddCustomerDto} addCustomerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCustomer(addCustomerDto: AddCustomerDto, options?: any): AxiosPromise<void> {
            return localVarFp.addCustomer(addCustomerDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ForgotPasswordDto} forgotPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminForgotPassword(forgotPasswordDto: ForgotPasswordDto, options?: any): AxiosPromise<void> {
            return localVarFp.adminForgotPassword(forgotPasswordDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignInDto} signInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminSignIn(signInDto: SignInDto, options?: any): AxiosPromise<SignInResponse> {
            return localVarFp.adminSignIn(signInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {any} [file] 
         * @param {string} [programId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUploadCustomers(file?: any, programId?: string, options?: any): AxiosPromise<GetCustomerBulkUploadResponse> {
            return localVarFp.bulkUploadCustomers(file, programId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ChangePasswordDto} changePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(changePasswordDto: ChangePasswordDto, options?: any): AxiosPromise<void> {
            return localVarFp.changePassword(changePasswordDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CustomerForgotPasswordDto} customerForgotPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerForgotPassword(customerForgotPasswordDto: CustomerForgotPasswordDto, options?: any): AxiosPromise<void> {
            return localVarFp.customerForgotPassword(customerForgotPasswordDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CustomerSignInDto} customerSignInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerSignIn(customerSignInDto: CustomerSignInDto, options?: any): AxiosPromise<SignInResponse> {
            return localVarFp.customerSignIn(customerSignInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CustomerSignUpDto} customerSignUpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerSignUp(customerSignUpDto: CustomerSignUpDto, options?: any): AxiosPromise<SignUpResponse> {
            return localVarFp.customerSignUp(customerSignUpDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InviteRebelAdminDto} inviteRebelAdminDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteAdmin(inviteRebelAdminDto: InviteRebelAdminDto, options?: any): AxiosPromise<SignUpResponse> {
            return localVarFp.inviteAdmin(inviteRebelAdminDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InviteProgramUserDto} inviteProgramUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteProgramAdmin(inviteProgramUserDto: InviteProgramUserDto, options?: any): AxiosPromise<SignUpResponse> {
            return localVarFp.inviteProgramAdmin(inviteProgramUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ProgramOwnerOnboardDto} programOwnerOnboardDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        onboardProgramOwner(programOwnerOnboardDto: ProgramOwnerOnboardDto, options?: any): AxiosPromise<void> {
            return localVarFp.onboardProgramOwner(programOwnerOnboardDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ForgotPasswordDto} forgotPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programForgotPassword(forgotPasswordDto: ForgotPasswordDto, options?: any): AxiosPromise<void> {
            return localVarFp.programForgotPassword(forgotPasswordDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SignInDto} signInDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programSignIn(signInDto: SignInDto, options?: any): AxiosPromise<SignInResponse> {
            return localVarFp.programSignIn(signInDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RefreshTokenDto} refreshTokenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(refreshTokenDto: RefreshTokenDto, options?: any): AxiosPromise<SignInResponse> {
            return localVarFp.refreshToken(refreshTokenDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SetUserPasswordDto} setUserPasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setUserPassword(setUserPasswordDto: SetUserPasswordDto, options?: any): AxiosPromise<void> {
            return localVarFp.setUserPassword(setUserPasswordDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {AddCustomerDto} addCustomerDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public addCustomer(addCustomerDto: AddCustomerDto, options?: any) {
        return AuthApiFp(this.configuration).addCustomer(addCustomerDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ForgotPasswordDto} forgotPasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public adminForgotPassword(forgotPasswordDto: ForgotPasswordDto, options?: any) {
        return AuthApiFp(this.configuration).adminForgotPassword(forgotPasswordDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignInDto} signInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public adminSignIn(signInDto: SignInDto, options?: any) {
        return AuthApiFp(this.configuration).adminSignIn(signInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {any} [file] 
     * @param {string} [programId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public bulkUploadCustomers(file?: any, programId?: string, options?: any) {
        return AuthApiFp(this.configuration).bulkUploadCustomers(file, programId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ChangePasswordDto} changePasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public changePassword(changePasswordDto: ChangePasswordDto, options?: any) {
        return AuthApiFp(this.configuration).changePassword(changePasswordDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CustomerForgotPasswordDto} customerForgotPasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public customerForgotPassword(customerForgotPasswordDto: CustomerForgotPasswordDto, options?: any) {
        return AuthApiFp(this.configuration).customerForgotPassword(customerForgotPasswordDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CustomerSignInDto} customerSignInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public customerSignIn(customerSignInDto: CustomerSignInDto, options?: any) {
        return AuthApiFp(this.configuration).customerSignIn(customerSignInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CustomerSignUpDto} customerSignUpDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public customerSignUp(customerSignUpDto: CustomerSignUpDto, options?: any) {
        return AuthApiFp(this.configuration).customerSignUp(customerSignUpDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InviteRebelAdminDto} inviteRebelAdminDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public inviteAdmin(inviteRebelAdminDto: InviteRebelAdminDto, options?: any) {
        return AuthApiFp(this.configuration).inviteAdmin(inviteRebelAdminDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InviteProgramUserDto} inviteProgramUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public inviteProgramAdmin(inviteProgramUserDto: InviteProgramUserDto, options?: any) {
        return AuthApiFp(this.configuration).inviteProgramAdmin(inviteProgramUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ProgramOwnerOnboardDto} programOwnerOnboardDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public onboardProgramOwner(programOwnerOnboardDto: ProgramOwnerOnboardDto, options?: any) {
        return AuthApiFp(this.configuration).onboardProgramOwner(programOwnerOnboardDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ForgotPasswordDto} forgotPasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public programForgotPassword(forgotPasswordDto: ForgotPasswordDto, options?: any) {
        return AuthApiFp(this.configuration).programForgotPassword(forgotPasswordDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SignInDto} signInDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public programSignIn(signInDto: SignInDto, options?: any) {
        return AuthApiFp(this.configuration).programSignIn(signInDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RefreshTokenDto} refreshTokenDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public refreshToken(refreshTokenDto: RefreshTokenDto, options?: any) {
        return AuthApiFp(this.configuration).refreshToken(refreshTokenDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SetUserPasswordDto} setUserPasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public setUserPassword(setUserPasswordDto: SetUserPasswordDto, options?: any) {
        return AuthApiFp(this.configuration).setUserPassword(setUserPasswordDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomerCardApi - axios parameter creator
 * @export
 */
export const CustomerCardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} userId 
         * @param {SaveCardDto} saveCardDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerCard: async (userId: string, saveCardDto: SaveCardDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('createCustomerCard', 'userId', userId)
            // verify required parameter 'saveCardDto' is not null or undefined
            assertParamExists('createCustomerCard', 'saveCardDto', saveCardDto)
            const localVarPath = `/v1/user/{userId}/card`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveCardDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomerCard: async (userId: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteCustomerCard', 'userId', userId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCustomerCard', 'id', id)
            const localVarPath = `/v1/user/{userId}/card/{id}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAllCustomerCards: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('fetchAllCustomerCards', 'userId', userId)
            const localVarPath = `/v1/user/{userId}/cards`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} cardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultCard: async (userId: string, cardId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('setDefaultCard', 'userId', userId)
            // verify required parameter 'cardId' is not null or undefined
            assertParamExists('setDefaultCard', 'cardId', cardId)
            const localVarPath = `/v1/user/{userId}/card/{cardId}/set-default`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"cardId"}}`, encodeURIComponent(String(cardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerCardApi - functional programming interface
 * @export
 */
export const CustomerCardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomerCardApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} userId 
         * @param {SaveCardDto} saveCardDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomerCard(userId: string, saveCardDto: SaveCardDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomerCard(userId, saveCardDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomerCard(userId: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomerCard(userId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchAllCustomerCards(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCardsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchAllCustomerCards(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} cardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDefaultCard(userId: string, cardId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDefaultCard(userId, cardId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomerCardApi - factory interface
 * @export
 */
export const CustomerCardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomerCardApiFp(configuration)
    return {
        /**
         * 
         * @param {string} userId 
         * @param {SaveCardDto} saveCardDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomerCard(userId: string, saveCardDto: SaveCardDto, options?: any): AxiosPromise<void> {
            return localVarFp.createCustomerCard(userId, saveCardDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomerCard(userId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCustomerCard(userId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAllCustomerCards(userId: string, options?: any): AxiosPromise<GetCardsListResponse> {
            return localVarFp.fetchAllCustomerCards(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} cardId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultCard(userId: string, cardId: string, options?: any): AxiosPromise<void> {
            return localVarFp.setDefaultCard(userId, cardId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomerCardApi - object-oriented interface
 * @export
 * @class CustomerCardApi
 * @extends {BaseAPI}
 */
export class CustomerCardApi extends BaseAPI {
    /**
     * 
     * @param {string} userId 
     * @param {SaveCardDto} saveCardDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerCardApi
     */
    public createCustomerCard(userId: string, saveCardDto: SaveCardDto, options?: any) {
        return CustomerCardApiFp(this.configuration).createCustomerCard(userId, saveCardDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerCardApi
     */
    public deleteCustomerCard(userId: string, id: string, options?: any) {
        return CustomerCardApiFp(this.configuration).deleteCustomerCard(userId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerCardApi
     */
    public fetchAllCustomerCards(userId: string, options?: any) {
        return CustomerCardApiFp(this.configuration).fetchAllCustomerCards(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {string} cardId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerCardApi
     */
    public setDefaultCard(userId: string, cardId: string, options?: any) {
        return CustomerCardApiFp(this.configuration).setDefaultCard(userId, cardId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DashboardApi - axios parameter creator
 * @export
 */
export const DashboardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveProductsForAllProgramsCount: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/report/active-products-count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveProgramProductsCount: async (programId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getActiveProgramProductsCount', 'programId', programId)
            const localVarPath = `/v1/report/{programId}/report/active-products-count`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveProgramsCount: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/report/active-programs-count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveUsersCount: async (programId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getActiveUsersCount', 'programId', programId)
            const localVarPath = `/v1/report/{programId}/active-users-count`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} isMtd 
         * @param {boolean} isYtd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUniqueProductSoldCount: async (isMtd: boolean, isYtd: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'isMtd' is not null or undefined
            assertParamExists('getAllUniqueProductSoldCount', 'isMtd', isMtd)
            // verify required parameter 'isYtd' is not null or undefined
            assertParamExists('getAllUniqueProductSoldCount', 'isYtd', isYtd)
            const localVarPath = `/v1/report/unique-products-sold-count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isMtd !== undefined) {
                localVarQueryParameter['isMtd'] = isMtd;
            }

            if (isYtd !== undefined) {
                localVarQueryParameter['isYtd'] = isYtd;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfitForProgram: async (programId: string, isMtd?: boolean, isYtd?: boolean, fromDate?: any, toDate?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getProfitForProgram', 'programId', programId)
            const localVarPath = `/v1/report/{programId}/total-profit`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isMtd !== undefined) {
                localVarQueryParameter['isMtd'] = isMtd;
            }

            if (isYtd !== undefined) {
                localVarQueryParameter['isYtd'] = isYtd;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfitForProgramForLast12Months: async (programId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getProfitForProgramForLast12Months', 'programId', programId)
            const localVarPath = `/v1/report/{programId}/total-profit-12-months`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRevenueForProgram: async (programId: string, isMtd?: boolean, isYtd?: boolean, fromDate?: any, toDate?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getRevenueForProgram', 'programId', programId)
            const localVarPath = `/v1/report/{programId}/total-revenue`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isMtd !== undefined) {
                localVarQueryParameter['isMtd'] = isMtd;
            }

            if (isYtd !== undefined) {
                localVarQueryParameter['isYtd'] = isYtd;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRevenueForProgramForLast12Months: async (programId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getRevenueForProgramForLast12Months', 'programId', programId)
            const localVarPath = `/v1/report/{programId}/total-revenue-12-months`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopRevenueProducts: async (limit?: number, isMtd?: boolean, isYtd?: boolean, fromDate?: any, toDate?: any, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/report/top-revenue-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (isMtd !== undefined) {
                localVarQueryParameter['isMtd'] = isMtd;
            }

            if (isYtd !== undefined) {
                localVarQueryParameter['isYtd'] = isYtd;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopRevenuePrograms: async (limit?: number, isMtd?: boolean, isYtd?: boolean, fromDate?: any, toDate?: any, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/report/top-revenue-programs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (isMtd !== undefined) {
                localVarQueryParameter['isMtd'] = isMtd;
            }

            if (isYtd !== undefined) {
                localVarQueryParameter['isYtd'] = isYtd;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniqueProductsSoldForLast12Months: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/report/unique-products-sold-count-12-months`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniqueProgramProductSoldCount: async (programId: string, isMtd?: boolean, isYtd?: boolean, fromDate?: any, toDate?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getUniqueProgramProductSoldCount', 'programId', programId)
            const localVarPath = `/v1/report/{programId}/unique-products-sold-count`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (isMtd !== undefined) {
                localVarQueryParameter['isMtd'] = isMtd;
            }

            if (isYtd !== undefined) {
                localVarQueryParameter['isYtd'] = isYtd;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniqueProgramProductsSoldForLast12Months: async (programId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getUniqueProgramProductsSoldForLast12Months', 'programId', programId)
            const localVarPath = `/v1/report/{programId}/unique-products-sold-count-12-months`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardApi - functional programming interface
 * @export
 */
export const DashboardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DashboardApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveProductsForAllProgramsCount(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActiveProductsCountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveProductsForAllProgramsCount(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveProgramProductsCount(programId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActiveProductsCountForProgramResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveProgramProductsCount(programId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveProgramsCount(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActiveProgramsCountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveProgramsCount(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveUsersCount(programId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActiveUsersCountForProgramResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveUsersCount(programId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} isMtd 
         * @param {boolean} isYtd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUniqueProductSoldCount(isMtd: boolean, isYtd: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SoldProductsCountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUniqueProductSoldCount(isMtd, isYtd, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfitForProgram(programId: string, isMtd?: boolean, isYtd?: boolean, fromDate?: any, toDate?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgramProfitResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfitForProgram(programId, isMtd, isYtd, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfitForProgramForLast12Months(programId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfitForProgramForLast12MonthsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfitForProgramForLast12Months(programId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRevenueForProgram(programId: string, isMtd?: boolean, isYtd?: boolean, fromDate?: any, toDate?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgramRevenueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRevenueForProgram(programId, isMtd, isYtd, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRevenueForProgramForLast12Months(programId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RevenueForProgramForLast12MonthsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRevenueForProgramForLast12Months(programId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopRevenueProducts(limit?: number, isMtd?: boolean, isYtd?: boolean, fromDate?: any, toDate?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopRevenueProductsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopRevenueProducts(limit, isMtd, isYtd, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTopRevenuePrograms(limit?: number, isMtd?: boolean, isYtd?: boolean, fromDate?: any, toDate?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopRevenueProgramsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTopRevenuePrograms(limit, isMtd, isYtd, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniqueProductsSoldForLast12Months(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UniqueProductsSoldForLast12MonthsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniqueProductsSoldForLast12Months(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniqueProgramProductSoldCount(programId: string, isMtd?: boolean, isYtd?: boolean, fromDate?: any, toDate?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SoldProductsCountForProgramResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniqueProgramProductSoldCount(programId, isMtd, isYtd, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUniqueProgramProductsSoldForLast12Months(programId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UniqueProductsSoldForLast12MonthsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUniqueProgramProductsSoldForLast12Months(programId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DashboardApi - factory interface
 * @export
 */
export const DashboardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DashboardApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveProductsForAllProgramsCount(options?: any): AxiosPromise<ActiveProductsCountResponse> {
            return localVarFp.getActiveProductsForAllProgramsCount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveProgramProductsCount(programId: string, options?: any): AxiosPromise<ActiveProductsCountForProgramResponse> {
            return localVarFp.getActiveProgramProductsCount(programId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveProgramsCount(options?: any): AxiosPromise<ActiveProgramsCountResponse> {
            return localVarFp.getActiveProgramsCount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveUsersCount(programId: string, options?: any): AxiosPromise<ActiveUsersCountForProgramResponse> {
            return localVarFp.getActiveUsersCount(programId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} isMtd 
         * @param {boolean} isYtd 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUniqueProductSoldCount(isMtd: boolean, isYtd: boolean, options?: any): AxiosPromise<SoldProductsCountResponse> {
            return localVarFp.getAllUniqueProductSoldCount(isMtd, isYtd, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfitForProgram(programId: string, isMtd?: boolean, isYtd?: boolean, fromDate?: any, toDate?: any, options?: any): AxiosPromise<ProgramProfitResponse> {
            return localVarFp.getProfitForProgram(programId, isMtd, isYtd, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfitForProgramForLast12Months(programId: string, options?: any): AxiosPromise<ProfitForProgramForLast12MonthsResponse> {
            return localVarFp.getProfitForProgramForLast12Months(programId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRevenueForProgram(programId: string, isMtd?: boolean, isYtd?: boolean, fromDate?: any, toDate?: any, options?: any): AxiosPromise<ProgramRevenueResponse> {
            return localVarFp.getRevenueForProgram(programId, isMtd, isYtd, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRevenueForProgramForLast12Months(programId: string, options?: any): AxiosPromise<RevenueForProgramForLast12MonthsResponse> {
            return localVarFp.getRevenueForProgramForLast12Months(programId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopRevenueProducts(limit?: number, isMtd?: boolean, isYtd?: boolean, fromDate?: any, toDate?: any, options?: any): AxiosPromise<TopRevenueProductsResponse> {
            return localVarFp.getTopRevenueProducts(limit, isMtd, isYtd, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopRevenuePrograms(limit?: number, isMtd?: boolean, isYtd?: boolean, fromDate?: any, toDate?: any, options?: any): AxiosPromise<TopRevenueProgramsResponse> {
            return localVarFp.getTopRevenuePrograms(limit, isMtd, isYtd, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniqueProductsSoldForLast12Months(options?: any): AxiosPromise<UniqueProductsSoldForLast12MonthsResponse> {
            return localVarFp.getUniqueProductsSoldForLast12Months(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniqueProgramProductSoldCount(programId: string, isMtd?: boolean, isYtd?: boolean, fromDate?: any, toDate?: any, options?: any): AxiosPromise<SoldProductsCountForProgramResponse> {
            return localVarFp.getUniqueProgramProductSoldCount(programId, isMtd, isYtd, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUniqueProgramProductsSoldForLast12Months(programId: string, options?: any): AxiosPromise<UniqueProductsSoldForLast12MonthsResponse> {
            return localVarFp.getUniqueProgramProductsSoldForLast12Months(programId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DashboardApi - object-oriented interface
 * @export
 * @class DashboardApi
 * @extends {BaseAPI}
 */
export class DashboardApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getActiveProductsForAllProgramsCount(options?: any) {
        return DashboardApiFp(this.configuration).getActiveProductsForAllProgramsCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getActiveProgramProductsCount(programId: string, options?: any) {
        return DashboardApiFp(this.configuration).getActiveProgramProductsCount(programId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getActiveProgramsCount(options?: any) {
        return DashboardApiFp(this.configuration).getActiveProgramsCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getActiveUsersCount(programId: string, options?: any) {
        return DashboardApiFp(this.configuration).getActiveUsersCount(programId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} isMtd 
     * @param {boolean} isYtd 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getAllUniqueProductSoldCount(isMtd: boolean, isYtd: boolean, options?: any) {
        return DashboardApiFp(this.configuration).getAllUniqueProductSoldCount(isMtd, isYtd, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {boolean} [isMtd] 
     * @param {boolean} [isYtd] 
     * @param {any} [fromDate] 
     * @param {any} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getProfitForProgram(programId: string, isMtd?: boolean, isYtd?: boolean, fromDate?: any, toDate?: any, options?: any) {
        return DashboardApiFp(this.configuration).getProfitForProgram(programId, isMtd, isYtd, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getProfitForProgramForLast12Months(programId: string, options?: any) {
        return DashboardApiFp(this.configuration).getProfitForProgramForLast12Months(programId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {boolean} [isMtd] 
     * @param {boolean} [isYtd] 
     * @param {any} [fromDate] 
     * @param {any} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getRevenueForProgram(programId: string, isMtd?: boolean, isYtd?: boolean, fromDate?: any, toDate?: any, options?: any) {
        return DashboardApiFp(this.configuration).getRevenueForProgram(programId, isMtd, isYtd, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getRevenueForProgramForLast12Months(programId: string, options?: any) {
        return DashboardApiFp(this.configuration).getRevenueForProgramForLast12Months(programId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {boolean} [isMtd] 
     * @param {boolean} [isYtd] 
     * @param {any} [fromDate] 
     * @param {any} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getTopRevenueProducts(limit?: number, isMtd?: boolean, isYtd?: boolean, fromDate?: any, toDate?: any, options?: any) {
        return DashboardApiFp(this.configuration).getTopRevenueProducts(limit, isMtd, isYtd, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {boolean} [isMtd] 
     * @param {boolean} [isYtd] 
     * @param {any} [fromDate] 
     * @param {any} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getTopRevenuePrograms(limit?: number, isMtd?: boolean, isYtd?: boolean, fromDate?: any, toDate?: any, options?: any) {
        return DashboardApiFp(this.configuration).getTopRevenuePrograms(limit, isMtd, isYtd, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getUniqueProductsSoldForLast12Months(options?: any) {
        return DashboardApiFp(this.configuration).getUniqueProductsSoldForLast12Months(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {boolean} [isMtd] 
     * @param {boolean} [isYtd] 
     * @param {any} [fromDate] 
     * @param {any} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getUniqueProgramProductSoldCount(programId: string, isMtd?: boolean, isYtd?: boolean, fromDate?: any, toDate?: any, options?: any) {
        return DashboardApiFp(this.configuration).getUniqueProgramProductSoldCount(programId, isMtd, isYtd, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardApi
     */
    public getUniqueProgramProductsSoldForLast12Months(programId: string, options?: any) {
        return DashboardApiFp(this.configuration).getUniqueProgramProductsSoldForLast12Months(programId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ErrorType} [eRRORUNKNOWN] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealthStatus: async (eRRORUNKNOWN?: ErrorType, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (eRRORUNKNOWN !== undefined) {
                localVarQueryParameter[''] = eRRORUNKNOWN;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ErrorType} [eRRORUNKNOWN] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHealthStatus(eRRORUNKNOWN?: ErrorType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthReponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHealthStatus(eRRORUNKNOWN, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * 
         * @param {ErrorType} [eRRORUNKNOWN] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHealthStatus(eRRORUNKNOWN?: ErrorType, options?: any): AxiosPromise<HealthReponse> {
            return localVarFp.getHealthStatus(eRRORUNKNOWN, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * 
     * @param {ErrorType} [eRRORUNKNOWN] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public getHealthStatus(eRRORUNKNOWN?: ErrorType, options?: any) {
        return HealthApiFp(this.configuration).getHealthStatus(eRRORUNKNOWN, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MediaApi - axios parameter creator
 * @export
 */
export const MediaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array<any>} [files] 
         * @param {string} [fileType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMultiple: async (files?: Array<any>, fileType?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/file/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
            if (fileType !== undefined) { 
                localVarFormParams.append('fileType', fileType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaApi - functional programming interface
 * @export
 */
export const MediaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MediaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Array<any>} [files] 
         * @param {string} [fileType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadMultiple(files?: Array<any>, fileType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMultipleFileUploadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadMultiple(files, fileType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MediaApi - factory interface
 * @export
 */
export const MediaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MediaApiFp(configuration)
    return {
        /**
         * 
         * @param {Array<any>} [files] 
         * @param {string} [fileType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadMultiple(files?: Array<any>, fileType?: string, options?: any): AxiosPromise<GetMultipleFileUploadResponse> {
            return localVarFp.uploadMultiple(files, fileType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MediaApi - object-oriented interface
 * @export
 * @class MediaApi
 * @extends {BaseAPI}
 */
export class MediaApi extends BaseAPI {
    /**
     * 
     * @param {Array<any>} [files] 
     * @param {string} [fileType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public uploadMultiple(files?: Array<any>, fileType?: string, options?: any) {
        return MediaApiFp(this.configuration).uploadMultiple(files, fileType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrderApi - axios parameter creator
 * @export
 */
export const OrderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} programProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveMOQNotMetProductOrders: async (programProductId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programProductId' is not null or undefined
            assertParamExists('approveMOQNotMetProductOrders', 'programProductId', programProductId)
            const localVarPath = `/v1/order/moq-not-met-orders/program-product/{programProductId}/approve`
                .replace(`{${"programProductId"}}`, encodeURIComponent(String(programProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderGroupId 
         * @param {ReturnRequestRefundEstimatesDTO} returnRequestRefundEstimatesDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateReturnCharge: async (orderGroupId: string, returnRequestRefundEstimatesDTO: ReturnRequestRefundEstimatesDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderGroupId' is not null or undefined
            assertParamExists('calculateReturnCharge', 'orderGroupId', orderGroupId)
            // verify required parameter 'returnRequestRefundEstimatesDTO' is not null or undefined
            assertParamExists('calculateReturnCharge', 'returnRequestRefundEstimatesDTO', returnRequestRefundEstimatesDTO)
            const localVarPath = `/v1/order/order-group/{orderGroupId}/calculate-refund`
                .replace(`{${"orderGroupId"}}`, encodeURIComponent(String(orderGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(returnRequestRefundEstimatesDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder: async (orderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('cancelOrder', 'orderId', orderId)
            const localVarPath = `/v1/order/{orderId}/cancel`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrdersForFailedPayments: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/order/cancel-failed-payment-orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShippingLabel: async (orderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('createShippingLabel', 'orderId', orderId)
            const localVarPath = `/v1/order/{orderId}/shipping-label`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShippingLabelForOrder: async (orderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('createShippingLabelForOrder', 'orderId', orderId)
            const localVarPath = `/v1/order/order/{orderId}/new-shipping-label`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineMOQNotMetProductOrders: async (programProductId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programProductId' is not null or undefined
            assertParamExists('declineMOQNotMetProductOrders', 'programProductId', programProductId)
            const localVarPath = `/v1/order/moq-not-met-orders/program-product/{programProductId}/decline`
                .replace(`{${"programProductId"}}`, encodeURIComponent(String(programProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ExportOrdersDto} exportOrdersDto 
         * @param {Array<string>} [status] 
         * @param {string} [searchTxt] 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {string} [sortType] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAllOrders: async (exportOrdersDto: ExportOrdersDto, status?: Array<string>, searchTxt?: string, isMtd?: boolean, isYtd?: boolean, sortType?: string, fromDate?: any, toDate?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'exportOrdersDto' is not null or undefined
            assertParamExists('downloadAllOrders', 'exportOrdersDto', exportOrdersDto)
            const localVarPath = `/v1/order/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (searchTxt !== undefined) {
                localVarQueryParameter['searchTxt'] = searchTxt;
            }

            if (isMtd !== undefined) {
                localVarQueryParameter['isMtd'] = isMtd;
            }

            if (isYtd !== undefined) {
                localVarQueryParameter['isYtd'] = isYtd;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exportOrdersDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ExportOrdersDto} exportOrdersDto 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [searchTxt] 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {string} [sortType] 
         * @param {any} [status] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadOrderItemReturns: async (exportOrdersDto: ExportOrdersDto, limit?: number, offset?: number, searchTxt?: string, isMtd?: boolean, isYtd?: boolean, sortType?: string, status?: any, fromDate?: any, toDate?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'exportOrdersDto' is not null or undefined
            assertParamExists('downloadOrderItemReturns', 'exportOrdersDto', exportOrdersDto)
            const localVarPath = `/v1/order/returns/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (searchTxt !== undefined) {
                localVarQueryParameter['searchTxt'] = searchTxt;
            }

            if (isMtd !== undefined) {
                localVarQueryParameter['isMtd'] = isMtd;
            }

            if (isYtd !== undefined) {
                localVarQueryParameter['isYtd'] = isYtd;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exportOrdersDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {ExportOrdersDto} exportOrdersDto 
         * @param {string} [searchTxt] 
         * @param {Array<string>} [status] 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {string} [sortType] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadProgramOrders: async (programId: string, exportOrdersDto: ExportOrdersDto, searchTxt?: string, status?: Array<string>, isMtd?: boolean, isYtd?: boolean, sortType?: string, fromDate?: any, toDate?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('downloadProgramOrders', 'programId', programId)
            // verify required parameter 'exportOrdersDto' is not null or undefined
            assertParamExists('downloadProgramOrders', 'exportOrdersDto', exportOrdersDto)
            const localVarPath = `/v1/order/program/{programId}/export`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (searchTxt !== undefined) {
                localVarQueryParameter['searchTxt'] = searchTxt;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (isMtd !== undefined) {
                localVarQueryParameter['isMtd'] = isMtd;
            }

            if (isYtd !== undefined) {
                localVarQueryParameter['isYtd'] = isYtd;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exportOrdersDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailReminderForFailedPayments: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/order/email-remainder-failed-payment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Array<string>} [status] 
         * @param {string} [searchTxt] 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {string} [sortType] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrders: async (limit?: number, offset?: number, status?: Array<string>, searchTxt?: string, isMtd?: boolean, isYtd?: boolean, sortType?: string, fromDate?: any, toDate?: any, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/order/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (searchTxt !== undefined) {
                localVarQueryParameter['searchTxt'] = searchTxt;
            }

            if (isMtd !== undefined) {
                localVarQueryParameter['isMtd'] = isMtd;
            }

            if (isYtd !== undefined) {
                localVarQueryParameter['isYtd'] = isYtd;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {number} [interval] 
         * @param {Array<string>} [status] 
         * @param {Array<string>} [orderPaymentStatus] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerOrders: async (programId: string, limit?: number, offset?: number, interval?: number, status?: Array<string>, orderPaymentStatus?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getCustomerOrders', 'programId', programId)
            const localVarPath = `/v1/order/program/{programId}/my-orders`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (orderPaymentStatus) {
                localVarQueryParameter['orderPaymentStatus'] = orderPaymentStatus;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupedOrders: async (orderId: string, programId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getGroupedOrders', 'orderId', orderId)
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getGroupedOrders', 'programId', programId)
            const localVarPath = `/v1/order/{orderId}/program/{programId}/grouped-orders`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderGroupId 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupedOrdersCheckoutSummary: async (orderGroupId: string, programId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderGroupId' is not null or undefined
            assertParamExists('getGroupedOrdersCheckoutSummary', 'orderGroupId', orderGroupId)
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getGroupedOrdersCheckoutSummary', 'programId', programId)
            const localVarPath = `/v1/order/order-group/{orderGroupId}/program/{programId}/grouped-orders-checkout-summary`
                .replace(`{${"orderGroupId"}}`, encodeURIComponent(String(orderGroupId)))
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [searchTxt] 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMOQNotMetProductOrders: async (limit?: number, offset?: number, searchTxt?: string, isMtd?: boolean, isYtd?: boolean, fromDate?: any, toDate?: any, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/order/moq-not-met-orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (searchTxt !== undefined) {
                localVarQueryParameter['searchTxt'] = searchTxt;
            }

            if (isMtd !== undefined) {
                localVarQueryParameter['isMtd'] = isMtd;
            }

            if (isYtd !== undefined) {
                localVarQueryParameter['isYtd'] = isYtd;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderDetails: async (orderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getOrderDetails', 'orderId', orderId)
            const localVarPath = `/v1/order/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderInvoice: async (orderGroupId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderGroupId' is not null or undefined
            assertParamExists('getOrderInvoice', 'orderGroupId', orderGroupId)
            const localVarPath = `/v1/order/order-group/{orderGroupId}/invoice`
                .replace(`{${"orderGroupId"}}`, encodeURIComponent(String(orderGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} orderItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderItemDetails: async (orderId: string, orderItemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getOrderItemDetails', 'orderId', orderId)
            // verify required parameter 'orderItemId' is not null or undefined
            assertParamExists('getOrderItemDetails', 'orderItemId', orderItemId)
            const localVarPath = `/v1/order/{orderId}/orderItem/{orderItemId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"orderItemId"}}`, encodeURIComponent(String(orderItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} orderItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderItemReturnReceipt: async (orderId: string, orderItemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getOrderItemReturnReceipt', 'orderId', orderId)
            // verify required parameter 'orderItemId' is not null or undefined
            assertParamExists('getOrderItemReturnReceipt', 'orderItemId', orderItemId)
            const localVarPath = `/v1/order/{orderId}/order-item/{orderItemId}/return-receipt`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"orderItemId"}}`, encodeURIComponent(String(orderItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderItemReturnId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderItemReturnRequest: async (orderItemReturnId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderItemReturnId' is not null or undefined
            assertParamExists('getOrderItemReturnRequest', 'orderItemReturnId', orderItemReturnId)
            const localVarPath = `/v1/order/return/{orderItemReturnId}/review-request`
                .replace(`{${"orderItemReturnId"}}`, encodeURIComponent(String(orderItemReturnId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [searchTxt] 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {string} [sortType] 
         * @param {any} [status] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderItemReturns: async (limit?: number, offset?: number, searchTxt?: string, isMtd?: boolean, isYtd?: boolean, sortType?: string, status?: any, fromDate?: any, toDate?: any, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/order/returns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (searchTxt !== undefined) {
                localVarQueryParameter['searchTxt'] = searchTxt;
            }

            if (isMtd !== undefined) {
                localVarQueryParameter['isMtd'] = isMtd;
            }

            if (isYtd !== undefined) {
                localVarQueryParameter['isYtd'] = isYtd;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} orderItemId 
         * @param {string} reasonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderRefundDetails: async (orderId: string, orderItemId: string, reasonId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getOrderRefundDetails', 'orderId', orderId)
            // verify required parameter 'orderItemId' is not null or undefined
            assertParamExists('getOrderRefundDetails', 'orderItemId', orderItemId)
            // verify required parameter 'reasonId' is not null or undefined
            assertParamExists('getOrderRefundDetails', 'reasonId', reasonId)
            const localVarPath = `/v1/order/{orderId}/order-item/{orderItemId}/refund-details/{reasonId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"orderItemId"}}`, encodeURIComponent(String(orderItemId)))
                .replace(`{${"reasonId"}}`, encodeURIComponent(String(reasonId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} orderItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderReturnDetails: async (orderId: string, orderItemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getOrderReturnDetails', 'orderId', orderId)
            // verify required parameter 'orderItemId' is not null or undefined
            assertParamExists('getOrderReturnDetails', 'orderItemId', orderItemId)
            const localVarPath = `/v1/order/{orderId}/order-item/{orderItemId}/return-details`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"orderItemId"}}`, encodeURIComponent(String(orderItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderReturnId 
         * @param {string} imageId 
         * @param {number} [size] 
         * @param {string} [scale] 
         * @param {boolean} [original] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderReturnImage: async (orderReturnId: string, imageId: string, size?: number, scale?: string, original?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderReturnId' is not null or undefined
            assertParamExists('getOrderReturnImage', 'orderReturnId', orderReturnId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('getOrderReturnImage', 'imageId', imageId)
            const localVarPath = `/v1/order/return/{orderReturnId}/order-return-image/{imageId}`
                .replace(`{${"orderReturnId"}}`, encodeURIComponent(String(orderReturnId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (scale !== undefined) {
                localVarQueryParameter['scale'] = scale;
            }

            if (original !== undefined) {
                localVarQueryParameter['original'] = original;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderReturnId 
         * @param {string} imageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderReturnImageUrl: async (orderReturnId: string, imageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderReturnId' is not null or undefined
            assertParamExists('getOrderReturnImageUrl', 'orderReturnId', orderReturnId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('getOrderReturnImageUrl', 'imageId', imageId)
            const localVarPath = `/v1/order/return/{orderReturnId}/order-return-image/{imageId}/url`
                .replace(`{${"orderReturnId"}}`, encodeURIComponent(String(orderReturnId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderReturnId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderReturnRequestList: async (orderReturnId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderReturnId' is not null or undefined
            assertParamExists('getOrderReturnRequestList', 'orderReturnId', orderReturnId)
            const localVarPath = `/v1/order/return/{orderReturnId}/return-requests`
                .replace(`{${"orderReturnId"}}`, encodeURIComponent(String(orderReturnId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [searchTxt] 
         * @param {Array<string>} [status] 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {string} [sortType] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramOrders: async (programId: string, limit?: number, offset?: number, searchTxt?: string, status?: Array<string>, isMtd?: boolean, isYtd?: boolean, sortType?: string, fromDate?: any, toDate?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getProgramOrders', 'programId', programId)
            const localVarPath = `/v1/order/program/{programId}/all`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (searchTxt !== undefined) {
                localVarQueryParameter['searchTxt'] = searchTxt;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (isMtd !== undefined) {
                localVarQueryParameter['isMtd'] = isMtd;
            }

            if (isYtd !== undefined) {
                localVarQueryParameter['isYtd'] = isYtd;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (fromDate !== undefined) {
                localVarQueryParameter['fromDate'] = fromDate;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['toDate'] = toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReturnOrderShippingLabel: async (orderItemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderItemId' is not null or undefined
            assertParamExists('getReturnOrderShippingLabel', 'orderItemId', orderItemId)
            const localVarPath = `/v1/order/order-item/{orderItemId}/get-return-order-shipping-label`
                .replace(`{${"orderItemId"}}`, encodeURIComponent(String(orderItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} orderItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReturnStatusForOrderItem: async (orderId: string, orderItemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getReturnStatusForOrderItem', 'orderId', orderId)
            // verify required parameter 'orderItemId' is not null or undefined
            assertParamExists('getReturnStatusForOrderItem', 'orderItemId', orderItemId)
            const localVarPath = `/v1/order/{orderId}/order-item/{orderItemId}/return-status`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"orderItemId"}}`, encodeURIComponent(String(orderItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReturnableOrderItems: async (orderGroupId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderGroupId' is not null or undefined
            assertParamExists('getReturnableOrderItems', 'orderGroupId', orderGroupId)
            const localVarPath = `/v1/order/order-group/{orderGroupId}/returnable-items`
                .replace(`{${"orderGroupId"}}`, encodeURIComponent(String(orderGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MarkDeliveredRequestDTO} markDeliveredRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDelivered: async (markDeliveredRequestDTO: MarkDeliveredRequestDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'markDeliveredRequestDTO' is not null or undefined
            assertParamExists('markDelivered', 'markDeliveredRequestDTO', markDeliveredRequestDTO)
            const localVarPath = `/v1/order/mark-delivered`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(markDeliveredRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} orderItemId 
         * @param {Array<any>} [files] 
         * @param {string} [reasonId] 
         * @param {string} [explanation] 
         * @param {string} [paymentMethod] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestOrderReturn: async (orderId: string, orderItemId: string, files?: Array<any>, reasonId?: string, explanation?: string, paymentMethod?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('requestOrderReturn', 'orderId', orderId)
            // verify required parameter 'orderItemId' is not null or undefined
            assertParamExists('requestOrderReturn', 'orderItemId', orderItemId)
            const localVarPath = `/v1/order/{orderId}/order-item/{orderItemId}/return-request`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)))
                .replace(`{${"orderItemId"}}`, encodeURIComponent(String(orderItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
            if (reasonId !== undefined) { 
                localVarFormParams.append('reasonId', reasonId as any);
            }
    
            if (explanation !== undefined) { 
                localVarFormParams.append('explanation', explanation as any);
            }
    
            if (paymentMethod !== undefined) { 
                localVarFormParams.append('paymentMethod', paymentMethod as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderItemReturnId 
         * @param {string} type 
         * @param {RespondReturnOrderDTO} respondReturnOrderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        respondReturnRequest: async (orderItemReturnId: string, type: string, respondReturnOrderDTO: RespondReturnOrderDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderItemReturnId' is not null or undefined
            assertParamExists('respondReturnRequest', 'orderItemReturnId', orderItemReturnId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('respondReturnRequest', 'type', type)
            // verify required parameter 'respondReturnOrderDTO' is not null or undefined
            assertParamExists('respondReturnRequest', 'respondReturnOrderDTO', respondReturnOrderDTO)
            const localVarPath = `/v1/order/order-item-return/{orderItemReturnId}/respond-return-request/{type}`
                .replace(`{${"orderItemReturnId"}}`, encodeURIComponent(String(orderItemReturnId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(respondReturnOrderDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderReturnId 
         * @param {MultipleItemReturnRespondDTO} multipleItemReturnRespondDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        respondReturnRequests: async (orderReturnId: string, multipleItemReturnRespondDTO: MultipleItemReturnRespondDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderReturnId' is not null or undefined
            assertParamExists('respondReturnRequests', 'orderReturnId', orderReturnId)
            // verify required parameter 'multipleItemReturnRespondDTO' is not null or undefined
            assertParamExists('respondReturnRequests', 'multipleItemReturnRespondDTO', multipleItemReturnRespondDTO)
            const localVarPath = `/v1/order/return/{orderReturnId}/respond-order-return`
                .replace(`{${"orderReturnId"}}`, encodeURIComponent(String(orderReturnId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(multipleItemReturnRespondDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startOrdersSyncJob: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/order/sync-orders-salesforce`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startUpdateOrdersJob: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/order/sync-order-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orderGroupId 
         * @param {MultipleItemReturnRequestDTO} multipleItemReturnRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitReturnRequest: async (orderGroupId: string, multipleItemReturnRequestDTO: MultipleItemReturnRequestDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderGroupId' is not null or undefined
            assertParamExists('submitReturnRequest', 'orderGroupId', orderGroupId)
            // verify required parameter 'multipleItemReturnRequestDTO' is not null or undefined
            assertParamExists('submitReturnRequest', 'multipleItemReturnRequestDTO', multipleItemReturnRequestDTO)
            const localVarPath = `/v1/order/order-group/{orderGroupId}/submit-return-request`
                .replace(`{${"orderGroupId"}}`, encodeURIComponent(String(orderGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(multipleItemReturnRequestDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderApi - functional programming interface
 * @export
 */
export const OrderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} programProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveMOQNotMetProductOrders(programProductId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveMOQNotMetProductOrders(programProductId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} orderGroupId 
         * @param {ReturnRequestRefundEstimatesDTO} returnRequestRefundEstimatesDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async calculateReturnCharge(orderGroupId: string, returnRequestRefundEstimatesDTO: ReturnRequestRefundEstimatesDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetReturnOrderRefundEstimatesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.calculateReturnCharge(orderGroupId, returnRequestRefundEstimatesDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelOrder(orderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelOrder(orderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelOrdersForFailedPayments(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelOrdersForFailedPayments(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createShippingLabel(orderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createShippingLabel(orderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createShippingLabelForOrder(orderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetShippingLabelPDFResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createShippingLabelForOrder(orderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async declineMOQNotMetProductOrders(programProductId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.declineMOQNotMetProductOrders(programProductId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ExportOrdersDto} exportOrdersDto 
         * @param {Array<string>} [status] 
         * @param {string} [searchTxt] 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {string} [sortType] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadAllOrders(exportOrdersDto: ExportOrdersDto, status?: Array<string>, searchTxt?: string, isMtd?: boolean, isYtd?: boolean, sortType?: string, fromDate?: any, toDate?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadAllOrders(exportOrdersDto, status, searchTxt, isMtd, isYtd, sortType, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ExportOrdersDto} exportOrdersDto 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [searchTxt] 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {string} [sortType] 
         * @param {any} [status] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadOrderItemReturns(exportOrdersDto: ExportOrdersDto, limit?: number, offset?: number, searchTxt?: string, isMtd?: boolean, isYtd?: boolean, sortType?: string, status?: any, fromDate?: any, toDate?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadOrderItemReturns(exportOrdersDto, limit, offset, searchTxt, isMtd, isYtd, sortType, status, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {ExportOrdersDto} exportOrdersDto 
         * @param {string} [searchTxt] 
         * @param {Array<string>} [status] 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {string} [sortType] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadProgramOrders(programId: string, exportOrdersDto: ExportOrdersDto, searchTxt?: string, status?: Array<string>, isMtd?: boolean, isYtd?: boolean, sortType?: string, fromDate?: any, toDate?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadProgramOrders(programId, exportOrdersDto, searchTxt, status, isMtd, isYtd, sortType, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async emailReminderForFailedPayments(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.emailReminderForFailedPayments(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Array<string>} [status] 
         * @param {string} [searchTxt] 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {string} [sortType] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllOrders(limit?: number, offset?: number, status?: Array<string>, searchTxt?: string, isMtd?: boolean, isYtd?: boolean, sortType?: string, fromDate?: any, toDate?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrdersListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllOrders(limit, offset, status, searchTxt, isMtd, isYtd, sortType, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {number} [interval] 
         * @param {Array<string>} [status] 
         * @param {Array<string>} [orderPaymentStatus] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerOrders(programId: string, limit?: number, offset?: number, interval?: number, status?: Array<string>, orderPaymentStatus?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomerOrdersListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomerOrders(programId, limit, offset, interval, status, orderPaymentStatus, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupedOrders(orderId: string, programId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomerGroupedOrdersListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupedOrders(orderId, programId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} orderGroupId 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupedOrdersCheckoutSummary(orderGroupId: string, programId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetGroupedOrdersCheckoutSummaryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupedOrdersCheckoutSummary(orderGroupId, programId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [searchTxt] 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMOQNotMetProductOrders(limit?: number, offset?: number, searchTxt?: string, isMtd?: boolean, isYtd?: boolean, fromDate?: any, toDate?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMoqNotMetProductOrderListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMOQNotMetProductOrders(limit, offset, searchTxt, isMtd, isYtd, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderDetails(orderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderDetails(orderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} orderGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderInvoice(orderGroupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderGroupInvoiceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderInvoice(orderGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} orderItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderItemDetails(orderId: string, orderItemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderItemDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderItemDetails(orderId, orderItemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} orderItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderItemReturnReceipt(orderId: string, orderItemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItemReturnReceiptResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderItemReturnReceipt(orderId, orderItemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} orderItemReturnId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderItemReturnRequest(orderItemReturnId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItemReviewRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderItemReturnRequest(orderItemReturnId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [searchTxt] 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {string} [sortType] 
         * @param {any} [status] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderItemReturns(limit?: number, offset?: number, searchTxt?: string, isMtd?: boolean, isYtd?: boolean, sortType?: string, status?: any, fromDate?: any, toDate?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItemReturnListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderItemReturns(limit, offset, searchTxt, isMtd, isYtd, sortType, status, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} orderItemId 
         * @param {string} reasonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderRefundDetails(orderId: string, orderItemId: string, reasonId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetReturnRefundDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderRefundDetails(orderId, orderItemId, reasonId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} orderItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderReturnDetails(orderId: string, orderItemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderReturnItemResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderReturnDetails(orderId, orderItemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} orderReturnId 
         * @param {string} imageId 
         * @param {number} [size] 
         * @param {string} [scale] 
         * @param {boolean} [original] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderReturnImage(orderReturnId: string, imageId: string, size?: number, scale?: string, original?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderReturnImage(orderReturnId, imageId, size, scale, original, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} orderReturnId 
         * @param {string} imageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderReturnImageUrl(orderReturnId: string, imageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderReturnImageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderReturnImageUrl(orderReturnId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} orderReturnId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderReturnRequestList(orderReturnId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItemReturnRequestList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderReturnRequestList(orderReturnId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [searchTxt] 
         * @param {Array<string>} [status] 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {string} [sortType] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramOrders(programId: string, limit?: number, offset?: number, searchTxt?: string, status?: Array<string>, isMtd?: boolean, isYtd?: boolean, sortType?: string, fromDate?: any, toDate?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrdersListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramOrders(programId, limit, offset, searchTxt, status, isMtd, isYtd, sortType, fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} orderItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReturnOrderShippingLabel(orderItemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetShippingLabelPDFResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReturnOrderShippingLabel(orderItemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} orderItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReturnStatusForOrderItem(orderId: string, orderItemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderItemReturnStatusList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReturnStatusForOrderItem(orderId, orderItemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} orderGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReturnableOrderItems(orderGroupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReturnableOrderItemsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReturnableOrderItems(orderGroupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {MarkDeliveredRequestDTO} markDeliveredRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markDelivered(markDeliveredRequestDTO: MarkDeliveredRequestDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markDelivered(markDeliveredRequestDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} orderItemId 
         * @param {Array<any>} [files] 
         * @param {string} [reasonId] 
         * @param {string} [explanation] 
         * @param {string} [paymentMethod] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestOrderReturn(orderId: string, orderItemId: string, files?: Array<any>, reasonId?: string, explanation?: string, paymentMethod?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderReturnRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestOrderReturn(orderId, orderItemId, files, reasonId, explanation, paymentMethod, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} orderItemReturnId 
         * @param {string} type 
         * @param {RespondReturnOrderDTO} respondReturnOrderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async respondReturnRequest(orderItemReturnId: string, type: string, respondReturnOrderDTO: RespondReturnOrderDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.respondReturnRequest(orderItemReturnId, type, respondReturnOrderDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} orderReturnId 
         * @param {MultipleItemReturnRespondDTO} multipleItemReturnRespondDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async respondReturnRequests(orderReturnId: string, multipleItemReturnRespondDTO: MultipleItemReturnRespondDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.respondReturnRequests(orderReturnId, multipleItemReturnRespondDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startOrdersSyncJob(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startOrdersSyncJob(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startUpdateOrdersJob(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startUpdateOrdersJob(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} orderGroupId 
         * @param {MultipleItemReturnRequestDTO} multipleItemReturnRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitReturnRequest(orderGroupId: string, multipleItemReturnRequestDTO: MultipleItemReturnRequestDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitReturnRequest(orderGroupId, multipleItemReturnRequestDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrderApi - factory interface
 * @export
 */
export const OrderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderApiFp(configuration)
    return {
        /**
         * 
         * @param {string} programProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveMOQNotMetProductOrders(programProductId: string, options?: any): AxiosPromise<void> {
            return localVarFp.approveMOQNotMetProductOrders(programProductId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderGroupId 
         * @param {ReturnRequestRefundEstimatesDTO} returnRequestRefundEstimatesDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateReturnCharge(orderGroupId: string, returnRequestRefundEstimatesDTO: ReturnRequestRefundEstimatesDTO, options?: any): AxiosPromise<GetReturnOrderRefundEstimatesResponse> {
            return localVarFp.calculateReturnCharge(orderGroupId, returnRequestRefundEstimatesDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder(orderId: string, options?: any): AxiosPromise<void> {
            return localVarFp.cancelOrder(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrdersForFailedPayments(options?: any): AxiosPromise<void> {
            return localVarFp.cancelOrdersForFailedPayments(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShippingLabel(orderId: string, options?: any): AxiosPromise<void> {
            return localVarFp.createShippingLabel(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShippingLabelForOrder(orderId: string, options?: any): AxiosPromise<GetShippingLabelPDFResponse> {
            return localVarFp.createShippingLabelForOrder(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineMOQNotMetProductOrders(programProductId: string, options?: any): AxiosPromise<void> {
            return localVarFp.declineMOQNotMetProductOrders(programProductId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ExportOrdersDto} exportOrdersDto 
         * @param {Array<string>} [status] 
         * @param {string} [searchTxt] 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {string} [sortType] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadAllOrders(exportOrdersDto: ExportOrdersDto, status?: Array<string>, searchTxt?: string, isMtd?: boolean, isYtd?: boolean, sortType?: string, fromDate?: any, toDate?: any, options?: any): AxiosPromise<GetOrderFileResponse> {
            return localVarFp.downloadAllOrders(exportOrdersDto, status, searchTxt, isMtd, isYtd, sortType, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ExportOrdersDto} exportOrdersDto 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [searchTxt] 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {string} [sortType] 
         * @param {any} [status] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadOrderItemReturns(exportOrdersDto: ExportOrdersDto, limit?: number, offset?: number, searchTxt?: string, isMtd?: boolean, isYtd?: boolean, sortType?: string, status?: any, fromDate?: any, toDate?: any, options?: any): AxiosPromise<GetOrderFileResponse> {
            return localVarFp.downloadOrderItemReturns(exportOrdersDto, limit, offset, searchTxt, isMtd, isYtd, sortType, status, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {ExportOrdersDto} exportOrdersDto 
         * @param {string} [searchTxt] 
         * @param {Array<string>} [status] 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {string} [sortType] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadProgramOrders(programId: string, exportOrdersDto: ExportOrdersDto, searchTxt?: string, status?: Array<string>, isMtd?: boolean, isYtd?: boolean, sortType?: string, fromDate?: any, toDate?: any, options?: any): AxiosPromise<GetOrderFileResponse> {
            return localVarFp.downloadProgramOrders(programId, exportOrdersDto, searchTxt, status, isMtd, isYtd, sortType, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emailReminderForFailedPayments(options?: any): AxiosPromise<void> {
            return localVarFp.emailReminderForFailedPayments(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Array<string>} [status] 
         * @param {string} [searchTxt] 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {string} [sortType] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOrders(limit?: number, offset?: number, status?: Array<string>, searchTxt?: string, isMtd?: boolean, isYtd?: boolean, sortType?: string, fromDate?: any, toDate?: any, options?: any): AxiosPromise<GetOrdersListResponse> {
            return localVarFp.getAllOrders(limit, offset, status, searchTxt, isMtd, isYtd, sortType, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {number} [interval] 
         * @param {Array<string>} [status] 
         * @param {Array<string>} [orderPaymentStatus] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerOrders(programId: string, limit?: number, offset?: number, interval?: number, status?: Array<string>, orderPaymentStatus?: Array<string>, options?: any): AxiosPromise<GetCustomerOrdersListResponse> {
            return localVarFp.getCustomerOrders(programId, limit, offset, interval, status, orderPaymentStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupedOrders(orderId: string, programId: string, options?: any): AxiosPromise<GetCustomerGroupedOrdersListResponse> {
            return localVarFp.getGroupedOrders(orderId, programId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderGroupId 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupedOrdersCheckoutSummary(orderGroupId: string, programId: string, options?: any): AxiosPromise<GetGroupedOrdersCheckoutSummaryResponse> {
            return localVarFp.getGroupedOrdersCheckoutSummary(orderGroupId, programId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [searchTxt] 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMOQNotMetProductOrders(limit?: number, offset?: number, searchTxt?: string, isMtd?: boolean, isYtd?: boolean, fromDate?: any, toDate?: any, options?: any): AxiosPromise<GetMoqNotMetProductOrderListResponse> {
            return localVarFp.getMOQNotMetProductOrders(limit, offset, searchTxt, isMtd, isYtd, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderDetails(orderId: string, options?: any): AxiosPromise<GetOrderDetailsResponse> {
            return localVarFp.getOrderDetails(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderInvoice(orderGroupId: string, options?: any): AxiosPromise<GetOrderGroupInvoiceResponse> {
            return localVarFp.getOrderInvoice(orderGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} orderItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderItemDetails(orderId: string, orderItemId: string, options?: any): AxiosPromise<GetOrderItemDetailsResponse> {
            return localVarFp.getOrderItemDetails(orderId, orderItemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} orderItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderItemReturnReceipt(orderId: string, orderItemId: string, options?: any): AxiosPromise<OrderItemReturnReceiptResponse> {
            return localVarFp.getOrderItemReturnReceipt(orderId, orderItemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderItemReturnId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderItemReturnRequest(orderItemReturnId: string, options?: any): AxiosPromise<OrderItemReviewRequestResponse> {
            return localVarFp.getOrderItemReturnRequest(orderItemReturnId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [searchTxt] 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {string} [sortType] 
         * @param {any} [status] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderItemReturns(limit?: number, offset?: number, searchTxt?: string, isMtd?: boolean, isYtd?: boolean, sortType?: string, status?: any, fromDate?: any, toDate?: any, options?: any): AxiosPromise<OrderItemReturnListResponse> {
            return localVarFp.getOrderItemReturns(limit, offset, searchTxt, isMtd, isYtd, sortType, status, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} orderItemId 
         * @param {string} reasonId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderRefundDetails(orderId: string, orderItemId: string, reasonId: string, options?: any): AxiosPromise<GetReturnRefundDetailsResponse> {
            return localVarFp.getOrderRefundDetails(orderId, orderItemId, reasonId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} orderItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderReturnDetails(orderId: string, orderItemId: string, options?: any): AxiosPromise<GetOrderReturnItemResponse> {
            return localVarFp.getOrderReturnDetails(orderId, orderItemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderReturnId 
         * @param {string} imageId 
         * @param {number} [size] 
         * @param {string} [scale] 
         * @param {boolean} [original] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderReturnImage(orderReturnId: string, imageId: string, size?: number, scale?: string, original?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.getOrderReturnImage(orderReturnId, imageId, size, scale, original, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderReturnId 
         * @param {string} imageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderReturnImageUrl(orderReturnId: string, imageId: string, options?: any): AxiosPromise<GetOrderReturnImageResponse> {
            return localVarFp.getOrderReturnImageUrl(orderReturnId, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderReturnId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderReturnRequestList(orderReturnId: string, options?: any): AxiosPromise<OrderItemReturnRequestList> {
            return localVarFp.getOrderReturnRequestList(orderReturnId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [searchTxt] 
         * @param {Array<string>} [status] 
         * @param {boolean} [isMtd] 
         * @param {boolean} [isYtd] 
         * @param {string} [sortType] 
         * @param {any} [fromDate] 
         * @param {any} [toDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramOrders(programId: string, limit?: number, offset?: number, searchTxt?: string, status?: Array<string>, isMtd?: boolean, isYtd?: boolean, sortType?: string, fromDate?: any, toDate?: any, options?: any): AxiosPromise<GetOrdersListResponse> {
            return localVarFp.getProgramOrders(programId, limit, offset, searchTxt, status, isMtd, isYtd, sortType, fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReturnOrderShippingLabel(orderItemId: string, options?: any): AxiosPromise<GetShippingLabelPDFResponse> {
            return localVarFp.getReturnOrderShippingLabel(orderItemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} orderItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReturnStatusForOrderItem(orderId: string, orderItemId: string, options?: any): AxiosPromise<OrderItemReturnStatusList> {
            return localVarFp.getReturnStatusForOrderItem(orderId, orderItemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderGroupId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReturnableOrderItems(orderGroupId: string, options?: any): AxiosPromise<ReturnableOrderItemsResponse> {
            return localVarFp.getReturnableOrderItems(orderGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MarkDeliveredRequestDTO} markDeliveredRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDelivered(markDeliveredRequestDTO: MarkDeliveredRequestDTO, options?: any): AxiosPromise<void> {
            return localVarFp.markDelivered(markDeliveredRequestDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderId 
         * @param {string} orderItemId 
         * @param {Array<any>} [files] 
         * @param {string} [reasonId] 
         * @param {string} [explanation] 
         * @param {string} [paymentMethod] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestOrderReturn(orderId: string, orderItemId: string, files?: Array<any>, reasonId?: string, explanation?: string, paymentMethod?: string, options?: any): AxiosPromise<GetOrderReturnRequestResponse> {
            return localVarFp.requestOrderReturn(orderId, orderItemId, files, reasonId, explanation, paymentMethod, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderItemReturnId 
         * @param {string} type 
         * @param {RespondReturnOrderDTO} respondReturnOrderDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        respondReturnRequest(orderItemReturnId: string, type: string, respondReturnOrderDTO: RespondReturnOrderDTO, options?: any): AxiosPromise<void> {
            return localVarFp.respondReturnRequest(orderItemReturnId, type, respondReturnOrderDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderReturnId 
         * @param {MultipleItemReturnRespondDTO} multipleItemReturnRespondDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        respondReturnRequests(orderReturnId: string, multipleItemReturnRespondDTO: MultipleItemReturnRespondDTO, options?: any): AxiosPromise<void> {
            return localVarFp.respondReturnRequests(orderReturnId, multipleItemReturnRespondDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startOrdersSyncJob(options?: any): AxiosPromise<void> {
            return localVarFp.startOrdersSyncJob(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startUpdateOrdersJob(options?: any): AxiosPromise<void> {
            return localVarFp.startUpdateOrdersJob(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orderGroupId 
         * @param {MultipleItemReturnRequestDTO} multipleItemReturnRequestDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitReturnRequest(orderGroupId: string, multipleItemReturnRequestDTO: MultipleItemReturnRequestDTO, options?: any): AxiosPromise<void> {
            return localVarFp.submitReturnRequest(orderGroupId, multipleItemReturnRequestDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export class OrderApi extends BaseAPI {
    /**
     * 
     * @param {string} programProductId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public approveMOQNotMetProductOrders(programProductId: string, options?: any) {
        return OrderApiFp(this.configuration).approveMOQNotMetProductOrders(programProductId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderGroupId 
     * @param {ReturnRequestRefundEstimatesDTO} returnRequestRefundEstimatesDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public calculateReturnCharge(orderGroupId: string, returnRequestRefundEstimatesDTO: ReturnRequestRefundEstimatesDTO, options?: any) {
        return OrderApiFp(this.configuration).calculateReturnCharge(orderGroupId, returnRequestRefundEstimatesDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public cancelOrder(orderId: string, options?: any) {
        return OrderApiFp(this.configuration).cancelOrder(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public cancelOrdersForFailedPayments(options?: any) {
        return OrderApiFp(this.configuration).cancelOrdersForFailedPayments(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public createShippingLabel(orderId: string, options?: any) {
        return OrderApiFp(this.configuration).createShippingLabel(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public createShippingLabelForOrder(orderId: string, options?: any) {
        return OrderApiFp(this.configuration).createShippingLabelForOrder(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programProductId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public declineMOQNotMetProductOrders(programProductId: string, options?: any) {
        return OrderApiFp(this.configuration).declineMOQNotMetProductOrders(programProductId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExportOrdersDto} exportOrdersDto 
     * @param {Array<string>} [status] 
     * @param {string} [searchTxt] 
     * @param {boolean} [isMtd] 
     * @param {boolean} [isYtd] 
     * @param {string} [sortType] 
     * @param {any} [fromDate] 
     * @param {any} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public downloadAllOrders(exportOrdersDto: ExportOrdersDto, status?: Array<string>, searchTxt?: string, isMtd?: boolean, isYtd?: boolean, sortType?: string, fromDate?: any, toDate?: any, options?: any) {
        return OrderApiFp(this.configuration).downloadAllOrders(exportOrdersDto, status, searchTxt, isMtd, isYtd, sortType, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExportOrdersDto} exportOrdersDto 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [searchTxt] 
     * @param {boolean} [isMtd] 
     * @param {boolean} [isYtd] 
     * @param {string} [sortType] 
     * @param {any} [status] 
     * @param {any} [fromDate] 
     * @param {any} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public downloadOrderItemReturns(exportOrdersDto: ExportOrdersDto, limit?: number, offset?: number, searchTxt?: string, isMtd?: boolean, isYtd?: boolean, sortType?: string, status?: any, fromDate?: any, toDate?: any, options?: any) {
        return OrderApiFp(this.configuration).downloadOrderItemReturns(exportOrdersDto, limit, offset, searchTxt, isMtd, isYtd, sortType, status, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {ExportOrdersDto} exportOrdersDto 
     * @param {string} [searchTxt] 
     * @param {Array<string>} [status] 
     * @param {boolean} [isMtd] 
     * @param {boolean} [isYtd] 
     * @param {string} [sortType] 
     * @param {any} [fromDate] 
     * @param {any} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public downloadProgramOrders(programId: string, exportOrdersDto: ExportOrdersDto, searchTxt?: string, status?: Array<string>, isMtd?: boolean, isYtd?: boolean, sortType?: string, fromDate?: any, toDate?: any, options?: any) {
        return OrderApiFp(this.configuration).downloadProgramOrders(programId, exportOrdersDto, searchTxt, status, isMtd, isYtd, sortType, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public emailReminderForFailedPayments(options?: any) {
        return OrderApiFp(this.configuration).emailReminderForFailedPayments(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {Array<string>} [status] 
     * @param {string} [searchTxt] 
     * @param {boolean} [isMtd] 
     * @param {boolean} [isYtd] 
     * @param {string} [sortType] 
     * @param {any} [fromDate] 
     * @param {any} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getAllOrders(limit?: number, offset?: number, status?: Array<string>, searchTxt?: string, isMtd?: boolean, isYtd?: boolean, sortType?: string, fromDate?: any, toDate?: any, options?: any) {
        return OrderApiFp(this.configuration).getAllOrders(limit, offset, status, searchTxt, isMtd, isYtd, sortType, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {number} [interval] 
     * @param {Array<string>} [status] 
     * @param {Array<string>} [orderPaymentStatus] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getCustomerOrders(programId: string, limit?: number, offset?: number, interval?: number, status?: Array<string>, orderPaymentStatus?: Array<string>, options?: any) {
        return OrderApiFp(this.configuration).getCustomerOrders(programId, limit, offset, interval, status, orderPaymentStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderId 
     * @param {string} programId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getGroupedOrders(orderId: string, programId: string, options?: any) {
        return OrderApiFp(this.configuration).getGroupedOrders(orderId, programId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderGroupId 
     * @param {string} programId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getGroupedOrdersCheckoutSummary(orderGroupId: string, programId: string, options?: any) {
        return OrderApiFp(this.configuration).getGroupedOrdersCheckoutSummary(orderGroupId, programId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [searchTxt] 
     * @param {boolean} [isMtd] 
     * @param {boolean} [isYtd] 
     * @param {any} [fromDate] 
     * @param {any} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getMOQNotMetProductOrders(limit?: number, offset?: number, searchTxt?: string, isMtd?: boolean, isYtd?: boolean, fromDate?: any, toDate?: any, options?: any) {
        return OrderApiFp(this.configuration).getMOQNotMetProductOrders(limit, offset, searchTxt, isMtd, isYtd, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrderDetails(orderId: string, options?: any) {
        return OrderApiFp(this.configuration).getOrderDetails(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderGroupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrderInvoice(orderGroupId: string, options?: any) {
        return OrderApiFp(this.configuration).getOrderInvoice(orderGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderId 
     * @param {string} orderItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrderItemDetails(orderId: string, orderItemId: string, options?: any) {
        return OrderApiFp(this.configuration).getOrderItemDetails(orderId, orderItemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderId 
     * @param {string} orderItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrderItemReturnReceipt(orderId: string, orderItemId: string, options?: any) {
        return OrderApiFp(this.configuration).getOrderItemReturnReceipt(orderId, orderItemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderItemReturnId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrderItemReturnRequest(orderItemReturnId: string, options?: any) {
        return OrderApiFp(this.configuration).getOrderItemReturnRequest(orderItemReturnId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [searchTxt] 
     * @param {boolean} [isMtd] 
     * @param {boolean} [isYtd] 
     * @param {string} [sortType] 
     * @param {any} [status] 
     * @param {any} [fromDate] 
     * @param {any} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrderItemReturns(limit?: number, offset?: number, searchTxt?: string, isMtd?: boolean, isYtd?: boolean, sortType?: string, status?: any, fromDate?: any, toDate?: any, options?: any) {
        return OrderApiFp(this.configuration).getOrderItemReturns(limit, offset, searchTxt, isMtd, isYtd, sortType, status, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderId 
     * @param {string} orderItemId 
     * @param {string} reasonId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrderRefundDetails(orderId: string, orderItemId: string, reasonId: string, options?: any) {
        return OrderApiFp(this.configuration).getOrderRefundDetails(orderId, orderItemId, reasonId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderId 
     * @param {string} orderItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrderReturnDetails(orderId: string, orderItemId: string, options?: any) {
        return OrderApiFp(this.configuration).getOrderReturnDetails(orderId, orderItemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderReturnId 
     * @param {string} imageId 
     * @param {number} [size] 
     * @param {string} [scale] 
     * @param {boolean} [original] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrderReturnImage(orderReturnId: string, imageId: string, size?: number, scale?: string, original?: boolean, options?: any) {
        return OrderApiFp(this.configuration).getOrderReturnImage(orderReturnId, imageId, size, scale, original, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderReturnId 
     * @param {string} imageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrderReturnImageUrl(orderReturnId: string, imageId: string, options?: any) {
        return OrderApiFp(this.configuration).getOrderReturnImageUrl(orderReturnId, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderReturnId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrderReturnRequestList(orderReturnId: string, options?: any) {
        return OrderApiFp(this.configuration).getOrderReturnRequestList(orderReturnId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [searchTxt] 
     * @param {Array<string>} [status] 
     * @param {boolean} [isMtd] 
     * @param {boolean} [isYtd] 
     * @param {string} [sortType] 
     * @param {any} [fromDate] 
     * @param {any} [toDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getProgramOrders(programId: string, limit?: number, offset?: number, searchTxt?: string, status?: Array<string>, isMtd?: boolean, isYtd?: boolean, sortType?: string, fromDate?: any, toDate?: any, options?: any) {
        return OrderApiFp(this.configuration).getProgramOrders(programId, limit, offset, searchTxt, status, isMtd, isYtd, sortType, fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getReturnOrderShippingLabel(orderItemId: string, options?: any) {
        return OrderApiFp(this.configuration).getReturnOrderShippingLabel(orderItemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderId 
     * @param {string} orderItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getReturnStatusForOrderItem(orderId: string, orderItemId: string, options?: any) {
        return OrderApiFp(this.configuration).getReturnStatusForOrderItem(orderId, orderItemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderGroupId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getReturnableOrderItems(orderGroupId: string, options?: any) {
        return OrderApiFp(this.configuration).getReturnableOrderItems(orderGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MarkDeliveredRequestDTO} markDeliveredRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public markDelivered(markDeliveredRequestDTO: MarkDeliveredRequestDTO, options?: any) {
        return OrderApiFp(this.configuration).markDelivered(markDeliveredRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderId 
     * @param {string} orderItemId 
     * @param {Array<any>} [files] 
     * @param {string} [reasonId] 
     * @param {string} [explanation] 
     * @param {string} [paymentMethod] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public requestOrderReturn(orderId: string, orderItemId: string, files?: Array<any>, reasonId?: string, explanation?: string, paymentMethod?: string, options?: any) {
        return OrderApiFp(this.configuration).requestOrderReturn(orderId, orderItemId, files, reasonId, explanation, paymentMethod, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderItemReturnId 
     * @param {string} type 
     * @param {RespondReturnOrderDTO} respondReturnOrderDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public respondReturnRequest(orderItemReturnId: string, type: string, respondReturnOrderDTO: RespondReturnOrderDTO, options?: any) {
        return OrderApiFp(this.configuration).respondReturnRequest(orderItemReturnId, type, respondReturnOrderDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderReturnId 
     * @param {MultipleItemReturnRespondDTO} multipleItemReturnRespondDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public respondReturnRequests(orderReturnId: string, multipleItemReturnRespondDTO: MultipleItemReturnRespondDTO, options?: any) {
        return OrderApiFp(this.configuration).respondReturnRequests(orderReturnId, multipleItemReturnRespondDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public startOrdersSyncJob(options?: any) {
        return OrderApiFp(this.configuration).startOrdersSyncJob(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public startUpdateOrdersJob(options?: any) {
        return OrderApiFp(this.configuration).startUpdateOrdersJob(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orderGroupId 
     * @param {MultipleItemReturnRequestDTO} multipleItemReturnRequestDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public submitReturnRequest(orderGroupId: string, multipleItemReturnRequestDTO: MultipleItemReturnRequestDTO, options?: any) {
        return OrderApiFp(this.configuration).submitReturnRequest(orderGroupId, multipleItemReturnRequestDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PaymentApi - axios parameter creator
 * @export
 */
export const PaymentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentSecretValues: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/payment/secret-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {OrderCheckoutDTO} orderCheckoutDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleOrderCheckout: async (programId: string, orderCheckoutDTO: OrderCheckoutDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('handleOrderCheckout', 'programId', programId)
            // verify required parameter 'orderCheckoutDTO' is not null or undefined
            assertParamExists('handleOrderCheckout', 'orderCheckoutDTO', orderCheckoutDTO)
            const localVarPath = `/v1/payment/program/{programId}/order-checkout`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderCheckoutDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} orderGroupId 
         * @param {RetryPaymentDTO} retryPaymentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRetryPayment: async (programId: string, orderGroupId: string, retryPaymentDTO: RetryPaymentDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('handleRetryPayment', 'programId', programId)
            // verify required parameter 'orderGroupId' is not null or undefined
            assertParamExists('handleRetryPayment', 'orderGroupId', orderGroupId)
            // verify required parameter 'retryPaymentDTO' is not null or undefined
            assertParamExists('handleRetryPayment', 'retryPaymentDTO', retryPaymentDTO)
            const localVarPath = `/v1/payment/program/{programId}/order-group/{orderGroupId}/retry-payment`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"orderGroupId"}}`, encodeURIComponent(String(orderGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(retryPaymentDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentApi - functional programming interface
 * @export
 */
export const PaymentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPaymentSecretValues(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPaymentSecretValues>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPaymentSecretValues(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {OrderCheckoutDTO} orderCheckoutDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleOrderCheckout(programId: string, orderCheckoutDTO: OrderCheckoutDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrdersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleOrderCheckout(programId, orderCheckoutDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} orderGroupId 
         * @param {RetryPaymentDTO} retryPaymentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleRetryPayment(programId: string, orderGroupId: string, retryPaymentDTO: RetryPaymentDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleRetryPayment(programId, orderGroupId, retryPaymentDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PaymentApi - factory interface
 * @export
 */
export const PaymentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentSecretValues(options?: any): AxiosPromise<GetPaymentSecretValues> {
            return localVarFp.getPaymentSecretValues(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {OrderCheckoutDTO} orderCheckoutDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleOrderCheckout(programId: string, orderCheckoutDTO: OrderCheckoutDTO, options?: any): AxiosPromise<GetOrdersResponse> {
            return localVarFp.handleOrderCheckout(programId, orderCheckoutDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} orderGroupId 
         * @param {RetryPaymentDTO} retryPaymentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleRetryPayment(programId: string, orderGroupId: string, retryPaymentDTO: RetryPaymentDTO, options?: any): AxiosPromise<void> {
            return localVarFp.handleRetryPayment(programId, orderGroupId, retryPaymentDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentApi - object-oriented interface
 * @export
 * @class PaymentApi
 * @extends {BaseAPI}
 */
export class PaymentApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public getPaymentSecretValues(options?: any) {
        return PaymentApiFp(this.configuration).getPaymentSecretValues(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {OrderCheckoutDTO} orderCheckoutDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public handleOrderCheckout(programId: string, orderCheckoutDTO: OrderCheckoutDTO, options?: any) {
        return PaymentApiFp(this.configuration).handleOrderCheckout(programId, orderCheckoutDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} orderGroupId 
     * @param {RetryPaymentDTO} retryPaymentDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    public handleRetryPayment(programId: string, orderGroupId: string, retryPaymentDTO: RetryPaymentDTO, options?: any) {
        return PaymentApiFp(this.configuration).handleRetryPayment(programId, orderGroupId, retryPaymentDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} coloredProductId 
         * @param {Array<Product3DColorLayerDTO>} product3DColorLayerDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add3DProductColor: async (coloredProductId: string, product3DColorLayerDTO: Array<Product3DColorLayerDTO>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'coloredProductId' is not null or undefined
            assertParamExists('add3DProductColor', 'coloredProductId', coloredProductId)
            // verify required parameter 'product3DColorLayerDTO' is not null or undefined
            assertParamExists('add3DProductColor', 'product3DColorLayerDTO', product3DColorLayerDTO)
            const localVarPath = `/v1/product/colored-product/{coloredProductId}/layer`
                .replace(`{${"coloredProductId"}}`, encodeURIComponent(String(coloredProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(product3DColorLayerDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {Array<string>} [chosenProductImageIds] 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMultipleProgramProductImages: async (programId: string, programProductId: string, chosenProductImageIds?: Array<string>, files?: Array<any>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('addMultipleProgramProductImages', 'programId', programId)
            // verify required parameter 'programProductId' is not null or undefined
            assertParamExists('addMultipleProgramProductImages', 'programProductId', programProductId)
            const localVarPath = `/v1/product/program/{programId}/program-product/{programProductId}/image-multiple`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"programProductId"}}`, encodeURIComponent(String(programProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (chosenProductImageIds) {
                localVarQueryParameter['chosenProductImageIds'] = chosenProductImageIds;
            }

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {AddCartItemDTO} addCartItemDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProductToCart: async (programId: string, addCartItemDTO: AddCartItemDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('addProductToCart', 'programId', programId)
            // verify required parameter 'addCartItemDTO' is not null or undefined
            assertParamExists('addProductToCart', 'addCartItemDTO', addCartItemDTO)
            const localVarPath = `/v1/product/program/{programId}/cart`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addCartItemDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {any} [file] 
         * @param {Array<string>} [colors] 
         * @param {number} [sensitivity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProgramArtwork: async (programId: string, file?: any, colors?: Array<string>, sensitivity?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('addProgramArtwork', 'programId', programId)
            const localVarPath = `/v1/product/program/{programId}/artwork`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
                if (colors) {
                localVarFormParams.append(colors.join(COLLECTION_FORMATS.csv));
            }

    
            if (sensitivity !== undefined) { 
                localVarFormParams.append('sensitivity', sensitivity as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProgramProductImage: async (programId: string, programProductId: string, file?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('addProgramProductImage', 'programId', programId)
            // verify required parameter 'programProductId' is not null or undefined
            assertParamExists('addProgramProductImage', 'programProductId', programProductId)
            const localVarPath = `/v1/product/program/{programId}/program-product/{programProductId}/image`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"programProductId"}}`, encodeURIComponent(String(programProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sku 
         * @param {UpdateProductTextureDTO} updateProductTextureDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTextureToParentProduct: async (sku: string, updateProductTextureDTO: UpdateProductTextureDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('addTextureToParentProduct', 'sku', sku)
            // verify required parameter 'updateProductTextureDTO' is not null or undefined
            assertParamExists('addTextureToParentProduct', 'updateProductTextureDTO', updateProductTextureDTO)
            const localVarPath = `/v1/product/texture/{sku}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProductTextureDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} programId 
         * @param {Array<ApplyArtworkDTO>} applyArtworkDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyProgramParentProductArtwork: async (programParentProductId: string, programId: string, applyArtworkDTO: Array<ApplyArtworkDTO>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programParentProductId' is not null or undefined
            assertParamExists('applyProgramParentProductArtwork', 'programParentProductId', programParentProductId)
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('applyProgramParentProductArtwork', 'programId', programId)
            // verify required parameter 'applyArtworkDTO' is not null or undefined
            assertParamExists('applyProgramParentProductArtwork', 'applyArtworkDTO', applyArtworkDTO)
            const localVarPath = `/v1/product/program/{programId}/program-parent-product/{programParentProductId}/apply-artwork`
                .replace(`{${"programParentProductId"}}`, encodeURIComponent(String(programParentProductId)))
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(applyArtworkDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sku 
         * @param {string} programId 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewProgramParentProduct: async (sku: string, programId: string, files?: Array<any>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('createNewProgramParentProduct', 'sku', sku)
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('createNewProgramParentProduct', 'programId', programId)
            const localVarPath = `/v1/product/{sku}/program/{programId}/new-program-parent-product`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)))
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sku 
         * @param {string} programId 
         * @param {CreateRebelProgramProductDTO} createRebelProgramProductDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProgramParentProduct: async (sku: string, programId: string, createRebelProgramProductDTO: CreateRebelProgramProductDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('createProgramParentProduct', 'sku', sku)
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('createProgramParentProduct', 'programId', programId)
            // verify required parameter 'createRebelProgramProductDTO' is not null or undefined
            assertParamExists('createProgramParentProduct', 'createRebelProgramProductDTO', createRebelProgramProductDTO)
            const localVarPath = `/v1/product/{sku}/program/{programId}/program-parent-product`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)))
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRebelProgramProductDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AddTextureDTO} addTextureDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTexture: async (addTextureDTO: AddTextureDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'addTextureDTO' is not null or undefined
            assertParamExists('createTexture', 'addTextureDTO', addTextureDTO)
            const localVarPath = `/v1/product/texture`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addTextureDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete3DModel: async (sku: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('delete3DModel', 'sku', sku)
            const localVarPath = `/v1/product/{sku}/3d-model`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {string} layerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete3DProductLayerColor: async (coloredProductId: string, layerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'coloredProductId' is not null or undefined
            assertParamExists('delete3DProductLayerColor', 'coloredProductId', coloredProductId)
            // verify required parameter 'layerId' is not null or undefined
            assertParamExists('delete3DProductLayerColor', 'layerId', layerId)
            const localVarPath = `/v1/product/colored-product/{coloredProductId}/layer/{layerId}`
                .replace(`{${"coloredProductId"}}`, encodeURIComponent(String(coloredProductId)))
                .replace(`{${"layerId"}}`, encodeURIComponent(String(layerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {Array<string>} programProductImageIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMultipleProgramProductImages: async (programId: string, programProductId: string, programProductImageIds: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('deleteMultipleProgramProductImages', 'programId', programId)
            // verify required parameter 'programProductId' is not null or undefined
            assertParamExists('deleteMultipleProgramProductImages', 'programProductId', programProductId)
            // verify required parameter 'programProductImageIds' is not null or undefined
            assertParamExists('deleteMultipleProgramProductImages', 'programProductImageIds', programProductImageIds)
            const localVarPath = `/v1/product/program/{programId}/program-product/{programProductId}/multiple-images`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"programProductId"}}`, encodeURIComponent(String(programProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (programProductImageIds) {
                localVarQueryParameter['programProductImageIds'] = programProductImageIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {string} productImageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductImage: async (coloredProductId: string, productImageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'coloredProductId' is not null or undefined
            assertParamExists('deleteProductImage', 'coloredProductId', coloredProductId)
            // verify required parameter 'productImageId' is not null or undefined
            assertParamExists('deleteProductImage', 'productImageId', productImageId)
            const localVarPath = `/v1/product/color/{coloredProductId}/product-image/{productImageId}`
                .replace(`{${"coloredProductId"}}`, encodeURIComponent(String(coloredProductId)))
                .replace(`{${"productImageId"}}`, encodeURIComponent(String(productImageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} artworkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProgramArtwork: async (programId: string, artworkId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('deleteProgramArtwork', 'programId', programId)
            // verify required parameter 'artworkId' is not null or undefined
            assertParamExists('deleteProgramArtwork', 'artworkId', artworkId)
            const localVarPath = `/v1/product/program/{programId}/artwork/{artworkId}`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"artworkId"}}`, encodeURIComponent(String(artworkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {string} programProductImageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProgramProductImage: async (programId: string, programProductId: string, programProductImageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('deleteProgramProductImage', 'programId', programId)
            // verify required parameter 'programProductId' is not null or undefined
            assertParamExists('deleteProgramProductImage', 'programProductId', programProductId)
            // verify required parameter 'programProductImageId' is not null or undefined
            assertParamExists('deleteProgramProductImage', 'programProductImageId', programProductImageId)
            const localVarPath = `/v1/product/program/{programId}/program-product/{programProductId}/program-product-image/{programProductImageId}`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"programProductId"}}`, encodeURIComponent(String(programProductId)))
                .replace(`{${"programProductImageId"}}`, encodeURIComponent(String(programProductImageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} model3DId 
         * @param {number} [size] 
         * @param {string} [scale] 
         * @param {boolean} [original] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get3DModel: async (model3DId: string, size?: number, scale?: string, original?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'model3DId' is not null or undefined
            assertParamExists('get3DModel', 'model3DId', model3DId)
            const localVarPath = `/v1/product/3d-model/{model3DId}`
                .replace(`{${"model3DId"}}`, encodeURIComponent(String(model3DId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (scale !== undefined) {
                localVarQueryParameter['scale'] = scale;
            }

            if (original !== undefined) {
                localVarQueryParameter['original'] = original;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get3DModelForParentProduct: async (sku: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('get3DModelForParentProduct', 'sku', sku)
            const localVarPath = `/v1/product/{sku}/3d-model`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} model3DId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get3DModelUrl: async (model3DId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'model3DId' is not null or undefined
            assertParamExists('get3DModelUrl', 'model3DId', model3DId)
            const localVarPath = `/v1/product/3d-model/{model3DId}/url`
                .replace(`{${"model3DId"}}`, encodeURIComponent(String(model3DId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get3DProductColorLayers: async (coloredProductId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'coloredProductId' is not null or undefined
            assertParamExists('get3DProductColorLayers', 'coloredProductId', coloredProductId)
            const localVarPath = `/v1/product/colored-product/{coloredProductId}/layers`
                .replace(`{${"coloredProductId"}}`, encodeURIComponent(String(coloredProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programParentProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveProgramProductListForProgramParentProduct: async (programId: string, programParentProductId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getActiveProgramProductListForProgramParentProduct', 'programId', programId)
            // verify required parameter 'programParentProductId' is not null or undefined
            assertParamExists('getActiveProgramProductListForProgramParentProduct', 'programParentProductId', programParentProductId)
            const localVarPath = `/v1/product/program/{programId}/program-parent-product/{programParentProductId}/active-program-products`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"programParentProductId"}}`, encodeURIComponent(String(programParentProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [searchTxt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllColoredProductSettingsOfProgram: async (programId: string, limit?: number, offset?: number, searchTxt?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getAllColoredProductSettingsOfProgram', 'programId', programId)
            const localVarPath = `/v1/product/settings/program/{programId}`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (searchTxt !== undefined) {
                localVarQueryParameter['searchTxt'] = searchTxt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [searchTxt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProgramsWithSpecificProductSettings: async (coloredProductId: string, limit?: number, offset?: number, searchTxt?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'coloredProductId' is not null or undefined
            assertParamExists('getAllProgramsWithSpecificProductSettings', 'coloredProductId', coloredProductId)
            const localVarPath = `/v1/product/settings/{coloredProductId}/programs`
                .replace(`{${"coloredProductId"}}`, encodeURIComponent(String(coloredProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (searchTxt !== undefined) {
                localVarQueryParameter['searchTxt'] = searchTxt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} imageId 
         * @param {number} [size] 
         * @param {string} [scale] 
         * @param {boolean} [original] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtwork: async (programId: string, imageId: string, size?: number, scale?: string, original?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getArtwork', 'programId', programId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('getArtwork', 'imageId', imageId)
            const localVarPath = `/v1/product/program/{programId}/artwork/{imageId}`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (scale !== undefined) {
                localVarQueryParameter['scale'] = scale;
            }

            if (original !== undefined) {
                localVarQueryParameter['original'] = original;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} imageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkUrl: async (programId: string, imageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getArtworkUrl', 'programId', programId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('getArtworkUrl', 'imageId', imageId)
            const localVarPath = `/v1/product/program/{programId}/artwork/{imageId}/url`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [status] 
         * @param {string} [searchTxt] 
         * @param {Array<string>} [categories] 
         * @param {boolean} [isDiscontinued] 
         * @param {boolean} [isRemoved] 
         * @param {boolean} [soldOut] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableRebelProducts: async (limit?: number, offset?: number, status?: string, searchTxt?: string, categories?: Array<string>, isDiscontinued?: boolean, isRemoved?: boolean, soldOut?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/product/system/available-parent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (searchTxt !== undefined) {
                localVarQueryParameter['searchTxt'] = searchTxt;
            }

            if (categories) {
                localVarQueryParameter['categories'] = categories;
            }

            if (isDiscontinued !== undefined) {
                localVarQueryParameter['isDiscontinued'] = isDiscontinued;
            }

            if (isRemoved !== undefined) {
                localVarQueryParameter['isRemoved'] = isRemoved;
            }

            if (soldOut !== undefined) {
                localVarQueryParameter['soldOut'] = soldOut;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCartItemsList: async (programId: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getCartItemsList', 'programId', programId)
            const localVarPath = `/v1/product/program/{programId}/cart/all`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCartProductsQuantityList: async (programId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getCartProductsQuantityList', 'programId', programId)
            const localVarPath = `/v1/product/program/{programId}/cart/products-quantity`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getColoredProduct: async (coloredProductId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'coloredProductId' is not null or undefined
            assertParamExists('getColoredProduct', 'coloredProductId', coloredProductId)
            const localVarPath = `/v1/product/color/{coloredProductId}`
                .replace(`{${"coloredProductId"}}`, encodeURIComponent(String(coloredProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {string} imageId 
         * @param {number} [size] 
         * @param {string} [scale] 
         * @param {boolean} [original] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getColoredProductImage: async (coloredProductId: string, imageId: string, size?: number, scale?: string, original?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'coloredProductId' is not null or undefined
            assertParamExists('getColoredProductImage', 'coloredProductId', coloredProductId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('getColoredProductImage', 'imageId', imageId)
            const localVarPath = `/v1/product/color/{coloredProductId}/product-image/{imageId}`
                .replace(`{${"coloredProductId"}}`, encodeURIComponent(String(coloredProductId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (scale !== undefined) {
                localVarQueryParameter['scale'] = scale;
            }

            if (original !== undefined) {
                localVarQueryParameter['original'] = original;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {string} imageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getColoredProductImagerUrl: async (coloredProductId: string, imageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'coloredProductId' is not null or undefined
            assertParamExists('getColoredProductImagerUrl', 'coloredProductId', coloredProductId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('getColoredProductImagerUrl', 'imageId', imageId)
            const localVarPath = `/v1/product/color/{coloredProductId}/product-image/{imageId}/url`
                .replace(`{${"coloredProductId"}}`, encodeURIComponent(String(coloredProductId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCartSubTotalDetails: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/product/cart/sub-total`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [addressLine1] 
         * @param {string} [city] 
         * @param {string} [zipCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCartSummaryDetails: async (addressLine1?: string, city?: string, zipCode?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/product/cart/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (addressLine1 !== undefined) {
                localVarQueryParameter['addressLine1'] = addressLine1;
            }

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (zipCode !== undefined) {
                localVarQueryParameter['zipCode'] = zipCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoriteProducts: async (programId: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getFavoriteProducts', 'programId', programId)
            const localVarPath = `/v1/product/program/{programId}/favorite-product/all`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalAndCustomProgramProducts: async (programId: string, limit?: number, offset?: number, type?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getGlobalAndCustomProgramProducts', 'programId', programId)
            const localVarPath = `/v1/product/program/{programId}/global-custom-program-products`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMOQAndReceivedOrderQuantityForProgramProduct: async (programId: string, programProductId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getMOQAndReceivedOrderQuantityForProgramProduct', 'programId', programId)
            // verify required parameter 'programProductId' is not null or undefined
            assertParamExists('getMOQAndReceivedOrderQuantityForProgramProduct', 'programProductId', programProductId)
            const localVarPath = `/v1/product/program/{programId}/program-product/{programProductId}/moq-and-received-order-quantity`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"programProductId"}}`, encodeURIComponent(String(programProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentProduct: async (sku: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('getParentProduct', 'sku', sku)
            const localVarPath = `/v1/product/{sku}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentProductForAProgram: async (programId: string, sku: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getParentProductForAProgram', 'programId', programId)
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('getParentProductForAProgram', 'sku', sku)
            const localVarPath = `/v1/product/program/{programId}/sku/{sku}`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentProductLayers: async (sku: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('getParentProductLayers', 'sku', sku)
            const localVarPath = `/v1/product/{sku}/layers`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentProductPublishedColors: async (sku: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('getParentProductPublishedColors', 'sku', sku)
            const localVarPath = `/v1/product/system/sku/{sku}/published-colors`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [searchTxt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentRebelProducts: async (limit?: number, offset?: number, searchTxt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/product/system/all-parent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (searchTxt !== undefined) {
                localVarQueryParameter['searchTxt'] = searchTxt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductCategories: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/product/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programArtworkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramArtworkColors: async (programId: string, programArtworkId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getProgramArtworkColors', 'programId', programId)
            // verify required parameter 'programArtworkId' is not null or undefined
            assertParamExists('getProgramArtworkColors', 'programArtworkId', programArtworkId)
            const localVarPath = `/v1/product/program/{programId}/program-artwork/{programArtworkId}/colors`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"programArtworkId"}}`, encodeURIComponent(String(programArtworkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramArtworkList: async (programId: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getProgramArtworkList', 'programId', programId)
            const localVarPath = `/v1/product/program/{programId}/artwork`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [storeStatus] 
         * @param {string} [nameSearch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramList: async (limit?: number, offset?: number, storeStatus?: string, nameSearch?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/product/programs/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (storeStatus !== undefined) {
                localVarQueryParameter['storeStatus'] = storeStatus;
            }

            if (nameSearch !== undefined) {
                localVarQueryParameter['nameSearch'] = nameSearch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programParentProductId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramParentArtworkList: async (programId: string, programParentProductId: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getProgramParentArtworkList', 'programId', programId)
            // verify required parameter 'programParentProductId' is not null or undefined
            assertParamExists('getProgramParentArtworkList', 'programParentProductId', programParentProductId)
            const localVarPath = `/v1/product/program/{programId}/program-parent-product/{programParentProductId}/artwork`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"programParentProductId"}}`, encodeURIComponent(String(programParentProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} sku 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramParentArtworkListWithProductSku: async (programId: string, sku: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getProgramParentArtworkListWithProductSku', 'programId', programId)
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('getProgramParentArtworkListWithProductSku', 'sku', sku)
            const localVarPath = `/v1/product/program/{programId}/sku/{sku}/artwork`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programParentProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramParentProduct3DModel: async (programId: string, programParentProductId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getProgramParentProduct3DModel', 'programId', programId)
            // verify required parameter 'programParentProductId' is not null or undefined
            assertParamExists('getProgramParentProduct3DModel', 'programParentProductId', programParentProductId)
            const localVarPath = `/v1/product/program/{programId}/program-parent-product/{programParentProductId}/3d-model`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"programParentProductId"}}`, encodeURIComponent(String(programParentProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramParentProductAppliedArtwork: async (programParentProductId: string, programId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programParentProductId' is not null or undefined
            assertParamExists('getProgramParentProductAppliedArtwork', 'programParentProductId', programParentProductId)
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getProgramParentProductAppliedArtwork', 'programId', programId)
            const localVarPath = `/v1/product/program/{programId}/program-parent-product/{programParentProductId}/apply-artwork`
                .replace(`{${"programParentProductId"}}`, encodeURIComponent(String(programParentProductId)))
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} programId 
         * @param {string} boundaryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramParentProductAppliedArtworkForBoundary: async (programParentProductId: string, programId: string, boundaryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programParentProductId' is not null or undefined
            assertParamExists('getProgramParentProductAppliedArtworkForBoundary', 'programParentProductId', programParentProductId)
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getProgramParentProductAppliedArtworkForBoundary', 'programId', programId)
            // verify required parameter 'boundaryId' is not null or undefined
            assertParamExists('getProgramParentProductAppliedArtworkForBoundary', 'boundaryId', boundaryId)
            const localVarPath = `/v1/product/program/{programId}/program-parent-product/{programParentProductId}/boundary/{boundaryId}/applied-artwork`
                .replace(`{${"programParentProductId"}}`, encodeURIComponent(String(programParentProductId)))
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"boundaryId"}}`, encodeURIComponent(String(boundaryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramParentProductDetails: async (programParentProductId: string, programId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programParentProductId' is not null or undefined
            assertParamExists('getProgramParentProductDetails', 'programParentProductId', programParentProductId)
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getProgramParentProductDetails', 'programId', programId)
            const localVarPath = `/v1/product/program/{programId}/program-parent-product/{programParentProductId}`
                .replace(`{${"programParentProductId"}}`, encodeURIComponent(String(programParentProductId)))
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sku 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramParentProductsSkuStatusCount: async (sku: string, programId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('getProgramParentProductsSkuStatusCount', 'sku', sku)
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getProgramParentProductsSkuStatusCount', 'programId', programId)
            const localVarPath = `/v1/product/program/{programId}/program-parent-product/{sku}/status/count`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)))
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramProduct3DModel: async (programId: string, programProductId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getProgramProduct3DModel', 'programId', programId)
            // verify required parameter 'programProductId' is not null or undefined
            assertParamExists('getProgramProduct3DModel', 'programProductId', programProductId)
            const localVarPath = `/v1/product/program/{programId}/program-product/{programProductId}/3d-model`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"programProductId"}}`, encodeURIComponent(String(programProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramProductAvailableColors: async (programId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getProgramProductAvailableColors', 'programId', programId)
            const localVarPath = `/v1/product/program/{programId}/program-product/colors`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramProductAvailableSizes: async (programId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getProgramProductAvailableSizes', 'programId', programId)
            const localVarPath = `/v1/product/program/{programId}/program-product/sizes`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramProductCategories: async (programId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getProgramProductCategories', 'programId', programId)
            const localVarPath = `/v1/product/program/{programId}/program-product/categories`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramProductDetails: async (programId: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getProgramProductDetails', 'programId', programId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProgramProductDetails', 'id', id)
            const localVarPath = `/v1/product/program/{programId}/program-product/{id}/details`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramProductDetailsWithRelatedProgramProducts: async (programId: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getProgramProductDetailsWithRelatedProgramProducts', 'programId', programId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProgramProductDetailsWithRelatedProgramProducts', 'id', id)
            const localVarPath = `/v1/product/program/{programId}/program-product/{id}`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programProductId 
         * @param {string} imageId 
         * @param {number} [size] 
         * @param {string} [scale] 
         * @param {boolean} [original] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramProductImage: async (programProductId: string, imageId: string, size?: number, scale?: string, original?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programProductId' is not null or undefined
            assertParamExists('getProgramProductImage', 'programProductId', programProductId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('getProgramProductImage', 'imageId', imageId)
            const localVarPath = `/v1/product/program-product/{programProductId}/program-product-image/{imageId}`
                .replace(`{${"programProductId"}}`, encodeURIComponent(String(programProductId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (scale !== undefined) {
                localVarQueryParameter['scale'] = scale;
            }

            if (original !== undefined) {
                localVarQueryParameter['original'] = original;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramProductImageList: async (programId: string, programProductId: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getProgramProductImageList', 'programId', programId)
            // verify required parameter 'programProductId' is not null or undefined
            assertParamExists('getProgramProductImageList', 'programProductId', programProductId)
            const localVarPath = `/v1/product/program/{programId}/program-product/{programProductId}/program-product-image`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"programProductId"}}`, encodeURIComponent(String(programProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programProductId 
         * @param {string} imageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramProductImageUrl: async (programProductId: string, imageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programProductId' is not null or undefined
            assertParamExists('getProgramProductImageUrl', 'programProductId', programProductId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('getProgramProductImageUrl', 'imageId', imageId)
            const localVarPath = `/v1/product/program-product/{programProductId}/program-product-image/{imageId}/url`
                .replace(`{${"programProductId"}}`, encodeURIComponent(String(programProductId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programParentProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramProductListForProgramParentProduct: async (programId: string, programParentProductId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getProgramProductListForProgramParentProduct', 'programId', programId)
            // verify required parameter 'programParentProductId' is not null or undefined
            assertParamExists('getProgramProductListForProgramParentProduct', 'programParentProductId', programParentProductId)
            const localVarPath = `/v1/product/program/{programId}/program-parent-product/{programParentProductId}/program-products`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"programParentProductId"}}`, encodeURIComponent(String(programParentProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Array<string>} [categories] 
         * @param {Array<string>} [sizes] 
         * @param {Array<string>} [colors] 
         * @param {number} [minPrice] 
         * @param {number} [maxPrice] 
         * @param {string} [orderByPrice] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramProducts: async (programId: string, limit?: number, offset?: number, categories?: Array<string>, sizes?: Array<string>, colors?: Array<string>, minPrice?: number, maxPrice?: number, orderByPrice?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getProgramProducts', 'programId', programId)
            const localVarPath = `/v1/product/program/{programId}/program-products`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (categories) {
                localVarQueryParameter['categories'] = categories;
            }

            if (sizes) {
                localVarQueryParameter['sizes'] = sizes;
            }

            if (colors) {
                localVarQueryParameter['colors'] = colors;
            }

            if (minPrice !== undefined) {
                localVarQueryParameter['minPrice'] = minPrice;
            }

            if (maxPrice !== undefined) {
                localVarQueryParameter['maxPrice'] = maxPrice;
            }

            if (orderByPrice !== undefined) {
                localVarQueryParameter['orderByPrice'] = orderByPrice;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Array<string>} [categories] 
         * @param {Array<string>} [sizes] 
         * @param {Array<string>} [colors] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicProgramProducts: async (programId: string, limit?: number, offset?: number, categories?: Array<string>, sizes?: Array<string>, colors?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getPublicProgramProducts', 'programId', programId)
            const localVarPath = `/v1/product/program/{programId}/public-program-products`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (categories) {
                localVarQueryParameter['categories'] = categories;
            }

            if (sizes) {
                localVarQueryParameter['sizes'] = sizes;
            }

            if (colors) {
                localVarQueryParameter['colors'] = colors;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Array<string>} [categories] 
         * @param {string} [searchTxt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedRebelProducts: async (limit?: number, offset?: number, categories?: Array<string>, searchTxt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/product/system/published-parent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (categories) {
                localVarQueryParameter['categories'] = categories;
            }

            if (searchTxt !== undefined) {
                localVarQueryParameter['searchTxt'] = searchTxt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Array<string>} [status] 
         * @param {string} [searchTxt] 
         * @param {Array<string>} [categories] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRebelProgramParentProducts: async (programId: string, limit?: number, offset?: number, status?: Array<string>, searchTxt?: string, categories?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getRebelProgramParentProducts', 'programId', programId)
            const localVarPath = `/v1/product/program/{programId}/parent-program-products`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            if (searchTxt !== undefined) {
                localVarQueryParameter['searchTxt'] = searchTxt;
            }

            if (categories) {
                localVarQueryParameter['categories'] = categories;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sizeChartId 
         * @param {number} [size] 
         * @param {string} [scale] 
         * @param {boolean} [original] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSizeChart: async (sizeChartId: string, size?: number, scale?: string, original?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sizeChartId' is not null or undefined
            assertParamExists('getSizeChart', 'sizeChartId', sizeChartId)
            const localVarPath = `/v1/product/size-chart/{sizeChartId}`
                .replace(`{${"sizeChartId"}}`, encodeURIComponent(String(sizeChartId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (scale !== undefined) {
                localVarQueryParameter['scale'] = scale;
            }

            if (original !== undefined) {
                localVarQueryParameter['original'] = original;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sizeChartId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSizeChartUrl: async (sizeChartId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sizeChartId' is not null or undefined
            assertParamExists('getSizeChartUrl', 'sizeChartId', sizeChartId)
            const localVarPath = `/v1/product/size-chart/{sizeChartId}/url`
                .replace(`{${"sizeChartId"}}`, encodeURIComponent(String(sizeChartId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSizeChartUrlbySku: async (sku: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('getSizeChartUrlbySku', 'sku', sku)
            const localVarPath = `/v1/product/{sku}/size-chart/url`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} techPackId 
         * @param {number} [size] 
         * @param {string} [scale] 
         * @param {boolean} [original] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTechPackImage: async (programParentProductId: string, techPackId: string, size?: number, scale?: string, original?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programParentProductId' is not null or undefined
            assertParamExists('getTechPackImage', 'programParentProductId', programParentProductId)
            // verify required parameter 'techPackId' is not null or undefined
            assertParamExists('getTechPackImage', 'techPackId', techPackId)
            const localVarPath = `/v1/product/program-parent-product/{programParentProductId}/tech-pack/{techPackId}`
                .replace(`{${"programParentProductId"}}`, encodeURIComponent(String(programParentProductId)))
                .replace(`{${"techPackId"}}`, encodeURIComponent(String(techPackId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (scale !== undefined) {
                localVarQueryParameter['scale'] = scale;
            }

            if (original !== undefined) {
                localVarQueryParameter['original'] = original;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} techPackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTechPackImageUrl: async (programParentProductId: string, techPackId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programParentProductId' is not null or undefined
            assertParamExists('getTechPackImageUrl', 'programParentProductId', programParentProductId)
            // verify required parameter 'techPackId' is not null or undefined
            assertParamExists('getTechPackImageUrl', 'techPackId', techPackId)
            const localVarPath = `/v1/product/program-parent-product/{programParentProductId}/tech-pack/{techPackId}/url`
                .replace(`{${"programParentProductId"}}`, encodeURIComponent(String(programParentProductId)))
                .replace(`{${"techPackId"}}`, encodeURIComponent(String(techPackId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [programId] 
         * @param {string} [programParentProductId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTechPacks: async (limit?: number, offset?: number, programId?: string, programParentProductId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/product/tech-pack/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (programId !== undefined) {
                localVarQueryParameter['programId'] = programId;
            }

            if (programParentProductId !== undefined) {
                localVarQueryParameter['programParentProductId'] = programParentProductId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTextures: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/product/texture`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalCartItemsCount: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/product/cart/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadedImagesForColoredProduct: async (coloredProductId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'coloredProductId' is not null or undefined
            assertParamExists('getUploadedImagesForColoredProduct', 'coloredProductId', coloredProductId)
            const localVarPath = `/v1/product/color/{coloredProductId}/uploaded-product-images`
                .replace(`{${"coloredProductId"}}`, encodeURIComponent(String(coloredProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markProductAsFavorite: async (programId: string, programProductId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('markProductAsFavorite', 'programId', programId)
            // verify required parameter 'programProductId' is not null or undefined
            assertParamExists('markProductAsFavorite', 'programProductId', programProductId)
            const localVarPath = `/v1/product/program/{programId}/program-product/{programProductId}/favorite`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"programProductId"}}`, encodeURIComponent(String(programProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveColoredProductToDraft: async (coloredProductId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'coloredProductId' is not null or undefined
            assertParamExists('moveColoredProductToDraft', 'coloredProductId', coloredProductId)
            const localVarPath = `/v1/product/color/{coloredProductId}/move-to-draft`
                .replace(`{${"coloredProductId"}}`, encodeURIComponent(String(coloredProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishColoredProduct: async (coloredProductId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'coloredProductId' is not null or undefined
            assertParamExists('publishColoredProduct', 'coloredProductId', coloredProductId)
            const localVarPath = `/v1/product/color/{coloredProductId}/publish`
                .replace(`{${"coloredProductId"}}`, encodeURIComponent(String(coloredProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishParentProduct: async (sku: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('publishParentProduct', 'sku', sku)
            const localVarPath = `/v1/product/{sku}/publish`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishProgramParentProduct: async (programParentProductId: string, programId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programParentProductId' is not null or undefined
            assertParamExists('publishProgramParentProduct', 'programParentProductId', programParentProductId)
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('publishProgramParentProduct', 'programId', programId)
            const localVarPath = `/v1/product/program/{programId}/program-parent-product/{programParentProductId}/publish`
                .replace(`{${"programParentProductId"}}`, encodeURIComponent(String(programParentProductId)))
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} programId 
         * @param {PublishProgramProductsDTO} publishProgramProductsDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishProgramProducts: async (programParentProductId: string, programId: string, publishProgramProductsDTO: PublishProgramProductsDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programParentProductId' is not null or undefined
            assertParamExists('publishProgramProducts', 'programParentProductId', programParentProductId)
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('publishProgramProducts', 'programId', programId)
            // verify required parameter 'publishProgramProductsDTO' is not null or undefined
            assertParamExists('publishProgramProducts', 'publishProgramProductsDTO', publishProgramProductsDTO)
            const localVarPath = `/v1/product/program/{programId}/program-parent-product/{programParentProductId}/publish-program-products`
                .replace(`{${"programParentProductId"}}`, encodeURIComponent(String(programParentProductId)))
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publishProgramProductsDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {string} productImageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePrimaryProductImage: async (coloredProductId: string, productImageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'coloredProductId' is not null or undefined
            assertParamExists('removePrimaryProductImage', 'coloredProductId', coloredProductId)
            // verify required parameter 'productImageId' is not null or undefined
            assertParamExists('removePrimaryProductImage', 'productImageId', productImageId)
            const localVarPath = `/v1/product/color/{coloredProductId}/product-image/{productImageId}/remove-default`
                .replace(`{${"coloredProductId"}}`, encodeURIComponent(String(coloredProductId)))
                .replace(`{${"productImageId"}}`, encodeURIComponent(String(productImageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} cartItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeProductFromCart: async (programId: string, cartItemId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('removeProductFromCart', 'programId', programId)
            // verify required parameter 'cartItemId' is not null or undefined
            assertParamExists('removeProductFromCart', 'cartItemId', cartItemId)
            const localVarPath = `/v1/product/program/{programId}/cart/{cartItemId}`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"cartItemId"}}`, encodeURIComponent(String(cartItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeProductFromFavorites: async (programId: string, programProductId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('removeProductFromFavorites', 'programId', programId)
            // verify required parameter 'programProductId' is not null or undefined
            assertParamExists('removeProductFromFavorites', 'programProductId', programProductId)
            const localVarPath = `/v1/product/program/{programId}/program-product/{programProductId}/un-favorite`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"programProductId"}}`, encodeURIComponent(String(programProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sku 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        save3DModel: async (sku: string, file?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('save3DModel', 'sku', sku)
            const localVarPath = `/v1/product/{sku}/3d-model`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveProductImage: async (coloredProductId: string, file?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'coloredProductId' is not null or undefined
            assertParamExists('saveProductImage', 'coloredProductId', coloredProductId)
            const localVarPath = `/v1/product/color/{coloredProductId}/product-image`
                .replace(`{${"coloredProductId"}}`, encodeURIComponent(String(coloredProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveProductImages: async (coloredProductId: string, files?: Array<any>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'coloredProductId' is not null or undefined
            assertParamExists('saveProductImages', 'coloredProductId', coloredProductId)
            const localVarPath = `/v1/product/color/{coloredProductId}/product-images`
                .replace(`{${"coloredProductId"}}`, encodeURIComponent(String(coloredProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (files) {
                files.forEach((element) => {
                    localVarFormParams.append('files', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sku 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSizeChart: async (sku: string, file?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('saveSizeChart', 'sku', sku)
            const localVarPath = `/v1/product/{sku}/size-chart`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTechPack: async (programParentProductId: string, file?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programParentProductId' is not null or undefined
            assertParamExists('saveTechPack', 'programParentProductId', programParentProductId)
            const localVarPath = `/v1/product/program-parent-product/{programParentProductId}/tech-pack`
                .replace(`{${"programParentProductId"}}`, encodeURIComponent(String(programParentProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programParentProductId 
         * @param {AddProgramProductDTO} addProgramProductDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        selectProgramProduct: async (programId: string, programParentProductId: string, addProgramProductDTO: AddProgramProductDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('selectProgramProduct', 'programId', programId)
            // verify required parameter 'programParentProductId' is not null or undefined
            assertParamExists('selectProgramProduct', 'programParentProductId', programParentProductId)
            // verify required parameter 'addProgramProductDTO' is not null or undefined
            assertParamExists('selectProgramProduct', 'addProgramProductDTO', addProgramProductDTO)
            const localVarPath = `/v1/product/program/{programId}/program-parent-product/{programParentProductId}/program-product`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"programParentProductId"}}`, encodeURIComponent(String(programParentProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addProgramProductDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {string} productImageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPrimaryProductImage: async (coloredProductId: string, productImageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'coloredProductId' is not null or undefined
            assertParamExists('setPrimaryProductImage', 'coloredProductId', coloredProductId)
            // verify required parameter 'productImageId' is not null or undefined
            assertParamExists('setPrimaryProductImage', 'productImageId', productImageId)
            const localVarPath = `/v1/product/color/{coloredProductId}/product-image/{productImageId}/set-default`
                .replace(`{${"coloredProductId"}}`, encodeURIComponent(String(coloredProductId)))
                .replace(`{${"productImageId"}}`, encodeURIComponent(String(productImageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {string} programProductImageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProgramProductImageAsPrimary: async (programId: string, programProductId: string, programProductImageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('setProgramProductImageAsPrimary', 'programId', programId)
            // verify required parameter 'programProductId' is not null or undefined
            assertParamExists('setProgramProductImageAsPrimary', 'programProductId', programProductId)
            // verify required parameter 'programProductImageId' is not null or undefined
            assertParamExists('setProgramProductImageAsPrimary', 'programProductImageId', programProductImageId)
            const localVarPath = `/v1/product/program/{programId}/program-product/{programProductId}/program-product-image/{programProductImageId}/set-primary`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"programProductId"}}`, encodeURIComponent(String(programProductId)))
                .replace(`{${"programProductImageId"}}`, encodeURIComponent(String(programProductImageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProductSyncJob: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/product/sync-product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SwapCategoriesDTO} swapCategoriesDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapCategories: async (swapCategoriesDTO: SwapCategoriesDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'swapCategoriesDTO' is not null or undefined
            assertParamExists('swapCategories', 'swapCategoriesDTO', swapCategoriesDTO)
            const localVarPath = `/v1/product/swap-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(swapCategoriesDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {SwapProgramParentProductsDTO} swapProgramParentProductsDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapProgramParentProducts: async (programId: string, swapProgramParentProductsDTO: SwapProgramParentProductsDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('swapProgramParentProducts', 'programId', programId)
            // verify required parameter 'swapProgramParentProductsDTO' is not null or undefined
            assertParamExists('swapProgramParentProducts', 'swapProgramParentProductsDTO', swapProgramParentProductsDTO)
            const localVarPath = `/v1/product/program/{programId}/swap-program-parent-products`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(swapProgramParentProductsDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SwapSystemProductsDTO} swapSystemProductsDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapSystemProducts: async (swapSystemProductsDTO: SwapSystemProductsDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'swapSystemProductsDTO' is not null or undefined
            assertParamExists('swapSystemProducts', 'swapSystemProductsDTO', swapSystemProductsDTO)
            const localVarPath = `/v1/product/swap-system-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(swapSystemProductsDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublishColoredProduct: async (coloredProductId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'coloredProductId' is not null or undefined
            assertParamExists('unpublishColoredProduct', 'coloredProductId', coloredProductId)
            const localVarPath = `/v1/product/color/{coloredProductId}/unpublish`
                .replace(`{${"coloredProductId"}}`, encodeURIComponent(String(coloredProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublishParentProduct: async (sku: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('unpublishParentProduct', 'sku', sku)
            const localVarPath = `/v1/product/{sku}/unpublish`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublishProgramParentProduct: async (programParentProductId: string, programId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programParentProductId' is not null or undefined
            assertParamExists('unpublishProgramParentProduct', 'programParentProductId', programParentProductId)
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('unpublishProgramParentProduct', 'programId', programId)
            const localVarPath = `/v1/product/program/{programId}/program-parent-product/{programParentProductId}/unpublish`
                .replace(`{${"programParentProductId"}}`, encodeURIComponent(String(programParentProductId)))
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unselectProgramProduct: async (programId: string, programProductId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('unselectProgramProduct', 'programId', programId)
            // verify required parameter 'programProductId' is not null or undefined
            assertParamExists('unselectProgramProduct', 'programProductId', programProductId)
            const localVarPath = `/v1/product/program/{programId}/program-product/{programProductId}`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"programProductId"}}`, encodeURIComponent(String(programProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sku 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update3DModel: async (sku: string, file?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('update3DModel', 'sku', sku)
            const localVarPath = `/v1/product/{sku}/3d-model`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sku 
         * @param {UpdateProductArtworkTypeDTO} updateProductArtworkTypeDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtworkTypeSelection: async (sku: string, updateProductArtworkTypeDTO: UpdateProductArtworkTypeDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('updateArtworkTypeSelection', 'sku', sku)
            // verify required parameter 'updateProductArtworkTypeDTO' is not null or undefined
            assertParamExists('updateArtworkTypeSelection', 'updateProductArtworkTypeDTO', updateProductArtworkTypeDTO)
            const localVarPath = `/v1/product/{sku}/artworkType`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProductArtworkTypeDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} cartItemId 
         * @param {UpdateCartItemDTO} updateCartItemDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCartItem: async (programId: string, cartItemId: string, updateCartItemDTO: UpdateCartItemDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('updateCartItem', 'programId', programId)
            // verify required parameter 'cartItemId' is not null or undefined
            assertParamExists('updateCartItem', 'cartItemId', cartItemId)
            // verify required parameter 'updateCartItemDTO' is not null or undefined
            assertParamExists('updateCartItem', 'updateCartItemDTO', updateCartItemDTO)
            const localVarPath = `/v1/product/program/{programId}/cart/{cartItemId}`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"cartItemId"}}`, encodeURIComponent(String(cartItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCartItemDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sku 
         * @param {UpdateProductDescriptionDTO} updateProductDescriptionDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDescription: async (sku: string, updateProductDescriptionDTO: UpdateProductDescriptionDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('updateDescription', 'sku', sku)
            // verify required parameter 'updateProductDescriptionDTO' is not null or undefined
            assertParamExists('updateDescription', 'updateProductDescriptionDTO', updateProductDescriptionDTO)
            const localVarPath = `/v1/product/{sku}`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProductDescriptionDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sku 
         * @param {UpdateLogoPriceDTO} updateLogoPriceDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLogoPrice: async (sku: string, updateLogoPriceDTO: UpdateLogoPriceDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sku' is not null or undefined
            assertParamExists('updateLogoPrice', 'sku', sku)
            // verify required parameter 'updateLogoPriceDTO' is not null or undefined
            assertParamExists('updateLogoPrice', 'updateLogoPriceDTO', updateLogoPriceDTO)
            const localVarPath = `/v1/product/{sku}/update-logo-price`
                .replace(`{${"sku"}}`, encodeURIComponent(String(sku)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateLogoPriceDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductSettingsForProgram: async (requestBody: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updateProductSettingsForProgram', 'requestBody', requestBody)
            const localVarPath = `/v1/product/settings/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} programId 
         * @param {UpdateProgramParentProductDTO} updateProgramParentProductDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProgramParentProduct: async (programParentProductId: string, programId: string, updateProgramParentProductDTO: UpdateProgramParentProductDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programParentProductId' is not null or undefined
            assertParamExists('updateProgramParentProduct', 'programParentProductId', programParentProductId)
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('updateProgramParentProduct', 'programId', programId)
            // verify required parameter 'updateProgramParentProductDTO' is not null or undefined
            assertParamExists('updateProgramParentProduct', 'updateProgramParentProductDTO', updateProgramParentProductDTO)
            const localVarPath = `/v1/product/program/{programId}/program-parent-product/{programParentProductId}`
                .replace(`{${"programParentProductId"}}`, encodeURIComponent(String(programParentProductId)))
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProgramParentProductDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} programId 
         * @param {UpdateProgramProductColorsDTO} updateProgramProductColorsDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProgramParentProductColors: async (programParentProductId: string, programId: string, updateProgramProductColorsDTO: UpdateProgramProductColorsDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programParentProductId' is not null or undefined
            assertParamExists('updateProgramParentProductColors', 'programParentProductId', programParentProductId)
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('updateProgramParentProductColors', 'programId', programId)
            // verify required parameter 'updateProgramProductColorsDTO' is not null or undefined
            assertParamExists('updateProgramParentProductColors', 'updateProgramProductColorsDTO', updateProgramProductColorsDTO)
            const localVarPath = `/v1/product/program/{programId}/program-parent-product/{programParentProductId}/program-product-colors`
                .replace(`{${"programParentProductId"}}`, encodeURIComponent(String(programParentProductId)))
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProgramProductColorsDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programParentProductId 
         * @param {Array<UpdateProgramProductPriceDTO>} updateProgramProductPriceDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProgramProductPrice: async (programId: string, programParentProductId: string, updateProgramProductPriceDTO: Array<UpdateProgramProductPriceDTO>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('updateProgramProductPrice', 'programId', programId)
            // verify required parameter 'programParentProductId' is not null or undefined
            assertParamExists('updateProgramProductPrice', 'programParentProductId', programParentProductId)
            // verify required parameter 'updateProgramProductPriceDTO' is not null or undefined
            assertParamExists('updateProgramProductPrice', 'updateProgramProductPriceDTO', updateProgramProductPriceDTO)
            const localVarPath = `/v1/product/program/{programId}/program-parent-product/{programParentProductId}/price`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"programParentProductId"}}`, encodeURIComponent(String(programParentProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProgramProductPriceDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {UpdateSwatchColorsDto} updateSwatchColorsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSwatchColors: async (coloredProductId: string, updateSwatchColorsDto: UpdateSwatchColorsDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'coloredProductId' is not null or undefined
            assertParamExists('updateSwatchColors', 'coloredProductId', coloredProductId)
            // verify required parameter 'updateSwatchColorsDto' is not null or undefined
            assertParamExists('updateSwatchColors', 'updateSwatchColorsDto', updateSwatchColorsDto)
            const localVarPath = `/v1/product/color/{coloredProductId}/swatch-colors`
                .replace(`{${"coloredProductId"}}`, encodeURIComponent(String(coloredProductId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSwatchColorsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} coloredProductId 
         * @param {Array<Product3DColorLayerDTO>} product3DColorLayerDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async add3DProductColor(coloredProductId: string, product3DColorLayerDTO: Array<Product3DColorLayerDTO>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.add3DProductColor(coloredProductId, product3DColorLayerDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {Array<string>} [chosenProductImageIds] 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMultipleProgramProductImages(programId: string, programProductId: string, chosenProductImageIds?: Array<string>, files?: Array<any>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMultipleProgramProductImages(programId, programProductId, chosenProductImageIds, files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {AddCartItemDTO} addCartItemDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addProductToCart(programId: string, addCartItemDTO: AddCartItemDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addProductToCart(programId, addCartItemDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {any} [file] 
         * @param {Array<string>} [colors] 
         * @param {number} [sensitivity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addProgramArtwork(programId: string, file?: any, colors?: Array<string>, sensitivity?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addProgramArtwork(programId, file, colors, sensitivity, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addProgramProductImage(programId: string, programProductId: string, file?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addProgramProductImage(programId, programProductId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sku 
         * @param {UpdateProductTextureDTO} updateProductTextureDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addTextureToParentProduct(sku: string, updateProductTextureDTO: UpdateProductTextureDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addTextureToParentProduct(sku, updateProductTextureDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} programId 
         * @param {Array<ApplyArtworkDTO>} applyArtworkDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async applyProgramParentProductArtwork(programParentProductId: string, programId: string, applyArtworkDTO: Array<ApplyArtworkDTO>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.applyProgramParentProductArtwork(programParentProductId, programId, applyArtworkDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sku 
         * @param {string} programId 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewProgramParentProduct(sku: string, programId: string, files?: Array<any>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCreatedIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNewProgramParentProduct(sku, programId, files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sku 
         * @param {string} programId 
         * @param {CreateRebelProgramProductDTO} createRebelProgramProductDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProgramParentProduct(sku: string, programId: string, createRebelProgramProductDTO: CreateRebelProgramProductDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCreatedIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProgramParentProduct(sku, programId, createRebelProgramProductDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {AddTextureDTO} addTextureDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTexture(addTextureDTO: AddTextureDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTexture(addTextureDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete3DModel(sku: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete3DModel(sku, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {string} layerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete3DProductLayerColor(coloredProductId: string, layerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete3DProductLayerColor(coloredProductId, layerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {Array<string>} programProductImageIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMultipleProgramProductImages(programId: string, programProductId: string, programProductImageIds: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMultipleProgramProductImages(programId, programProductId, programProductImageIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {string} productImageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProductImage(coloredProductId: string, productImageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProductImage(coloredProductId, productImageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} artworkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProgramArtwork(programId: string, artworkId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProgramArtwork(programId, artworkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {string} programProductImageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProgramProductImage(programId: string, programProductId: string, programProductImageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProgramProductImage(programId, programProductId, programProductImageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} model3DId 
         * @param {number} [size] 
         * @param {string} [scale] 
         * @param {boolean} [original] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get3DModel(model3DId: string, size?: number, scale?: string, original?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get3DModel(model3DId, size, scale, original, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get3DModelForParentProduct(sku: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get3DModelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get3DModelForParentProduct(sku, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} model3DId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get3DModelUrl(model3DId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetModel3DFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get3DModelUrl(model3DId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get3DProductColorLayers(coloredProductId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProduct3DColorLayersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get3DProductColorLayers(coloredProductId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programParentProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveProgramProductListForProgramParentProduct(programId: string, programParentProductId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetActiveProgramProductListForProgramParentProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveProgramProductListForProgramParentProduct(programId, programParentProductId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [searchTxt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllColoredProductSettingsOfProgram(programId: string, limit?: number, offset?: number, searchTxt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProductSettingsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllColoredProductSettingsOfProgram(programId, limit, offset, searchTxt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [searchTxt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllProgramsWithSpecificProductSettings(coloredProductId: string, limit?: number, offset?: number, searchTxt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramsProductSettingsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllProgramsWithSpecificProductSettings(coloredProductId, limit, offset, searchTxt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} imageId 
         * @param {number} [size] 
         * @param {string} [scale] 
         * @param {boolean} [original] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtwork(programId: string, imageId: string, size?: number, scale?: string, original?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtwork(programId, imageId, size, scale, original, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} imageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtworkUrl(programId: string, imageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramArtworkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtworkUrl(programId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [status] 
         * @param {string} [searchTxt] 
         * @param {Array<string>} [categories] 
         * @param {boolean} [isDiscontinued] 
         * @param {boolean} [isRemoved] 
         * @param {boolean} [soldOut] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableRebelProducts(limit?: number, offset?: number, status?: string, searchTxt?: string, categories?: Array<string>, isDiscontinued?: boolean, isRemoved?: boolean, soldOut?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAvailableRebelProductListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableRebelProducts(limit, offset, status, searchTxt, categories, isDiscontinued, isRemoved, soldOut, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCartItemsList(programId: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCartListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCartItemsList(programId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCartProductsQuantityList(programId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCartProductsQuantityListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCartProductsQuantityList(programId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getColoredProduct(coloredProductId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetColouredProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getColoredProduct(coloredProductId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {string} imageId 
         * @param {number} [size] 
         * @param {string} [scale] 
         * @param {boolean} [original] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getColoredProductImage(coloredProductId: string, imageId: string, size?: number, scale?: string, original?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getColoredProductImage(coloredProductId, imageId, size, scale, original, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {string} imageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getColoredProductImagerUrl(coloredProductId: string, imageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProductImageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getColoredProductImagerUrl(coloredProductId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerCartSubTotalDetails(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomerCartSubTotalDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomerCartSubTotalDetails(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [addressLine1] 
         * @param {string} [city] 
         * @param {string} [zipCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerCartSummaryDetails(addressLine1?: string, city?: string, zipCode?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomerCartSummaryDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomerCartSummaryDetails(addressLine1, city, zipCode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFavoriteProducts(programId: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomerFavoriteProductListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFavoriteProducts(programId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGlobalAndCustomProgramProducts(programId: string, limit?: number, offset?: number, type?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramParentProductListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGlobalAndCustomProgramProducts(programId, limit, offset, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMOQAndReceivedOrderQuantityForProgramProduct(programId: string, programProductId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMinOrderQuantityAndReceivedOrderQuantityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMOQAndReceivedOrderQuantityForProgramProduct(programId, programProductId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParentProduct(sku: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetParentProductDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParentProduct(sku, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParentProductForAProgram(programId: string, sku: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetParentProductDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParentProductForAProgram(programId, sku, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParentProductLayers(sku: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetParentProduct3DColorLayersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParentProductLayers(sku, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParentProductPublishedColors(sku: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMinimalPublishedColoredProductListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParentProductPublishedColors(sku, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [searchTxt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getParentRebelProducts(limit?: number, offset?: number, searchTxt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMinimalParentProductListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getParentRebelProducts(limit, offset, searchTxt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductCategories(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProductCategoryListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductCategories(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programArtworkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramArtworkColors(programId: string, programArtworkId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramArtworkColorListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramArtworkColors(programId, programArtworkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramArtworkList(programId: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramArtworkListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramArtworkList(programId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [storeStatus] 
         * @param {string} [nameSearch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramList(limit?: number, offset?: number, storeStatus?: string, nameSearch?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramsWithProductsCountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramList(limit, offset, storeStatus, nameSearch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programParentProductId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramParentArtworkList(programId: string, programParentProductId: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramArtworkListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramParentArtworkList(programId, programParentProductId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} sku 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramParentArtworkListWithProductSku(programId: string, sku: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramArtworkListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramParentArtworkListWithProductSku(programId, sku, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programParentProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramParentProduct3DModel(programId: string, programParentProductId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramParentProduct3DModelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramParentProduct3DModel(programId, programParentProductId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramParentProductAppliedArtwork(programParentProductId: string, programId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramProductAppliedArtworkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramParentProductAppliedArtwork(programParentProductId, programId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} programId 
         * @param {string} boundaryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramParentProductAppliedArtworkForBoundary(programParentProductId: string, programId: string, boundaryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramProductAppliedArtworkData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramParentProductAppliedArtworkForBoundary(programParentProductId, programId, boundaryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramParentProductDetails(programParentProductId: string, programId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramParentProductDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramParentProductDetails(programParentProductId, programId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sku 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramParentProductsSkuStatusCount(sku: string, programId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramParentProductsSkuStatusCountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramParentProductsSkuStatusCount(sku, programId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramProduct3DModel(programId: string, programProductId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramProduct3DModelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramProduct3DModel(programId, programProductId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramProductAvailableColors(programId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramProductColorListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramProductAvailableColors(programId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramProductAvailableSizes(programId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramProductSizeListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramProductAvailableSizes(programId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramProductCategories(programId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramProductCategoryListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramProductCategories(programId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramProductDetails(programId: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramProductDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramProductDetails(programId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramProductDetailsWithRelatedProgramProducts(programId: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramProductDetailsWithRelatedProgramProducts(programId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programProductId 
         * @param {string} imageId 
         * @param {number} [size] 
         * @param {string} [scale] 
         * @param {boolean} [original] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramProductImage(programProductId: string, imageId: string, size?: number, scale?: string, original?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramProductImage(programProductId, imageId, size, scale, original, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramProductImageList(programId: string, programProductId: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramProductImageListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramProductImageList(programId, programProductId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programProductId 
         * @param {string} imageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramProductImageUrl(programProductId: string, imageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramProductImageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramProductImageUrl(programProductId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programParentProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramProductListForProgramParentProduct(programId: string, programParentProductId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramProductListForProgramParentProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramProductListForProgramParentProduct(programId, programParentProductId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Array<string>} [categories] 
         * @param {Array<string>} [sizes] 
         * @param {Array<string>} [colors] 
         * @param {number} [minPrice] 
         * @param {number} [maxPrice] 
         * @param {string} [orderByPrice] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramProducts(programId: string, limit?: number, offset?: number, categories?: Array<string>, sizes?: Array<string>, colors?: Array<string>, minPrice?: number, maxPrice?: number, orderByPrice?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramParentProductListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramProducts(programId, limit, offset, categories, sizes, colors, minPrice, maxPrice, orderByPrice, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Array<string>} [categories] 
         * @param {Array<string>} [sizes] 
         * @param {Array<string>} [colors] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicProgramProducts(programId: string, limit?: number, offset?: number, categories?: Array<string>, sizes?: Array<string>, colors?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramParentProductListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicProgramProducts(programId, limit, offset, categories, sizes, colors, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Array<string>} [categories] 
         * @param {string} [searchTxt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublishedRebelProducts(limit?: number, offset?: number, categories?: Array<string>, searchTxt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPublishedRebelProductListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublishedRebelProducts(limit, offset, categories, searchTxt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Array<string>} [status] 
         * @param {string} [searchTxt] 
         * @param {Array<string>} [categories] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRebelProgramParentProducts(programId: string, limit?: number, offset?: number, status?: Array<string>, searchTxt?: string, categories?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramParentProductListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRebelProgramParentProducts(programId, limit, offset, status, searchTxt, categories, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sizeChartId 
         * @param {number} [size] 
         * @param {string} [scale] 
         * @param {boolean} [original] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSizeChart(sizeChartId: string, size?: number, scale?: string, original?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSizeChart(sizeChartId, size, scale, original, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sizeChartId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSizeChartUrl(sizeChartId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSizeChartFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSizeChartUrl(sizeChartId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSizeChartUrlbySku(sku: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSizeChartFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSizeChartUrlbySku(sku, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} techPackId 
         * @param {number} [size] 
         * @param {string} [scale] 
         * @param {boolean} [original] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTechPackImage(programParentProductId: string, techPackId: string, size?: number, scale?: string, original?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTechPackImage(programParentProductId, techPackId, size, scale, original, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} techPackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTechPackImageUrl(programParentProductId: string, techPackId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTechPackImageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTechPackImageUrl(programParentProductId, techPackId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [programId] 
         * @param {string} [programParentProductId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTechPacks(limit?: number, offset?: number, programId?: string, programParentProductId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTechPackListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTechPacks(limit, offset, programId, programParentProductId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTextures(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTextureListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTextures(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTotalCartItemsCount(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTotalCartQuantityResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTotalCartItemsCount(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUploadedImagesForColoredProduct(coloredProductId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProductImagesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUploadedImagesForColoredProduct(coloredProductId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markProductAsFavorite(programId: string, programProductId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markProductAsFavorite(programId, programProductId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveColoredProductToDraft(coloredProductId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveColoredProductToDraft(coloredProductId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishColoredProduct(coloredProductId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishColoredProduct(coloredProductId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishParentProduct(sku: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishParentProduct(sku, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishProgramParentProduct(programParentProductId: string, programId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishProgramParentProduct(programParentProductId, programId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} programId 
         * @param {PublishProgramProductsDTO} publishProgramProductsDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishProgramProducts(programParentProductId: string, programId: string, publishProgramProductsDTO: PublishProgramProductsDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishProgramProducts(programParentProductId, programId, publishProgramProductsDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {string} productImageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removePrimaryProductImage(coloredProductId: string, productImageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removePrimaryProductImage(coloredProductId, productImageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} cartItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeProductFromCart(programId: string, cartItemId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeProductFromCart(programId, cartItemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeProductFromFavorites(programId: string, programProductId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeProductFromFavorites(programId, programProductId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sku 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async save3DModel(sku: string, file?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.save3DModel(sku, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveProductImage(coloredProductId: string, file?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveProductImage(coloredProductId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveProductImages(coloredProductId: string, files?: Array<any>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveProductImages(coloredProductId, files, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sku 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveSizeChart(sku: string, file?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveSizeChart(sku, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveTechPack(programParentProductId: string, file?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveTechPack(programParentProductId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programParentProductId 
         * @param {AddProgramProductDTO} addProgramProductDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async selectProgramProduct(programId: string, programParentProductId: string, addProgramProductDTO: AddProgramProductDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCreatedIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.selectProgramProduct(programId, programParentProductId, addProgramProductDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {string} productImageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPrimaryProductImage(coloredProductId: string, productImageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPrimaryProductImage(coloredProductId, productImageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {string} programProductImageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setProgramProductImageAsPrimary(programId: string, programProductId: string, programProductImageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setProgramProductImageAsPrimary(programId, programProductId, programProductImageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startProductSyncJob(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startProductSyncJob(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SwapCategoriesDTO} swapCategoriesDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async swapCategories(swapCategoriesDTO: SwapCategoriesDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.swapCategories(swapCategoriesDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {SwapProgramParentProductsDTO} swapProgramParentProductsDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async swapProgramParentProducts(programId: string, swapProgramParentProductsDTO: SwapProgramParentProductsDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.swapProgramParentProducts(programId, swapProgramParentProductsDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SwapSystemProductsDTO} swapSystemProductsDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async swapSystemProducts(swapSystemProductsDTO: SwapSystemProductsDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.swapSystemProducts(swapSystemProductsDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unpublishColoredProduct(coloredProductId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unpublishColoredProduct(coloredProductId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unpublishParentProduct(sku: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unpublishParentProduct(sku, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unpublishProgramParentProduct(programParentProductId: string, programId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unpublishProgramParentProduct(programParentProductId, programId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unselectProgramProduct(programId: string, programProductId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unselectProgramProduct(programId, programProductId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sku 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update3DModel(sku: string, file?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update3DModel(sku, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sku 
         * @param {UpdateProductArtworkTypeDTO} updateProductArtworkTypeDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateArtworkTypeSelection(sku: string, updateProductArtworkTypeDTO: UpdateProductArtworkTypeDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateArtworkTypeSelection(sku, updateProductArtworkTypeDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} cartItemId 
         * @param {UpdateCartItemDTO} updateCartItemDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCartItem(programId: string, cartItemId: string, updateCartItemDTO: UpdateCartItemDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCartItem(programId, cartItemId, updateCartItemDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sku 
         * @param {UpdateProductDescriptionDTO} updateProductDescriptionDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDescription(sku: string, updateProductDescriptionDTO: UpdateProductDescriptionDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDescription(sku, updateProductDescriptionDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} sku 
         * @param {UpdateLogoPriceDTO} updateLogoPriceDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLogoPrice(sku: string, updateLogoPriceDTO: UpdateLogoPriceDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLogoPrice(sku, updateLogoPriceDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProductSettingsForProgram(requestBody: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProductSettingsForProgram(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} programId 
         * @param {UpdateProgramParentProductDTO} updateProgramParentProductDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProgramParentProduct(programParentProductId: string, programId: string, updateProgramParentProductDTO: UpdateProgramParentProductDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProgramParentProduct(programParentProductId, programId, updateProgramParentProductDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} programId 
         * @param {UpdateProgramProductColorsDTO} updateProgramProductColorsDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProgramParentProductColors(programParentProductId: string, programId: string, updateProgramProductColorsDTO: UpdateProgramProductColorsDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProgramParentProductColors(programParentProductId, programId, updateProgramProductColorsDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programParentProductId 
         * @param {Array<UpdateProgramProductPriceDTO>} updateProgramProductPriceDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProgramProductPrice(programId: string, programParentProductId: string, updateProgramProductPriceDTO: Array<UpdateProgramProductPriceDTO>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProgramProductPrice(programId, programParentProductId, updateProgramProductPriceDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {UpdateSwatchColorsDto} updateSwatchColorsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSwatchColors(coloredProductId: string, updateSwatchColorsDto: UpdateSwatchColorsDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSwatchColors(coloredProductId, updateSwatchColorsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         * 
         * @param {string} coloredProductId 
         * @param {Array<Product3DColorLayerDTO>} product3DColorLayerDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        add3DProductColor(coloredProductId: string, product3DColorLayerDTO: Array<Product3DColorLayerDTO>, options?: any): AxiosPromise<void> {
            return localVarFp.add3DProductColor(coloredProductId, product3DColorLayerDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {Array<string>} [chosenProductImageIds] 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMultipleProgramProductImages(programId: string, programProductId: string, chosenProductImageIds?: Array<string>, files?: Array<any>, options?: any): AxiosPromise<void> {
            return localVarFp.addMultipleProgramProductImages(programId, programProductId, chosenProductImageIds, files, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {AddCartItemDTO} addCartItemDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProductToCart(programId: string, addCartItemDTO: AddCartItemDTO, options?: any): AxiosPromise<void> {
            return localVarFp.addProductToCart(programId, addCartItemDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {any} [file] 
         * @param {Array<string>} [colors] 
         * @param {number} [sensitivity] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProgramArtwork(programId: string, file?: any, colors?: Array<string>, sensitivity?: number, options?: any): AxiosPromise<void> {
            return localVarFp.addProgramArtwork(programId, file, colors, sensitivity, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProgramProductImage(programId: string, programProductId: string, file?: any, options?: any): AxiosPromise<void> {
            return localVarFp.addProgramProductImage(programId, programProductId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sku 
         * @param {UpdateProductTextureDTO} updateProductTextureDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTextureToParentProduct(sku: string, updateProductTextureDTO: UpdateProductTextureDTO, options?: any): AxiosPromise<void> {
            return localVarFp.addTextureToParentProduct(sku, updateProductTextureDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} programId 
         * @param {Array<ApplyArtworkDTO>} applyArtworkDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyProgramParentProductArtwork(programParentProductId: string, programId: string, applyArtworkDTO: Array<ApplyArtworkDTO>, options?: any): AxiosPromise<void> {
            return localVarFp.applyProgramParentProductArtwork(programParentProductId, programId, applyArtworkDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sku 
         * @param {string} programId 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewProgramParentProduct(sku: string, programId: string, files?: Array<any>, options?: any): AxiosPromise<GetCreatedIdResponse> {
            return localVarFp.createNewProgramParentProduct(sku, programId, files, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sku 
         * @param {string} programId 
         * @param {CreateRebelProgramProductDTO} createRebelProgramProductDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProgramParentProduct(sku: string, programId: string, createRebelProgramProductDTO: CreateRebelProgramProductDTO, options?: any): AxiosPromise<GetCreatedIdResponse> {
            return localVarFp.createProgramParentProduct(sku, programId, createRebelProgramProductDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AddTextureDTO} addTextureDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTexture(addTextureDTO: AddTextureDTO, options?: any): AxiosPromise<void> {
            return localVarFp.createTexture(addTextureDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete3DModel(sku: string, options?: any): AxiosPromise<void> {
            return localVarFp.delete3DModel(sku, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {string} layerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete3DProductLayerColor(coloredProductId: string, layerId: string, options?: any): AxiosPromise<void> {
            return localVarFp.delete3DProductLayerColor(coloredProductId, layerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {Array<string>} programProductImageIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMultipleProgramProductImages(programId: string, programProductId: string, programProductImageIds: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMultipleProgramProductImages(programId, programProductId, programProductImageIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {string} productImageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductImage(coloredProductId: string, productImageId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProductImage(coloredProductId, productImageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} artworkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProgramArtwork(programId: string, artworkId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProgramArtwork(programId, artworkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {string} programProductImageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProgramProductImage(programId: string, programProductId: string, programProductImageId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProgramProductImage(programId, programProductId, programProductImageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} model3DId 
         * @param {number} [size] 
         * @param {string} [scale] 
         * @param {boolean} [original] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get3DModel(model3DId: string, size?: number, scale?: string, original?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.get3DModel(model3DId, size, scale, original, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get3DModelForParentProduct(sku: string, options?: any): AxiosPromise<Get3DModelResponse> {
            return localVarFp.get3DModelForParentProduct(sku, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} model3DId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get3DModelUrl(model3DId: string, options?: any): AxiosPromise<GetModel3DFileResponse> {
            return localVarFp.get3DModelUrl(model3DId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get3DProductColorLayers(coloredProductId: string, options?: any): AxiosPromise<GetProduct3DColorLayersResponse> {
            return localVarFp.get3DProductColorLayers(coloredProductId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programParentProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveProgramProductListForProgramParentProduct(programId: string, programParentProductId: string, options?: any): AxiosPromise<GetActiveProgramProductListForProgramParentProductResponse> {
            return localVarFp.getActiveProgramProductListForProgramParentProduct(programId, programParentProductId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [searchTxt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllColoredProductSettingsOfProgram(programId: string, limit?: number, offset?: number, searchTxt?: string, options?: any): AxiosPromise<GetProductSettingsListResponse> {
            return localVarFp.getAllColoredProductSettingsOfProgram(programId, limit, offset, searchTxt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [searchTxt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllProgramsWithSpecificProductSettings(coloredProductId: string, limit?: number, offset?: number, searchTxt?: string, options?: any): AxiosPromise<GetProgramsProductSettingsListResponse> {
            return localVarFp.getAllProgramsWithSpecificProductSettings(coloredProductId, limit, offset, searchTxt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} imageId 
         * @param {number} [size] 
         * @param {string} [scale] 
         * @param {boolean} [original] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtwork(programId: string, imageId: string, size?: number, scale?: string, original?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.getArtwork(programId, imageId, size, scale, original, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} imageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtworkUrl(programId: string, imageId: string, options?: any): AxiosPromise<GetProgramArtworkResponse> {
            return localVarFp.getArtworkUrl(programId, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [status] 
         * @param {string} [searchTxt] 
         * @param {Array<string>} [categories] 
         * @param {boolean} [isDiscontinued] 
         * @param {boolean} [isRemoved] 
         * @param {boolean} [soldOut] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableRebelProducts(limit?: number, offset?: number, status?: string, searchTxt?: string, categories?: Array<string>, isDiscontinued?: boolean, isRemoved?: boolean, soldOut?: boolean, options?: any): AxiosPromise<GetAvailableRebelProductListResponse> {
            return localVarFp.getAvailableRebelProducts(limit, offset, status, searchTxt, categories, isDiscontinued, isRemoved, soldOut, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCartItemsList(programId: string, limit?: number, offset?: number, options?: any): AxiosPromise<GetCartListResponse> {
            return localVarFp.getCartItemsList(programId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCartProductsQuantityList(programId: string, options?: any): AxiosPromise<GetCartProductsQuantityListResponse> {
            return localVarFp.getCartProductsQuantityList(programId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getColoredProduct(coloredProductId: string, options?: any): AxiosPromise<GetColouredProductResponse> {
            return localVarFp.getColoredProduct(coloredProductId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {string} imageId 
         * @param {number} [size] 
         * @param {string} [scale] 
         * @param {boolean} [original] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getColoredProductImage(coloredProductId: string, imageId: string, size?: number, scale?: string, original?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.getColoredProductImage(coloredProductId, imageId, size, scale, original, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {string} imageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getColoredProductImagerUrl(coloredProductId: string, imageId: string, options?: any): AxiosPromise<GetProductImageResponse> {
            return localVarFp.getColoredProductImagerUrl(coloredProductId, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCartSubTotalDetails(options?: any): AxiosPromise<GetCustomerCartSubTotalDetailsResponse> {
            return localVarFp.getCustomerCartSubTotalDetails(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [addressLine1] 
         * @param {string} [city] 
         * @param {string} [zipCode] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerCartSummaryDetails(addressLine1?: string, city?: string, zipCode?: string, options?: any): AxiosPromise<GetCustomerCartSummaryDetailsResponse> {
            return localVarFp.getCustomerCartSummaryDetails(addressLine1, city, zipCode, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFavoriteProducts(programId: string, limit?: number, offset?: number, options?: any): AxiosPromise<GetCustomerFavoriteProductListResponse> {
            return localVarFp.getFavoriteProducts(programId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalAndCustomProgramProducts(programId: string, limit?: number, offset?: number, type?: string, options?: any): AxiosPromise<GetProgramParentProductListResponse> {
            return localVarFp.getGlobalAndCustomProgramProducts(programId, limit, offset, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMOQAndReceivedOrderQuantityForProgramProduct(programId: string, programProductId: string, options?: any): AxiosPromise<GetMinOrderQuantityAndReceivedOrderQuantityResponse> {
            return localVarFp.getMOQAndReceivedOrderQuantityForProgramProduct(programId, programProductId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentProduct(sku: string, options?: any): AxiosPromise<GetParentProductDetailResponse> {
            return localVarFp.getParentProduct(sku, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentProductForAProgram(programId: string, sku: string, options?: any): AxiosPromise<GetParentProductDetailResponse> {
            return localVarFp.getParentProductForAProgram(programId, sku, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentProductLayers(sku: string, options?: any): AxiosPromise<GetParentProduct3DColorLayersResponse> {
            return localVarFp.getParentProductLayers(sku, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentProductPublishedColors(sku: string, options?: any): AxiosPromise<GetMinimalPublishedColoredProductListResponse> {
            return localVarFp.getParentProductPublishedColors(sku, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [searchTxt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentRebelProducts(limit?: number, offset?: number, searchTxt?: string, options?: any): AxiosPromise<GetMinimalParentProductListResponse> {
            return localVarFp.getParentRebelProducts(limit, offset, searchTxt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductCategories(options?: any): AxiosPromise<GetProductCategoryListResponse> {
            return localVarFp.getProductCategories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programArtworkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramArtworkColors(programId: string, programArtworkId: string, options?: any): AxiosPromise<GetProgramArtworkColorListResponse> {
            return localVarFp.getProgramArtworkColors(programId, programArtworkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramArtworkList(programId: string, limit?: number, offset?: number, options?: any): AxiosPromise<GetProgramArtworkListResponse> {
            return localVarFp.getProgramArtworkList(programId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [storeStatus] 
         * @param {string} [nameSearch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramList(limit?: number, offset?: number, storeStatus?: string, nameSearch?: string, options?: any): AxiosPromise<GetProgramsWithProductsCountResponse> {
            return localVarFp.getProgramList(limit, offset, storeStatus, nameSearch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programParentProductId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramParentArtworkList(programId: string, programParentProductId: string, limit?: number, offset?: number, options?: any): AxiosPromise<GetProgramArtworkListResponse> {
            return localVarFp.getProgramParentArtworkList(programId, programParentProductId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} sku 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramParentArtworkListWithProductSku(programId: string, sku: string, limit?: number, offset?: number, options?: any): AxiosPromise<GetProgramArtworkListResponse> {
            return localVarFp.getProgramParentArtworkListWithProductSku(programId, sku, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programParentProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramParentProduct3DModel(programId: string, programParentProductId: string, options?: any): AxiosPromise<GetProgramParentProduct3DModelResponse> {
            return localVarFp.getProgramParentProduct3DModel(programId, programParentProductId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramParentProductAppliedArtwork(programParentProductId: string, programId: string, options?: any): AxiosPromise<GetProgramProductAppliedArtworkResponse> {
            return localVarFp.getProgramParentProductAppliedArtwork(programParentProductId, programId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} programId 
         * @param {string} boundaryId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramParentProductAppliedArtworkForBoundary(programParentProductId: string, programId: string, boundaryId: string, options?: any): AxiosPromise<GetProgramProductAppliedArtworkData> {
            return localVarFp.getProgramParentProductAppliedArtworkForBoundary(programParentProductId, programId, boundaryId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramParentProductDetails(programParentProductId: string, programId: string, options?: any): AxiosPromise<GetProgramParentProductDetailResponse> {
            return localVarFp.getProgramParentProductDetails(programParentProductId, programId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sku 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramParentProductsSkuStatusCount(sku: string, programId: string, options?: any): AxiosPromise<GetProgramParentProductsSkuStatusCountResponse> {
            return localVarFp.getProgramParentProductsSkuStatusCount(sku, programId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramProduct3DModel(programId: string, programProductId: string, options?: any): AxiosPromise<GetProgramProduct3DModelResponse> {
            return localVarFp.getProgramProduct3DModel(programId, programProductId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramProductAvailableColors(programId: string, options?: any): AxiosPromise<GetProgramProductColorListResponse> {
            return localVarFp.getProgramProductAvailableColors(programId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramProductAvailableSizes(programId: string, options?: any): AxiosPromise<GetProgramProductSizeListResponse> {
            return localVarFp.getProgramProductAvailableSizes(programId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramProductCategories(programId: string, options?: any): AxiosPromise<GetProgramProductCategoryListResponse> {
            return localVarFp.getProgramProductCategories(programId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramProductDetails(programId: string, id: string, options?: any): AxiosPromise<GetProgramProductDetailsResponse> {
            return localVarFp.getProgramProductDetails(programId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramProductDetailsWithRelatedProgramProducts(programId: string, id: string, options?: any): AxiosPromise<GetProgramProductResponse> {
            return localVarFp.getProgramProductDetailsWithRelatedProgramProducts(programId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programProductId 
         * @param {string} imageId 
         * @param {number} [size] 
         * @param {string} [scale] 
         * @param {boolean} [original] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramProductImage(programProductId: string, imageId: string, size?: number, scale?: string, original?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.getProgramProductImage(programProductId, imageId, size, scale, original, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramProductImageList(programId: string, programProductId: string, limit?: number, offset?: number, options?: any): AxiosPromise<GetProgramProductImageListResponse> {
            return localVarFp.getProgramProductImageList(programId, programProductId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programProductId 
         * @param {string} imageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramProductImageUrl(programProductId: string, imageId: string, options?: any): AxiosPromise<GetProgramProductImageResponse> {
            return localVarFp.getProgramProductImageUrl(programProductId, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programParentProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramProductListForProgramParentProduct(programId: string, programParentProductId: string, options?: any): AxiosPromise<GetProgramProductListForProgramParentProductResponse> {
            return localVarFp.getProgramProductListForProgramParentProduct(programId, programParentProductId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Array<string>} [categories] 
         * @param {Array<string>} [sizes] 
         * @param {Array<string>} [colors] 
         * @param {number} [minPrice] 
         * @param {number} [maxPrice] 
         * @param {string} [orderByPrice] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramProducts(programId: string, limit?: number, offset?: number, categories?: Array<string>, sizes?: Array<string>, colors?: Array<string>, minPrice?: number, maxPrice?: number, orderByPrice?: string, options?: any): AxiosPromise<GetProgramParentProductListResponse> {
            return localVarFp.getProgramProducts(programId, limit, offset, categories, sizes, colors, minPrice, maxPrice, orderByPrice, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Array<string>} [categories] 
         * @param {Array<string>} [sizes] 
         * @param {Array<string>} [colors] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicProgramProducts(programId: string, limit?: number, offset?: number, categories?: Array<string>, sizes?: Array<string>, colors?: Array<string>, options?: any): AxiosPromise<GetProgramParentProductListResponse> {
            return localVarFp.getPublicProgramProducts(programId, limit, offset, categories, sizes, colors, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Array<string>} [categories] 
         * @param {string} [searchTxt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedRebelProducts(limit?: number, offset?: number, categories?: Array<string>, searchTxt?: string, options?: any): AxiosPromise<GetPublishedRebelProductListResponse> {
            return localVarFp.getPublishedRebelProducts(limit, offset, categories, searchTxt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {Array<string>} [status] 
         * @param {string} [searchTxt] 
         * @param {Array<string>} [categories] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRebelProgramParentProducts(programId: string, limit?: number, offset?: number, status?: Array<string>, searchTxt?: string, categories?: Array<string>, options?: any): AxiosPromise<GetProgramParentProductListResponse> {
            return localVarFp.getRebelProgramParentProducts(programId, limit, offset, status, searchTxt, categories, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sizeChartId 
         * @param {number} [size] 
         * @param {string} [scale] 
         * @param {boolean} [original] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSizeChart(sizeChartId: string, size?: number, scale?: string, original?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.getSizeChart(sizeChartId, size, scale, original, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sizeChartId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSizeChartUrl(sizeChartId: string, options?: any): AxiosPromise<GetSizeChartFileResponse> {
            return localVarFp.getSizeChartUrl(sizeChartId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSizeChartUrlbySku(sku: string, options?: any): AxiosPromise<GetSizeChartFileResponse> {
            return localVarFp.getSizeChartUrlbySku(sku, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} techPackId 
         * @param {number} [size] 
         * @param {string} [scale] 
         * @param {boolean} [original] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTechPackImage(programParentProductId: string, techPackId: string, size?: number, scale?: string, original?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.getTechPackImage(programParentProductId, techPackId, size, scale, original, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} techPackId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTechPackImageUrl(programParentProductId: string, techPackId: string, options?: any): AxiosPromise<GetTechPackImageResponse> {
            return localVarFp.getTechPackImageUrl(programParentProductId, techPackId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [programId] 
         * @param {string} [programParentProductId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTechPacks(limit?: number, offset?: number, programId?: string, programParentProductId?: string, options?: any): AxiosPromise<GetTechPackListResponse> {
            return localVarFp.getTechPacks(limit, offset, programId, programParentProductId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTextures(options?: any): AxiosPromise<GetTextureListResponse> {
            return localVarFp.getTextures(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalCartItemsCount(options?: any): AxiosPromise<GetTotalCartQuantityResponse> {
            return localVarFp.getTotalCartItemsCount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadedImagesForColoredProduct(coloredProductId: string, options?: any): AxiosPromise<GetProductImagesResponse> {
            return localVarFp.getUploadedImagesForColoredProduct(coloredProductId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markProductAsFavorite(programId: string, programProductId: string, options?: any): AxiosPromise<void> {
            return localVarFp.markProductAsFavorite(programId, programProductId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveColoredProductToDraft(coloredProductId: string, options?: any): AxiosPromise<void> {
            return localVarFp.moveColoredProductToDraft(coloredProductId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishColoredProduct(coloredProductId: string, options?: any): AxiosPromise<void> {
            return localVarFp.publishColoredProduct(coloredProductId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishParentProduct(sku: string, options?: any): AxiosPromise<void> {
            return localVarFp.publishParentProduct(sku, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishProgramParentProduct(programParentProductId: string, programId: string, options?: any): AxiosPromise<void> {
            return localVarFp.publishProgramParentProduct(programParentProductId, programId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} programId 
         * @param {PublishProgramProductsDTO} publishProgramProductsDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishProgramProducts(programParentProductId: string, programId: string, publishProgramProductsDTO: PublishProgramProductsDTO, options?: any): AxiosPromise<void> {
            return localVarFp.publishProgramProducts(programParentProductId, programId, publishProgramProductsDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {string} productImageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removePrimaryProductImage(coloredProductId: string, productImageId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removePrimaryProductImage(coloredProductId, productImageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} cartItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeProductFromCart(programId: string, cartItemId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeProductFromCart(programId, cartItemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeProductFromFavorites(programId: string, programProductId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeProductFromFavorites(programId, programProductId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sku 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        save3DModel(sku: string, file?: any, options?: any): AxiosPromise<void> {
            return localVarFp.save3DModel(sku, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveProductImage(coloredProductId: string, file?: any, options?: any): AxiosPromise<void> {
            return localVarFp.saveProductImage(coloredProductId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {Array<any>} [files] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveProductImages(coloredProductId: string, files?: Array<any>, options?: any): AxiosPromise<void> {
            return localVarFp.saveProductImages(coloredProductId, files, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sku 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveSizeChart(sku: string, file?: any, options?: any): AxiosPromise<void> {
            return localVarFp.saveSizeChart(sku, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTechPack(programParentProductId: string, file?: any, options?: any): AxiosPromise<void> {
            return localVarFp.saveTechPack(programParentProductId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programParentProductId 
         * @param {AddProgramProductDTO} addProgramProductDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        selectProgramProduct(programId: string, programParentProductId: string, addProgramProductDTO: AddProgramProductDTO, options?: any): AxiosPromise<GetCreatedIdResponse> {
            return localVarFp.selectProgramProduct(programId, programParentProductId, addProgramProductDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {string} productImageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPrimaryProductImage(coloredProductId: string, productImageId: string, options?: any): AxiosPromise<void> {
            return localVarFp.setPrimaryProductImage(coloredProductId, productImageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {string} programProductImageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProgramProductImageAsPrimary(programId: string, programProductId: string, programProductImageId: string, options?: any): AxiosPromise<void> {
            return localVarFp.setProgramProductImageAsPrimary(programId, programProductId, programProductImageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProductSyncJob(options?: any): AxiosPromise<void> {
            return localVarFp.startProductSyncJob(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SwapCategoriesDTO} swapCategoriesDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapCategories(swapCategoriesDTO: SwapCategoriesDTO, options?: any): AxiosPromise<void> {
            return localVarFp.swapCategories(swapCategoriesDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {SwapProgramParentProductsDTO} swapProgramParentProductsDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapProgramParentProducts(programId: string, swapProgramParentProductsDTO: SwapProgramParentProductsDTO, options?: any): AxiosPromise<void> {
            return localVarFp.swapProgramParentProducts(programId, swapProgramParentProductsDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SwapSystemProductsDTO} swapSystemProductsDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapSystemProducts(swapSystemProductsDTO: SwapSystemProductsDTO, options?: any): AxiosPromise<void> {
            return localVarFp.swapSystemProducts(swapSystemProductsDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublishColoredProduct(coloredProductId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unpublishColoredProduct(coloredProductId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sku 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublishParentProduct(sku: string, options?: any): AxiosPromise<void> {
            return localVarFp.unpublishParentProduct(sku, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublishProgramParentProduct(programParentProductId: string, programId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unpublishProgramParentProduct(programParentProductId, programId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programProductId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unselectProgramProduct(programId: string, programProductId: string, options?: any): AxiosPromise<void> {
            return localVarFp.unselectProgramProduct(programId, programProductId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sku 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update3DModel(sku: string, file?: any, options?: any): AxiosPromise<void> {
            return localVarFp.update3DModel(sku, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sku 
         * @param {UpdateProductArtworkTypeDTO} updateProductArtworkTypeDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtworkTypeSelection(sku: string, updateProductArtworkTypeDTO: UpdateProductArtworkTypeDTO, options?: any): AxiosPromise<void> {
            return localVarFp.updateArtworkTypeSelection(sku, updateProductArtworkTypeDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} cartItemId 
         * @param {UpdateCartItemDTO} updateCartItemDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCartItem(programId: string, cartItemId: string, updateCartItemDTO: UpdateCartItemDTO, options?: any): AxiosPromise<void> {
            return localVarFp.updateCartItem(programId, cartItemId, updateCartItemDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sku 
         * @param {UpdateProductDescriptionDTO} updateProductDescriptionDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDescription(sku: string, updateProductDescriptionDTO: UpdateProductDescriptionDTO, options?: any): AxiosPromise<void> {
            return localVarFp.updateDescription(sku, updateProductDescriptionDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sku 
         * @param {UpdateLogoPriceDTO} updateLogoPriceDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLogoPrice(sku: string, updateLogoPriceDTO: UpdateLogoPriceDTO, options?: any): AxiosPromise<void> {
            return localVarFp.updateLogoPrice(sku, updateLogoPriceDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductSettingsForProgram(requestBody: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.updateProductSettingsForProgram(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} programId 
         * @param {UpdateProgramParentProductDTO} updateProgramParentProductDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProgramParentProduct(programParentProductId: string, programId: string, updateProgramParentProductDTO: UpdateProgramParentProductDTO, options?: any): AxiosPromise<void> {
            return localVarFp.updateProgramParentProduct(programParentProductId, programId, updateProgramParentProductDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programParentProductId 
         * @param {string} programId 
         * @param {UpdateProgramProductColorsDTO} updateProgramProductColorsDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProgramParentProductColors(programParentProductId: string, programId: string, updateProgramProductColorsDTO: UpdateProgramProductColorsDTO, options?: any): AxiosPromise<void> {
            return localVarFp.updateProgramParentProductColors(programParentProductId, programId, updateProgramProductColorsDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} programParentProductId 
         * @param {Array<UpdateProgramProductPriceDTO>} updateProgramProductPriceDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProgramProductPrice(programId: string, programParentProductId: string, updateProgramProductPriceDTO: Array<UpdateProgramProductPriceDTO>, options?: any): AxiosPromise<void> {
            return localVarFp.updateProgramProductPrice(programId, programParentProductId, updateProgramProductPriceDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} coloredProductId 
         * @param {UpdateSwatchColorsDto} updateSwatchColorsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSwatchColors(coloredProductId: string, updateSwatchColorsDto: UpdateSwatchColorsDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateSwatchColors(coloredProductId, updateSwatchColorsDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     * 
     * @param {string} coloredProductId 
     * @param {Array<Product3DColorLayerDTO>} product3DColorLayerDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public add3DProductColor(coloredProductId: string, product3DColorLayerDTO: Array<Product3DColorLayerDTO>, options?: any) {
        return ProductApiFp(this.configuration).add3DProductColor(coloredProductId, product3DColorLayerDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} programProductId 
     * @param {Array<string>} [chosenProductImageIds] 
     * @param {Array<any>} [files] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public addMultipleProgramProductImages(programId: string, programProductId: string, chosenProductImageIds?: Array<string>, files?: Array<any>, options?: any) {
        return ProductApiFp(this.configuration).addMultipleProgramProductImages(programId, programProductId, chosenProductImageIds, files, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {AddCartItemDTO} addCartItemDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public addProductToCart(programId: string, addCartItemDTO: AddCartItemDTO, options?: any) {
        return ProductApiFp(this.configuration).addProductToCart(programId, addCartItemDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {any} [file] 
     * @param {Array<string>} [colors] 
     * @param {number} [sensitivity] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public addProgramArtwork(programId: string, file?: any, colors?: Array<string>, sensitivity?: number, options?: any) {
        return ProductApiFp(this.configuration).addProgramArtwork(programId, file, colors, sensitivity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} programProductId 
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public addProgramProductImage(programId: string, programProductId: string, file?: any, options?: any) {
        return ProductApiFp(this.configuration).addProgramProductImage(programId, programProductId, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sku 
     * @param {UpdateProductTextureDTO} updateProductTextureDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public addTextureToParentProduct(sku: string, updateProductTextureDTO: UpdateProductTextureDTO, options?: any) {
        return ProductApiFp(this.configuration).addTextureToParentProduct(sku, updateProductTextureDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programParentProductId 
     * @param {string} programId 
     * @param {Array<ApplyArtworkDTO>} applyArtworkDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public applyProgramParentProductArtwork(programParentProductId: string, programId: string, applyArtworkDTO: Array<ApplyArtworkDTO>, options?: any) {
        return ProductApiFp(this.configuration).applyProgramParentProductArtwork(programParentProductId, programId, applyArtworkDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sku 
     * @param {string} programId 
     * @param {Array<any>} [files] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public createNewProgramParentProduct(sku: string, programId: string, files?: Array<any>, options?: any) {
        return ProductApiFp(this.configuration).createNewProgramParentProduct(sku, programId, files, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sku 
     * @param {string} programId 
     * @param {CreateRebelProgramProductDTO} createRebelProgramProductDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public createProgramParentProduct(sku: string, programId: string, createRebelProgramProductDTO: CreateRebelProgramProductDTO, options?: any) {
        return ProductApiFp(this.configuration).createProgramParentProduct(sku, programId, createRebelProgramProductDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AddTextureDTO} addTextureDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public createTexture(addTextureDTO: AddTextureDTO, options?: any) {
        return ProductApiFp(this.configuration).createTexture(addTextureDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sku 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public delete3DModel(sku: string, options?: any) {
        return ProductApiFp(this.configuration).delete3DModel(sku, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coloredProductId 
     * @param {string} layerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public delete3DProductLayerColor(coloredProductId: string, layerId: string, options?: any) {
        return ProductApiFp(this.configuration).delete3DProductLayerColor(coloredProductId, layerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} programProductId 
     * @param {Array<string>} programProductImageIds 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public deleteMultipleProgramProductImages(programId: string, programProductId: string, programProductImageIds: Array<string>, options?: any) {
        return ProductApiFp(this.configuration).deleteMultipleProgramProductImages(programId, programProductId, programProductImageIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coloredProductId 
     * @param {string} productImageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public deleteProductImage(coloredProductId: string, productImageId: string, options?: any) {
        return ProductApiFp(this.configuration).deleteProductImage(coloredProductId, productImageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} artworkId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public deleteProgramArtwork(programId: string, artworkId: string, options?: any) {
        return ProductApiFp(this.configuration).deleteProgramArtwork(programId, artworkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} programProductId 
     * @param {string} programProductImageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public deleteProgramProductImage(programId: string, programProductId: string, programProductImageId: string, options?: any) {
        return ProductApiFp(this.configuration).deleteProgramProductImage(programId, programProductId, programProductImageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} model3DId 
     * @param {number} [size] 
     * @param {string} [scale] 
     * @param {boolean} [original] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public get3DModel(model3DId: string, size?: number, scale?: string, original?: boolean, options?: any) {
        return ProductApiFp(this.configuration).get3DModel(model3DId, size, scale, original, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sku 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public get3DModelForParentProduct(sku: string, options?: any) {
        return ProductApiFp(this.configuration).get3DModelForParentProduct(sku, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} model3DId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public get3DModelUrl(model3DId: string, options?: any) {
        return ProductApiFp(this.configuration).get3DModelUrl(model3DId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coloredProductId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public get3DProductColorLayers(coloredProductId: string, options?: any) {
        return ProductApiFp(this.configuration).get3DProductColorLayers(coloredProductId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} programParentProductId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getActiveProgramProductListForProgramParentProduct(programId: string, programParentProductId: string, options?: any) {
        return ProductApiFp(this.configuration).getActiveProgramProductListForProgramParentProduct(programId, programParentProductId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [searchTxt] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getAllColoredProductSettingsOfProgram(programId: string, limit?: number, offset?: number, searchTxt?: string, options?: any) {
        return ProductApiFp(this.configuration).getAllColoredProductSettingsOfProgram(programId, limit, offset, searchTxt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coloredProductId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [searchTxt] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getAllProgramsWithSpecificProductSettings(coloredProductId: string, limit?: number, offset?: number, searchTxt?: string, options?: any) {
        return ProductApiFp(this.configuration).getAllProgramsWithSpecificProductSettings(coloredProductId, limit, offset, searchTxt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} imageId 
     * @param {number} [size] 
     * @param {string} [scale] 
     * @param {boolean} [original] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getArtwork(programId: string, imageId: string, size?: number, scale?: string, original?: boolean, options?: any) {
        return ProductApiFp(this.configuration).getArtwork(programId, imageId, size, scale, original, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} imageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getArtworkUrl(programId: string, imageId: string, options?: any) {
        return ProductApiFp(this.configuration).getArtworkUrl(programId, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [status] 
     * @param {string} [searchTxt] 
     * @param {Array<string>} [categories] 
     * @param {boolean} [isDiscontinued] 
     * @param {boolean} [isRemoved] 
     * @param {boolean} [soldOut] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getAvailableRebelProducts(limit?: number, offset?: number, status?: string, searchTxt?: string, categories?: Array<string>, isDiscontinued?: boolean, isRemoved?: boolean, soldOut?: boolean, options?: any) {
        return ProductApiFp(this.configuration).getAvailableRebelProducts(limit, offset, status, searchTxt, categories, isDiscontinued, isRemoved, soldOut, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getCartItemsList(programId: string, limit?: number, offset?: number, options?: any) {
        return ProductApiFp(this.configuration).getCartItemsList(programId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getCartProductsQuantityList(programId: string, options?: any) {
        return ProductApiFp(this.configuration).getCartProductsQuantityList(programId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coloredProductId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getColoredProduct(coloredProductId: string, options?: any) {
        return ProductApiFp(this.configuration).getColoredProduct(coloredProductId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coloredProductId 
     * @param {string} imageId 
     * @param {number} [size] 
     * @param {string} [scale] 
     * @param {boolean} [original] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getColoredProductImage(coloredProductId: string, imageId: string, size?: number, scale?: string, original?: boolean, options?: any) {
        return ProductApiFp(this.configuration).getColoredProductImage(coloredProductId, imageId, size, scale, original, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coloredProductId 
     * @param {string} imageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getColoredProductImagerUrl(coloredProductId: string, imageId: string, options?: any) {
        return ProductApiFp(this.configuration).getColoredProductImagerUrl(coloredProductId, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getCustomerCartSubTotalDetails(options?: any) {
        return ProductApiFp(this.configuration).getCustomerCartSubTotalDetails(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [addressLine1] 
     * @param {string} [city] 
     * @param {string} [zipCode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getCustomerCartSummaryDetails(addressLine1?: string, city?: string, zipCode?: string, options?: any) {
        return ProductApiFp(this.configuration).getCustomerCartSummaryDetails(addressLine1, city, zipCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getFavoriteProducts(programId: string, limit?: number, offset?: number, options?: any) {
        return ProductApiFp(this.configuration).getFavoriteProducts(programId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [type] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getGlobalAndCustomProgramProducts(programId: string, limit?: number, offset?: number, type?: string, options?: any) {
        return ProductApiFp(this.configuration).getGlobalAndCustomProgramProducts(programId, limit, offset, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} programProductId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getMOQAndReceivedOrderQuantityForProgramProduct(programId: string, programProductId: string, options?: any) {
        return ProductApiFp(this.configuration).getMOQAndReceivedOrderQuantityForProgramProduct(programId, programProductId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sku 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getParentProduct(sku: string, options?: any) {
        return ProductApiFp(this.configuration).getParentProduct(sku, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} sku 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getParentProductForAProgram(programId: string, sku: string, options?: any) {
        return ProductApiFp(this.configuration).getParentProductForAProgram(programId, sku, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sku 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getParentProductLayers(sku: string, options?: any) {
        return ProductApiFp(this.configuration).getParentProductLayers(sku, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sku 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getParentProductPublishedColors(sku: string, options?: any) {
        return ProductApiFp(this.configuration).getParentProductPublishedColors(sku, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [searchTxt] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getParentRebelProducts(limit?: number, offset?: number, searchTxt?: string, options?: any) {
        return ProductApiFp(this.configuration).getParentRebelProducts(limit, offset, searchTxt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProductCategories(options?: any) {
        return ProductApiFp(this.configuration).getProductCategories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} programArtworkId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProgramArtworkColors(programId: string, programArtworkId: string, options?: any) {
        return ProductApiFp(this.configuration).getProgramArtworkColors(programId, programArtworkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProgramArtworkList(programId: string, limit?: number, offset?: number, options?: any) {
        return ProductApiFp(this.configuration).getProgramArtworkList(programId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [storeStatus] 
     * @param {string} [nameSearch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProgramList(limit?: number, offset?: number, storeStatus?: string, nameSearch?: string, options?: any) {
        return ProductApiFp(this.configuration).getProgramList(limit, offset, storeStatus, nameSearch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} programParentProductId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProgramParentArtworkList(programId: string, programParentProductId: string, limit?: number, offset?: number, options?: any) {
        return ProductApiFp(this.configuration).getProgramParentArtworkList(programId, programParentProductId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} sku 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProgramParentArtworkListWithProductSku(programId: string, sku: string, limit?: number, offset?: number, options?: any) {
        return ProductApiFp(this.configuration).getProgramParentArtworkListWithProductSku(programId, sku, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} programParentProductId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProgramParentProduct3DModel(programId: string, programParentProductId: string, options?: any) {
        return ProductApiFp(this.configuration).getProgramParentProduct3DModel(programId, programParentProductId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programParentProductId 
     * @param {string} programId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProgramParentProductAppliedArtwork(programParentProductId: string, programId: string, options?: any) {
        return ProductApiFp(this.configuration).getProgramParentProductAppliedArtwork(programParentProductId, programId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programParentProductId 
     * @param {string} programId 
     * @param {string} boundaryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProgramParentProductAppliedArtworkForBoundary(programParentProductId: string, programId: string, boundaryId: string, options?: any) {
        return ProductApiFp(this.configuration).getProgramParentProductAppliedArtworkForBoundary(programParentProductId, programId, boundaryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programParentProductId 
     * @param {string} programId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProgramParentProductDetails(programParentProductId: string, programId: string, options?: any) {
        return ProductApiFp(this.configuration).getProgramParentProductDetails(programParentProductId, programId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sku 
     * @param {string} programId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProgramParentProductsSkuStatusCount(sku: string, programId: string, options?: any) {
        return ProductApiFp(this.configuration).getProgramParentProductsSkuStatusCount(sku, programId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} programProductId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProgramProduct3DModel(programId: string, programProductId: string, options?: any) {
        return ProductApiFp(this.configuration).getProgramProduct3DModel(programId, programProductId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProgramProductAvailableColors(programId: string, options?: any) {
        return ProductApiFp(this.configuration).getProgramProductAvailableColors(programId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProgramProductAvailableSizes(programId: string, options?: any) {
        return ProductApiFp(this.configuration).getProgramProductAvailableSizes(programId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProgramProductCategories(programId: string, options?: any) {
        return ProductApiFp(this.configuration).getProgramProductCategories(programId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProgramProductDetails(programId: string, id: string, options?: any) {
        return ProductApiFp(this.configuration).getProgramProductDetails(programId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProgramProductDetailsWithRelatedProgramProducts(programId: string, id: string, options?: any) {
        return ProductApiFp(this.configuration).getProgramProductDetailsWithRelatedProgramProducts(programId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programProductId 
     * @param {string} imageId 
     * @param {number} [size] 
     * @param {string} [scale] 
     * @param {boolean} [original] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProgramProductImage(programProductId: string, imageId: string, size?: number, scale?: string, original?: boolean, options?: any) {
        return ProductApiFp(this.configuration).getProgramProductImage(programProductId, imageId, size, scale, original, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} programProductId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProgramProductImageList(programId: string, programProductId: string, limit?: number, offset?: number, options?: any) {
        return ProductApiFp(this.configuration).getProgramProductImageList(programId, programProductId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programProductId 
     * @param {string} imageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProgramProductImageUrl(programProductId: string, imageId: string, options?: any) {
        return ProductApiFp(this.configuration).getProgramProductImageUrl(programProductId, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} programParentProductId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProgramProductListForProgramParentProduct(programId: string, programParentProductId: string, options?: any) {
        return ProductApiFp(this.configuration).getProgramProductListForProgramParentProduct(programId, programParentProductId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {Array<string>} [categories] 
     * @param {Array<string>} [sizes] 
     * @param {Array<string>} [colors] 
     * @param {number} [minPrice] 
     * @param {number} [maxPrice] 
     * @param {string} [orderByPrice] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProgramProducts(programId: string, limit?: number, offset?: number, categories?: Array<string>, sizes?: Array<string>, colors?: Array<string>, minPrice?: number, maxPrice?: number, orderByPrice?: string, options?: any) {
        return ProductApiFp(this.configuration).getProgramProducts(programId, limit, offset, categories, sizes, colors, minPrice, maxPrice, orderByPrice, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {Array<string>} [categories] 
     * @param {Array<string>} [sizes] 
     * @param {Array<string>} [colors] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getPublicProgramProducts(programId: string, limit?: number, offset?: number, categories?: Array<string>, sizes?: Array<string>, colors?: Array<string>, options?: any) {
        return ProductApiFp(this.configuration).getPublicProgramProducts(programId, limit, offset, categories, sizes, colors, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {Array<string>} [categories] 
     * @param {string} [searchTxt] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getPublishedRebelProducts(limit?: number, offset?: number, categories?: Array<string>, searchTxt?: string, options?: any) {
        return ProductApiFp(this.configuration).getPublishedRebelProducts(limit, offset, categories, searchTxt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {Array<string>} [status] 
     * @param {string} [searchTxt] 
     * @param {Array<string>} [categories] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getRebelProgramParentProducts(programId: string, limit?: number, offset?: number, status?: Array<string>, searchTxt?: string, categories?: Array<string>, options?: any) {
        return ProductApiFp(this.configuration).getRebelProgramParentProducts(programId, limit, offset, status, searchTxt, categories, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sizeChartId 
     * @param {number} [size] 
     * @param {string} [scale] 
     * @param {boolean} [original] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getSizeChart(sizeChartId: string, size?: number, scale?: string, original?: boolean, options?: any) {
        return ProductApiFp(this.configuration).getSizeChart(sizeChartId, size, scale, original, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sizeChartId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getSizeChartUrl(sizeChartId: string, options?: any) {
        return ProductApiFp(this.configuration).getSizeChartUrl(sizeChartId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sku 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getSizeChartUrlbySku(sku: string, options?: any) {
        return ProductApiFp(this.configuration).getSizeChartUrlbySku(sku, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programParentProductId 
     * @param {string} techPackId 
     * @param {number} [size] 
     * @param {string} [scale] 
     * @param {boolean} [original] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getTechPackImage(programParentProductId: string, techPackId: string, size?: number, scale?: string, original?: boolean, options?: any) {
        return ProductApiFp(this.configuration).getTechPackImage(programParentProductId, techPackId, size, scale, original, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programParentProductId 
     * @param {string} techPackId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getTechPackImageUrl(programParentProductId: string, techPackId: string, options?: any) {
        return ProductApiFp(this.configuration).getTechPackImageUrl(programParentProductId, techPackId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [programId] 
     * @param {string} [programParentProductId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getTechPacks(limit?: number, offset?: number, programId?: string, programParentProductId?: string, options?: any) {
        return ProductApiFp(this.configuration).getTechPacks(limit, offset, programId, programParentProductId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getTextures(options?: any) {
        return ProductApiFp(this.configuration).getTextures(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getTotalCartItemsCount(options?: any) {
        return ProductApiFp(this.configuration).getTotalCartItemsCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coloredProductId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getUploadedImagesForColoredProduct(coloredProductId: string, options?: any) {
        return ProductApiFp(this.configuration).getUploadedImagesForColoredProduct(coloredProductId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} programProductId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public markProductAsFavorite(programId: string, programProductId: string, options?: any) {
        return ProductApiFp(this.configuration).markProductAsFavorite(programId, programProductId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coloredProductId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public moveColoredProductToDraft(coloredProductId: string, options?: any) {
        return ProductApiFp(this.configuration).moveColoredProductToDraft(coloredProductId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coloredProductId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public publishColoredProduct(coloredProductId: string, options?: any) {
        return ProductApiFp(this.configuration).publishColoredProduct(coloredProductId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sku 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public publishParentProduct(sku: string, options?: any) {
        return ProductApiFp(this.configuration).publishParentProduct(sku, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programParentProductId 
     * @param {string} programId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public publishProgramParentProduct(programParentProductId: string, programId: string, options?: any) {
        return ProductApiFp(this.configuration).publishProgramParentProduct(programParentProductId, programId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programParentProductId 
     * @param {string} programId 
     * @param {PublishProgramProductsDTO} publishProgramProductsDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public publishProgramProducts(programParentProductId: string, programId: string, publishProgramProductsDTO: PublishProgramProductsDTO, options?: any) {
        return ProductApiFp(this.configuration).publishProgramProducts(programParentProductId, programId, publishProgramProductsDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coloredProductId 
     * @param {string} productImageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public removePrimaryProductImage(coloredProductId: string, productImageId: string, options?: any) {
        return ProductApiFp(this.configuration).removePrimaryProductImage(coloredProductId, productImageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} cartItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public removeProductFromCart(programId: string, cartItemId: string, options?: any) {
        return ProductApiFp(this.configuration).removeProductFromCart(programId, cartItemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} programProductId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public removeProductFromFavorites(programId: string, programProductId: string, options?: any) {
        return ProductApiFp(this.configuration).removeProductFromFavorites(programId, programProductId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sku 
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public save3DModel(sku: string, file?: any, options?: any) {
        return ProductApiFp(this.configuration).save3DModel(sku, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coloredProductId 
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public saveProductImage(coloredProductId: string, file?: any, options?: any) {
        return ProductApiFp(this.configuration).saveProductImage(coloredProductId, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coloredProductId 
     * @param {Array<any>} [files] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public saveProductImages(coloredProductId: string, files?: Array<any>, options?: any) {
        return ProductApiFp(this.configuration).saveProductImages(coloredProductId, files, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sku 
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public saveSizeChart(sku: string, file?: any, options?: any) {
        return ProductApiFp(this.configuration).saveSizeChart(sku, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programParentProductId 
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public saveTechPack(programParentProductId: string, file?: any, options?: any) {
        return ProductApiFp(this.configuration).saveTechPack(programParentProductId, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} programParentProductId 
     * @param {AddProgramProductDTO} addProgramProductDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public selectProgramProduct(programId: string, programParentProductId: string, addProgramProductDTO: AddProgramProductDTO, options?: any) {
        return ProductApiFp(this.configuration).selectProgramProduct(programId, programParentProductId, addProgramProductDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coloredProductId 
     * @param {string} productImageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public setPrimaryProductImage(coloredProductId: string, productImageId: string, options?: any) {
        return ProductApiFp(this.configuration).setPrimaryProductImage(coloredProductId, productImageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} programProductId 
     * @param {string} programProductImageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public setProgramProductImageAsPrimary(programId: string, programProductId: string, programProductImageId: string, options?: any) {
        return ProductApiFp(this.configuration).setProgramProductImageAsPrimary(programId, programProductId, programProductImageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public startProductSyncJob(options?: any) {
        return ProductApiFp(this.configuration).startProductSyncJob(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SwapCategoriesDTO} swapCategoriesDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public swapCategories(swapCategoriesDTO: SwapCategoriesDTO, options?: any) {
        return ProductApiFp(this.configuration).swapCategories(swapCategoriesDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {SwapProgramParentProductsDTO} swapProgramParentProductsDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public swapProgramParentProducts(programId: string, swapProgramParentProductsDTO: SwapProgramParentProductsDTO, options?: any) {
        return ProductApiFp(this.configuration).swapProgramParentProducts(programId, swapProgramParentProductsDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SwapSystemProductsDTO} swapSystemProductsDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public swapSystemProducts(swapSystemProductsDTO: SwapSystemProductsDTO, options?: any) {
        return ProductApiFp(this.configuration).swapSystemProducts(swapSystemProductsDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coloredProductId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public unpublishColoredProduct(coloredProductId: string, options?: any) {
        return ProductApiFp(this.configuration).unpublishColoredProduct(coloredProductId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sku 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public unpublishParentProduct(sku: string, options?: any) {
        return ProductApiFp(this.configuration).unpublishParentProduct(sku, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programParentProductId 
     * @param {string} programId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public unpublishProgramParentProduct(programParentProductId: string, programId: string, options?: any) {
        return ProductApiFp(this.configuration).unpublishProgramParentProduct(programParentProductId, programId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} programProductId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public unselectProgramProduct(programId: string, programProductId: string, options?: any) {
        return ProductApiFp(this.configuration).unselectProgramProduct(programId, programProductId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sku 
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public update3DModel(sku: string, file?: any, options?: any) {
        return ProductApiFp(this.configuration).update3DModel(sku, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sku 
     * @param {UpdateProductArtworkTypeDTO} updateProductArtworkTypeDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public updateArtworkTypeSelection(sku: string, updateProductArtworkTypeDTO: UpdateProductArtworkTypeDTO, options?: any) {
        return ProductApiFp(this.configuration).updateArtworkTypeSelection(sku, updateProductArtworkTypeDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} cartItemId 
     * @param {UpdateCartItemDTO} updateCartItemDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public updateCartItem(programId: string, cartItemId: string, updateCartItemDTO: UpdateCartItemDTO, options?: any) {
        return ProductApiFp(this.configuration).updateCartItem(programId, cartItemId, updateCartItemDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sku 
     * @param {UpdateProductDescriptionDTO} updateProductDescriptionDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public updateDescription(sku: string, updateProductDescriptionDTO: UpdateProductDescriptionDTO, options?: any) {
        return ProductApiFp(this.configuration).updateDescription(sku, updateProductDescriptionDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sku 
     * @param {UpdateLogoPriceDTO} updateLogoPriceDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public updateLogoPrice(sku: string, updateLogoPriceDTO: UpdateLogoPriceDTO, options?: any) {
        return ProductApiFp(this.configuration).updateLogoPrice(sku, updateLogoPriceDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public updateProductSettingsForProgram(requestBody: Array<string>, options?: any) {
        return ProductApiFp(this.configuration).updateProductSettingsForProgram(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programParentProductId 
     * @param {string} programId 
     * @param {UpdateProgramParentProductDTO} updateProgramParentProductDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public updateProgramParentProduct(programParentProductId: string, programId: string, updateProgramParentProductDTO: UpdateProgramParentProductDTO, options?: any) {
        return ProductApiFp(this.configuration).updateProgramParentProduct(programParentProductId, programId, updateProgramParentProductDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programParentProductId 
     * @param {string} programId 
     * @param {UpdateProgramProductColorsDTO} updateProgramProductColorsDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public updateProgramParentProductColors(programParentProductId: string, programId: string, updateProgramProductColorsDTO: UpdateProgramProductColorsDTO, options?: any) {
        return ProductApiFp(this.configuration).updateProgramParentProductColors(programParentProductId, programId, updateProgramProductColorsDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} programParentProductId 
     * @param {Array<UpdateProgramProductPriceDTO>} updateProgramProductPriceDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public updateProgramProductPrice(programId: string, programParentProductId: string, updateProgramProductPriceDTO: Array<UpdateProgramProductPriceDTO>, options?: any) {
        return ProductApiFp(this.configuration).updateProgramProductPrice(programId, programParentProductId, updateProgramProductPriceDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} coloredProductId 
     * @param {UpdateSwatchColorsDto} updateSwatchColorsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public updateSwatchColors(coloredProductId: string, updateSwatchColorsDto: UpdateSwatchColorsDto, options?: any) {
        return ProductApiFp(this.configuration).updateSwatchColors(coloredProductId, updateSwatchColorsDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProgramApi - axios parameter creator
 * @export
 */
export const ProgramApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveCustomer: async (programId: string, customerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('approveCustomer', 'programId', programId)
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('approveCustomer', 'customerId', customerId)
            const localVarPath = `/v1/program/{programId}/customer/{customerId}/approve`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelCustomerInvitation: async (programId: string, customerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('cancelCustomerInvitation', 'programId', programId)
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('cancelCustomerInvitation', 'customerId', customerId)
            const localVarPath = `/v1/program/{programId}/customer/{customerId}/cancel-invite`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDomainAvailability: async (domain: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('checkDomainAvailability', 'domain', domain)
            const localVarPath = `/v1/program/store-domain-availability`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (domain !== undefined) {
                localVarQueryParameter['domain'] = domain;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateCustomer: async (programId: string, customerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('deactivateCustomer', 'programId', programId)
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('deactivateCustomer', 'customerId', customerId)
            const localVarPath = `/v1/program/{programId}/customer/{customerId}/deactivate`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateProgram: async (programId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('deactivateProgram', 'programId', programId)
            const localVarPath = `/v1/program/{programId}/deactivate`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineCustomer: async (programId: string, customerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('declineCustomer', 'programId', programId)
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('declineCustomer', 'customerId', customerId)
            const localVarPath = `/v1/program/{programId}/customer/{customerId}/decline`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer: async (programId: string, customerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('deleteCustomer', 'programId', programId)
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('deleteCustomer', 'customerId', customerId)
            const localVarPath = `/v1/program/{programId}/customer/{customerId}/delete`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ExportProgramsDto} exportProgramsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadProgramList: async (exportProgramsDto: ExportProgramsDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'exportProgramsDto' is not null or undefined
            assertParamExists('downloadProgramList', 'exportProgramsDto', exportProgramsDto)
            const localVarPath = `/v1/program/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exportProgramsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} imageId 
         * @param {number} [size] 
         * @param {string} [scale] 
         * @param {boolean} [original] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanner: async (imageId: string, size?: number, scale?: string, original?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('getBanner', 'imageId', imageId)
            const localVarPath = `/v1/program/banner/{imageId}`
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (scale !== undefined) {
                localVarQueryParameter['scale'] = scale;
            }

            if (original !== undefined) {
                localVarQueryParameter['original'] = original;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} imageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBannerUrl: async (imageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('getBannerUrl', 'imageId', imageId)
            const localVarPath = `/v1/program/banner/{imageId}/url`
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBulkUploadHistory: async (programId: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getBulkUploadHistory', 'programId', programId)
            const localVarPath = `/v1/program/{programId}/customer-bulk-upload-history`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} imageId 
         * @param {number} [size] 
         * @param {string} [scale] 
         * @param {boolean} [original] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogo: async (imageId: string, size?: number, scale?: string, original?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('getLogo', 'imageId', imageId)
            const localVarPath = `/v1/program/logo/{imageId}`
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (scale !== undefined) {
                localVarQueryParameter['scale'] = scale;
            }

            if (original !== undefined) {
                localVarQueryParameter['original'] = original;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} imageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogoUrl: async (imageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('getLogoUrl', 'imageId', imageId)
            const localVarPath = `/v1/program/logo/{imageId}/url`
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgram: async (programId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getProgram', 'programId', programId)
            const localVarPath = `/v1/program/{programId}`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramByDomain: async (domain: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('getProgramByDomain', 'domain', domain)
            const localVarPath = `/v1/program/domain-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (domain !== undefined) {
                localVarQueryParameter['domain'] = domain;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramCustomerDetails: async (programId: string, customerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getProgramCustomerDetails', 'programId', programId)
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('getProgramCustomerDetails', 'customerId', customerId)
            const localVarPath = `/v1/program/{programId}/customer/{customerId}`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [status] 
         * @param {string} [searchTxt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramCustomers: async (programId: string, limit?: number, offset?: number, status?: string, searchTxt?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getProgramCustomers', 'programId', programId)
            const localVarPath = `/v1/program/{programId}/customers`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (searchTxt !== undefined) {
                localVarQueryParameter['searchTxt'] = searchTxt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramCustomersCount: async (programId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getProgramCustomersCount', 'programId', programId)
            const localVarPath = `/v1/program/{programId}/customers-count`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [storeStatus] 
         * @param {string} [nameSearch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramList: async (limit?: number, offset?: number, storeStatus?: string, nameSearch?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/program/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (storeStatus !== undefined) {
                localVarQueryParameter['storeStatus'] = storeStatus;
            }

            if (nameSearch !== undefined) {
                localVarQueryParameter['nameSearch'] = nameSearch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramUsersCount: async (programId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getProgramUsersCount', 'programId', programId)
            const localVarPath = `/v1/program/{programId}/users-count`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorePaymentInfo: async (programId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getStorePaymentInfo', 'programId', programId)
            const localVarPath = `/v1/program/{programId}/payment`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} type 
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleBulkCustomersUpdate: async (programId: string, type: string, requestBody: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('handleBulkCustomersUpdate', 'programId', programId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('handleBulkCustomersUpdate', 'type', type)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('handleBulkCustomersUpdate', 'requestBody', requestBody)
            const localVarPath = `/v1/program/{programId}/bulk-customers/{type}`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteCustomer: async (programId: string, customerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('inviteCustomer', 'programId', programId)
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('inviteCustomer', 'customerId', customerId)
            const localVarPath = `/v1/program/{programId}/customer/{customerId}/invite`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {InviteProgramDto} inviteProgramDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteProgram: async (programId: string, inviteProgramDto: InviteProgramDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('inviteProgram', 'programId', programId)
            // verify required parameter 'inviteProgramDto' is not null or undefined
            assertParamExists('inviteProgram', 'inviteProgramDto', inviteProgramDto)
            const localVarPath = `/v1/program/{programId}/invite`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteProgramDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reInviteCustomer: async (programId: string, customerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('reInviteCustomer', 'programId', programId)
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('reInviteCustomer', 'customerId', customerId)
            const localVarPath = `/v1/program/{programId}/customer/{customerId}/re-invite`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reactivateCustomer: async (programId: string, customerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('reactivateCustomer', 'programId', programId)
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('reactivateCustomer', 'customerId', customerId)
            const localVarPath = `/v1/program/{programId}/customer/{customerId}/reactivate`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reactivateProgram: async (programId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('reactivateProgram', 'programId', programId)
            const localVarPath = `/v1/program/{programId}/reactivate`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reinviteProgram: async (programId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('reinviteProgram', 'programId', programId)
            const localVarPath = `/v1/program/{programId}/reinvite`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBanner: async (programId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('removeBanner', 'programId', programId)
            const localVarPath = `/v1/program/{programId}/banner`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProgramSyncJob: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/program/sync-program`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBanner: async (programId: string, file?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('updateBanner', 'programId', programId)
            const localVarPath = `/v1/program/{programId}/banner`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {UpdateBulkShippingAddressDto} updateBulkShippingAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBulkShippingAddress: async (programId: string, updateBulkShippingAddressDto: UpdateBulkShippingAddressDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('updateBulkShippingAddress', 'programId', programId)
            // verify required parameter 'updateBulkShippingAddressDto' is not null or undefined
            assertParamExists('updateBulkShippingAddress', 'updateBulkShippingAddressDto', updateBulkShippingAddressDto)
            const localVarPath = `/v1/program/{programId}/bulk-shipping-address`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateBulkShippingAddressDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {UpdateGlobalShippingDataDTO} updateGlobalShippingDataDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGlobalShippingData: async (programId: string, updateGlobalShippingDataDTO: UpdateGlobalShippingDataDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('updateGlobalShippingData', 'programId', programId)
            // verify required parameter 'updateGlobalShippingDataDTO' is not null or undefined
            assertParamExists('updateGlobalShippingData', 'updateGlobalShippingDataDTO', updateGlobalShippingDataDTO)
            const localVarPath = `/v1/program/{programId}/global-shipping`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateGlobalShippingDataDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLogo: async (programId: string, file?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('updateLogo', 'programId', programId)
            const localVarPath = `/v1/program/{programId}/logo`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {UpdateProgramPaymentDto} updateProgramPaymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentInfo: async (programId: string, updateProgramPaymentDto: UpdateProgramPaymentDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('updatePaymentInfo', 'programId', programId)
            // verify required parameter 'updateProgramPaymentDto' is not null or undefined
            assertParamExists('updatePaymentInfo', 'updateProgramPaymentDto', updateProgramPaymentDto)
            const localVarPath = `/v1/program/{programId}/payment`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProgramPaymentDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {UpdateProgramColorsDto} updateProgramColorsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProgramColors: async (programId: string, updateProgramColorsDto: UpdateProgramColorsDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('updateProgramColors', 'programId', programId)
            // verify required parameter 'updateProgramColorsDto' is not null or undefined
            assertParamExists('updateProgramColors', 'updateProgramColorsDto', updateProgramColorsDto)
            const localVarPath = `/v1/program/{programId}/colors`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProgramColorsDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {UpdateCustomerProfileDto} updateCustomerProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProgramCustomerDetails: async (programId: string, customerId: string, updateCustomerProfileDto: UpdateCustomerProfileDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('updateProgramCustomerDetails', 'programId', programId)
            // verify required parameter 'customerId' is not null or undefined
            assertParamExists('updateProgramCustomerDetails', 'customerId', customerId)
            // verify required parameter 'updateCustomerProfileDto' is not null or undefined
            assertParamExists('updateProgramCustomerDetails', 'updateCustomerProfileDto', updateCustomerProfileDto)
            const localVarPath = `/v1/program/{programId}/customer/{customerId}`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)))
                .replace(`{${"customerId"}}`, encodeURIComponent(String(customerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCustomerProfileDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProgramApi - functional programming interface
 * @export
 */
export const ProgramApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProgramApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveCustomer(programId: string, customerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveCustomer(programId, customerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelCustomerInvitation(programId: string, customerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelCustomerInvitation(programId, customerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkDomainAvailability(domain: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoreDomainAvailabilityReponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkDomainAvailability(domain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateCustomer(programId: string, customerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateCustomer(programId, customerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateProgram(programId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateProgram(programId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async declineCustomer(programId: string, customerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.declineCustomer(programId, customerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomer(programId: string, customerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomer(programId, customerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ExportProgramsDto} exportProgramsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadProgramList(exportProgramsDto: ExportProgramsDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadProgramList(exportProgramsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} imageId 
         * @param {number} [size] 
         * @param {string} [scale] 
         * @param {boolean} [original] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBanner(imageId: string, size?: number, scale?: string, original?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBanner(imageId, size, scale, original, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} imageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBannerUrl(imageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBannerUrl(imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBulkUploadHistory(programId: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomerBulkUploadHistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBulkUploadHistory(programId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} imageId 
         * @param {number} [size] 
         * @param {string} [scale] 
         * @param {boolean} [original] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLogo(imageId: string, size?: number, scale?: string, original?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLogo(imageId, size, scale, original, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} imageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLogoUrl(imageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramFileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLogoUrl(imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgram(programId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgram(programId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramByDomain(domain: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramByDomainResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramByDomain(domain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramCustomerDetails(programId: string, customerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomerProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramCustomerDetails(programId, customerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [status] 
         * @param {string} [searchTxt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramCustomers(programId: string, limit?: number, offset?: number, status?: string, searchTxt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramCustomersListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramCustomers(programId, limit, offset, status, searchTxt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramCustomersCount(programId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomerCountByStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramCustomersCount(programId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [storeStatus] 
         * @param {string} [nameSearch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramList(limit?: number, offset?: number, storeStatus?: string, nameSearch?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramList(limit, offset, storeStatus, nameSearch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramUsersCount(programId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgramUserCountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramUsersCount(programId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStorePaymentInfo(programId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramPaymentInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStorePaymentInfo(programId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} type 
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleBulkCustomersUpdate(programId: string, type: string, requestBody: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomerBulkUpdateFailedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleBulkCustomersUpdate(programId, type, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteCustomer(programId: string, customerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteCustomer(programId, customerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {InviteProgramDto} inviteProgramDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async inviteProgram(programId: string, inviteProgramDto: InviteProgramDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.inviteProgram(programId, inviteProgramDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reInviteCustomer(programId: string, customerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reInviteCustomer(programId, customerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reactivateCustomer(programId: string, customerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reactivateCustomer(programId, customerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reactivateProgram(programId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reactivateProgram(programId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reinviteProgram(programId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reinviteProgram(programId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeBanner(programId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeBanner(programId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startProgramSyncJob(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startProgramSyncJob(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBanner(programId: string, file?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBanner(programId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {UpdateBulkShippingAddressDto} updateBulkShippingAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBulkShippingAddress(programId: string, updateBulkShippingAddressDto: UpdateBulkShippingAddressDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBulkShippingAddress(programId, updateBulkShippingAddressDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {UpdateGlobalShippingDataDTO} updateGlobalShippingDataDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGlobalShippingData(programId: string, updateGlobalShippingDataDTO: UpdateGlobalShippingDataDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGlobalShippingData(programId, updateGlobalShippingDataDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLogo(programId: string, file?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLogo(programId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {UpdateProgramPaymentDto} updateProgramPaymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePaymentInfo(programId: string, updateProgramPaymentDto: UpdateProgramPaymentDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePaymentInfo(programId, updateProgramPaymentDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {UpdateProgramColorsDto} updateProgramColorsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProgramColors(programId: string, updateProgramColorsDto: UpdateProgramColorsDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProgramColors(programId, updateProgramColorsDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {UpdateCustomerProfileDto} updateCustomerProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProgramCustomerDetails(programId: string, customerId: string, updateCustomerProfileDto: UpdateCustomerProfileDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProgramCustomerDetails(programId, customerId, updateCustomerProfileDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProgramApi - factory interface
 * @export
 */
export const ProgramApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProgramApiFp(configuration)
    return {
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveCustomer(programId: string, customerId: string, options?: any): AxiosPromise<void> {
            return localVarFp.approveCustomer(programId, customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelCustomerInvitation(programId: string, customerId: string, options?: any): AxiosPromise<void> {
            return localVarFp.cancelCustomerInvitation(programId, customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkDomainAvailability(domain: string, options?: any): AxiosPromise<StoreDomainAvailabilityReponse> {
            return localVarFp.checkDomainAvailability(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateCustomer(programId: string, customerId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deactivateCustomer(programId, customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateProgram(programId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deactivateProgram(programId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineCustomer(programId: string, customerId: string, options?: any): AxiosPromise<void> {
            return localVarFp.declineCustomer(programId, customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer(programId: string, customerId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCustomer(programId, customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ExportProgramsDto} exportProgramsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadProgramList(exportProgramsDto: ExportProgramsDto, options?: any): AxiosPromise<GetProgramFileResponse> {
            return localVarFp.downloadProgramList(exportProgramsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} imageId 
         * @param {number} [size] 
         * @param {string} [scale] 
         * @param {boolean} [original] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanner(imageId: string, size?: number, scale?: string, original?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.getBanner(imageId, size, scale, original, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} imageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBannerUrl(imageId: string, options?: any): AxiosPromise<GetProgramFileResponse> {
            return localVarFp.getBannerUrl(imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBulkUploadHistory(programId: string, limit?: number, offset?: number, options?: any): AxiosPromise<GetCustomerBulkUploadHistoryResponse> {
            return localVarFp.getBulkUploadHistory(programId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} imageId 
         * @param {number} [size] 
         * @param {string} [scale] 
         * @param {boolean} [original] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogo(imageId: string, size?: number, scale?: string, original?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.getLogo(imageId, size, scale, original, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} imageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogoUrl(imageId: string, options?: any): AxiosPromise<GetProgramFileResponse> {
            return localVarFp.getLogoUrl(imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgram(programId: string, options?: any): AxiosPromise<GetProgramResponse> {
            return localVarFp.getProgram(programId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramByDomain(domain: string, options?: any): AxiosPromise<GetProgramByDomainResponse> {
            return localVarFp.getProgramByDomain(domain, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramCustomerDetails(programId: string, customerId: string, options?: any): AxiosPromise<GetCustomerProfileResponse> {
            return localVarFp.getProgramCustomerDetails(programId, customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [status] 
         * @param {string} [searchTxt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramCustomers(programId: string, limit?: number, offset?: number, status?: string, searchTxt?: string, options?: any): AxiosPromise<GetProgramCustomersListResponse> {
            return localVarFp.getProgramCustomers(programId, limit, offset, status, searchTxt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramCustomersCount(programId: string, options?: any): AxiosPromise<GetCustomerCountByStatusResponse> {
            return localVarFp.getProgramCustomersCount(programId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [storeStatus] 
         * @param {string} [nameSearch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramList(limit?: number, offset?: number, storeStatus?: string, nameSearch?: string, options?: any): AxiosPromise<GetProgramListResponse> {
            return localVarFp.getProgramList(limit, offset, storeStatus, nameSearch, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramUsersCount(programId: string, options?: any): AxiosPromise<ProgramUserCountResponse> {
            return localVarFp.getProgramUsersCount(programId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorePaymentInfo(programId: string, options?: any): AxiosPromise<GetProgramPaymentInfoResponse> {
            return localVarFp.getStorePaymentInfo(programId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} type 
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleBulkCustomersUpdate(programId: string, type: string, requestBody: Array<string>, options?: any): AxiosPromise<GetCustomerBulkUpdateFailedResponse> {
            return localVarFp.handleBulkCustomersUpdate(programId, type, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteCustomer(programId: string, customerId: string, options?: any): AxiosPromise<void> {
            return localVarFp.inviteCustomer(programId, customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {InviteProgramDto} inviteProgramDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteProgram(programId: string, inviteProgramDto: InviteProgramDto, options?: any): AxiosPromise<void> {
            return localVarFp.inviteProgram(programId, inviteProgramDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reInviteCustomer(programId: string, customerId: string, options?: any): AxiosPromise<void> {
            return localVarFp.reInviteCustomer(programId, customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reactivateCustomer(programId: string, customerId: string, options?: any): AxiosPromise<void> {
            return localVarFp.reactivateCustomer(programId, customerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reactivateProgram(programId: string, options?: any): AxiosPromise<void> {
            return localVarFp.reactivateProgram(programId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reinviteProgram(programId: string, options?: any): AxiosPromise<void> {
            return localVarFp.reinviteProgram(programId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBanner(programId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeBanner(programId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProgramSyncJob(options?: any): AxiosPromise<void> {
            return localVarFp.startProgramSyncJob(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBanner(programId: string, file?: any, options?: any): AxiosPromise<void> {
            return localVarFp.updateBanner(programId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {UpdateBulkShippingAddressDto} updateBulkShippingAddressDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBulkShippingAddress(programId: string, updateBulkShippingAddressDto: UpdateBulkShippingAddressDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateBulkShippingAddress(programId, updateBulkShippingAddressDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {UpdateGlobalShippingDataDTO} updateGlobalShippingDataDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGlobalShippingData(programId: string, updateGlobalShippingDataDTO: UpdateGlobalShippingDataDTO, options?: any): AxiosPromise<void> {
            return localVarFp.updateGlobalShippingData(programId, updateGlobalShippingDataDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLogo(programId: string, file?: any, options?: any): AxiosPromise<void> {
            return localVarFp.updateLogo(programId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {UpdateProgramPaymentDto} updateProgramPaymentDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentInfo(programId: string, updateProgramPaymentDto: UpdateProgramPaymentDto, options?: any): AxiosPromise<void> {
            return localVarFp.updatePaymentInfo(programId, updateProgramPaymentDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {UpdateProgramColorsDto} updateProgramColorsDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProgramColors(programId: string, updateProgramColorsDto: UpdateProgramColorsDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateProgramColors(programId, updateProgramColorsDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {string} customerId 
         * @param {UpdateCustomerProfileDto} updateCustomerProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProgramCustomerDetails(programId: string, customerId: string, updateCustomerProfileDto: UpdateCustomerProfileDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateProgramCustomerDetails(programId, customerId, updateCustomerProfileDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProgramApi - object-oriented interface
 * @export
 * @class ProgramApi
 * @extends {BaseAPI}
 */
export class ProgramApi extends BaseAPI {
    /**
     * 
     * @param {string} programId 
     * @param {string} customerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public approveCustomer(programId: string, customerId: string, options?: any) {
        return ProgramApiFp(this.configuration).approveCustomer(programId, customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} customerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public cancelCustomerInvitation(programId: string, customerId: string, options?: any) {
        return ProgramApiFp(this.configuration).cancelCustomerInvitation(programId, customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public checkDomainAvailability(domain: string, options?: any) {
        return ProgramApiFp(this.configuration).checkDomainAvailability(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} customerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public deactivateCustomer(programId: string, customerId: string, options?: any) {
        return ProgramApiFp(this.configuration).deactivateCustomer(programId, customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public deactivateProgram(programId: string, options?: any) {
        return ProgramApiFp(this.configuration).deactivateProgram(programId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} customerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public declineCustomer(programId: string, customerId: string, options?: any) {
        return ProgramApiFp(this.configuration).declineCustomer(programId, customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} customerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public deleteCustomer(programId: string, customerId: string, options?: any) {
        return ProgramApiFp(this.configuration).deleteCustomer(programId, customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExportProgramsDto} exportProgramsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public downloadProgramList(exportProgramsDto: ExportProgramsDto, options?: any) {
        return ProgramApiFp(this.configuration).downloadProgramList(exportProgramsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} imageId 
     * @param {number} [size] 
     * @param {string} [scale] 
     * @param {boolean} [original] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public getBanner(imageId: string, size?: number, scale?: string, original?: boolean, options?: any) {
        return ProgramApiFp(this.configuration).getBanner(imageId, size, scale, original, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} imageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public getBannerUrl(imageId: string, options?: any) {
        return ProgramApiFp(this.configuration).getBannerUrl(imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public getBulkUploadHistory(programId: string, limit?: number, offset?: number, options?: any) {
        return ProgramApiFp(this.configuration).getBulkUploadHistory(programId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} imageId 
     * @param {number} [size] 
     * @param {string} [scale] 
     * @param {boolean} [original] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public getLogo(imageId: string, size?: number, scale?: string, original?: boolean, options?: any) {
        return ProgramApiFp(this.configuration).getLogo(imageId, size, scale, original, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} imageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public getLogoUrl(imageId: string, options?: any) {
        return ProgramApiFp(this.configuration).getLogoUrl(imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public getProgram(programId: string, options?: any) {
        return ProgramApiFp(this.configuration).getProgram(programId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public getProgramByDomain(domain: string, options?: any) {
        return ProgramApiFp(this.configuration).getProgramByDomain(domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} customerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public getProgramCustomerDetails(programId: string, customerId: string, options?: any) {
        return ProgramApiFp(this.configuration).getProgramCustomerDetails(programId, customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [status] 
     * @param {string} [searchTxt] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public getProgramCustomers(programId: string, limit?: number, offset?: number, status?: string, searchTxt?: string, options?: any) {
        return ProgramApiFp(this.configuration).getProgramCustomers(programId, limit, offset, status, searchTxt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public getProgramCustomersCount(programId: string, options?: any) {
        return ProgramApiFp(this.configuration).getProgramCustomersCount(programId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [storeStatus] 
     * @param {string} [nameSearch] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public getProgramList(limit?: number, offset?: number, storeStatus?: string, nameSearch?: string, options?: any) {
        return ProgramApiFp(this.configuration).getProgramList(limit, offset, storeStatus, nameSearch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public getProgramUsersCount(programId: string, options?: any) {
        return ProgramApiFp(this.configuration).getProgramUsersCount(programId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public getStorePaymentInfo(programId: string, options?: any) {
        return ProgramApiFp(this.configuration).getStorePaymentInfo(programId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} type 
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public handleBulkCustomersUpdate(programId: string, type: string, requestBody: Array<string>, options?: any) {
        return ProgramApiFp(this.configuration).handleBulkCustomersUpdate(programId, type, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} customerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public inviteCustomer(programId: string, customerId: string, options?: any) {
        return ProgramApiFp(this.configuration).inviteCustomer(programId, customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {InviteProgramDto} inviteProgramDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public inviteProgram(programId: string, inviteProgramDto: InviteProgramDto, options?: any) {
        return ProgramApiFp(this.configuration).inviteProgram(programId, inviteProgramDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} customerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public reInviteCustomer(programId: string, customerId: string, options?: any) {
        return ProgramApiFp(this.configuration).reInviteCustomer(programId, customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} customerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public reactivateCustomer(programId: string, customerId: string, options?: any) {
        return ProgramApiFp(this.configuration).reactivateCustomer(programId, customerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public reactivateProgram(programId: string, options?: any) {
        return ProgramApiFp(this.configuration).reactivateProgram(programId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public reinviteProgram(programId: string, options?: any) {
        return ProgramApiFp(this.configuration).reinviteProgram(programId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public removeBanner(programId: string, options?: any) {
        return ProgramApiFp(this.configuration).removeBanner(programId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public startProgramSyncJob(options?: any) {
        return ProgramApiFp(this.configuration).startProgramSyncJob(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public updateBanner(programId: string, file?: any, options?: any) {
        return ProgramApiFp(this.configuration).updateBanner(programId, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {UpdateBulkShippingAddressDto} updateBulkShippingAddressDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public updateBulkShippingAddress(programId: string, updateBulkShippingAddressDto: UpdateBulkShippingAddressDto, options?: any) {
        return ProgramApiFp(this.configuration).updateBulkShippingAddress(programId, updateBulkShippingAddressDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {UpdateGlobalShippingDataDTO} updateGlobalShippingDataDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public updateGlobalShippingData(programId: string, updateGlobalShippingDataDTO: UpdateGlobalShippingDataDTO, options?: any) {
        return ProgramApiFp(this.configuration).updateGlobalShippingData(programId, updateGlobalShippingDataDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public updateLogo(programId: string, file?: any, options?: any) {
        return ProgramApiFp(this.configuration).updateLogo(programId, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {UpdateProgramPaymentDto} updateProgramPaymentDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public updatePaymentInfo(programId: string, updateProgramPaymentDto: UpdateProgramPaymentDto, options?: any) {
        return ProgramApiFp(this.configuration).updatePaymentInfo(programId, updateProgramPaymentDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {UpdateProgramColorsDto} updateProgramColorsDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public updateProgramColors(programId: string, updateProgramColorsDto: UpdateProgramColorsDto, options?: any) {
        return ProgramApiFp(this.configuration).updateProgramColors(programId, updateProgramColorsDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {string} customerId 
     * @param {UpdateCustomerProfileDto} updateCustomerProfileDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramApi
     */
    public updateProgramCustomerDetails(programId: string, customerId: string, updateCustomerProfileDto: UpdateCustomerProfileDto, options?: any) {
        return ProgramApiFp(this.configuration).updateProgramCustomerDetails(programId, customerId, updateCustomerProfileDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {Array<CreateOrderReturnReasonDTO>} createOrderReturnReasonDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderReturnReason: async (createOrderReturnReasonDTO: Array<CreateOrderReturnReasonDTO>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrderReturnReasonDTO' is not null or undefined
            assertParamExists('createOrderReturnReason', 'createOrderReturnReasonDTO', createOrderReturnReasonDTO)
            const localVarPath = `/v1/settings/order-return-reason`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrderReturnReasonDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateShippingInfoDTO} createShippingInfoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShipping: async (createShippingInfoDTO: CreateShippingInfoDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createShippingInfoDTO' is not null or undefined
            assertParamExists('createShipping', 'createShippingInfoDTO', createShippingInfoDTO)
            const localVarPath = `/v1/settings/shipping-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createShippingInfoDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateShippingCostDTO} createShippingCostDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShippingCost: async (createShippingCostDTO: CreateShippingCostDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createShippingCostDTO' is not null or undefined
            assertParamExists('createShippingCost', 'createShippingCostDTO', createShippingCostDTO)
            const localVarPath = `/v1/settings/shipping-cost`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createShippingCostDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} shippingCostId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShippingCost: async (shippingCostId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shippingCostId' is not null or undefined
            assertParamExists('deleteShippingCost', 'shippingCostId', shippingCostId)
            const localVarPath = `/v1/settings/shipping-cost/{shippingCostId}`
                .replace(`{${"shippingCostId"}}`, encodeURIComponent(String(shippingCostId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} shippingInfoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShippingInfo: async (shippingInfoId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shippingInfoId' is not null or undefined
            assertParamExists('deleteShippingInfo', 'shippingInfoId', shippingInfoId)
            const localVarPath = `/v1/settings/shipping-info/{shippingInfoId}`
                .replace(`{${"shippingInfoId"}}`, encodeURIComponent(String(shippingInfoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllParentOrderReturnReasons: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/settings/parent-order-return-reason`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllShippingCost: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/settings/shipping-cost`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllShippingInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/settings/shipping-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} orderTotal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShippingCost: async (orderTotal: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderTotal' is not null or undefined
            assertParamExists('getShippingCost', 'orderTotal', orderTotal)
            const localVarPath = `/v1/settings/shipping-cost/{orderTotal}`
                .replace(`{${"orderTotal"}}`, encodeURIComponent(String(orderTotal)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} shippingInfoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShippingInfo: async (shippingInfoId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shippingInfoId' is not null or undefined
            assertParamExists('getShippingInfo', 'shippingInfoId', shippingInfoId)
            const localVarPath = `/v1/settings/shipping-info/{shippingInfoId}`
                .replace(`{${"shippingInfoId"}}`, encodeURIComponent(String(shippingInfoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateSystemVariablesDTO} updateSystemVariablesDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSystemVariables: async (updateSystemVariablesDTO: UpdateSystemVariablesDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateSystemVariablesDTO' is not null or undefined
            assertParamExists('updateSystemVariables', 'updateSystemVariablesDTO', updateSystemVariablesDTO)
            const localVarPath = `/v1/settings/system-variables`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSystemVariablesDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {Array<CreateOrderReturnReasonDTO>} createOrderReturnReasonDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrderReturnReason(createOrderReturnReasonDTO: Array<CreateOrderReturnReasonDTO>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrderReturnReason(createOrderReturnReasonDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateShippingInfoDTO} createShippingInfoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createShipping(createShippingInfoDTO: CreateShippingInfoDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createShipping(createShippingInfoDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateShippingCostDTO} createShippingCostDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createShippingCost(createShippingCostDTO: CreateShippingCostDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createShippingCost(createShippingCostDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} shippingCostId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteShippingCost(shippingCostId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteShippingCost(shippingCostId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} shippingInfoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteShippingInfo(shippingInfoId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteShippingInfo(shippingInfoId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllParentOrderReturnReasons(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetParentOrderReturnReasonListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllParentOrderReturnReasons(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllShippingCost(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetShippingCostListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllShippingCost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllShippingInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetShippingInfoListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllShippingInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} orderTotal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShippingCost(orderTotal: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetShippingCostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShippingCost(orderTotal, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} shippingInfoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getShippingInfo(shippingInfoId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetShippingInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getShippingInfo(shippingInfoId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpdateSystemVariablesDTO} updateSystemVariablesDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSystemVariables(updateSystemVariablesDTO: UpdateSystemVariablesDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSystemVariables(updateSystemVariablesDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsApiFp(configuration)
    return {
        /**
         * 
         * @param {Array<CreateOrderReturnReasonDTO>} createOrderReturnReasonDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrderReturnReason(createOrderReturnReasonDTO: Array<CreateOrderReturnReasonDTO>, options?: any): AxiosPromise<void> {
            return localVarFp.createOrderReturnReason(createOrderReturnReasonDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateShippingInfoDTO} createShippingInfoDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShipping(createShippingInfoDTO: CreateShippingInfoDTO, options?: any): AxiosPromise<void> {
            return localVarFp.createShipping(createShippingInfoDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateShippingCostDTO} createShippingCostDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShippingCost(createShippingCostDTO: CreateShippingCostDTO, options?: any): AxiosPromise<void> {
            return localVarFp.createShippingCost(createShippingCostDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} shippingCostId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShippingCost(shippingCostId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteShippingCost(shippingCostId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} shippingInfoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteShippingInfo(shippingInfoId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteShippingInfo(shippingInfoId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllParentOrderReturnReasons(options?: any): AxiosPromise<GetParentOrderReturnReasonListResponse> {
            return localVarFp.getAllParentOrderReturnReasons(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllShippingCost(options?: any): AxiosPromise<GetShippingCostListResponse> {
            return localVarFp.getAllShippingCost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllShippingInfo(options?: any): AxiosPromise<GetShippingInfoListResponse> {
            return localVarFp.getAllShippingInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} orderTotal 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShippingCost(orderTotal: number, options?: any): AxiosPromise<GetShippingCostResponse> {
            return localVarFp.getShippingCost(orderTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} shippingInfoId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getShippingInfo(shippingInfoId: string, options?: any): AxiosPromise<GetShippingInfoResponse> {
            return localVarFp.getShippingInfo(shippingInfoId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateSystemVariablesDTO} updateSystemVariablesDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSystemVariables(updateSystemVariablesDTO: UpdateSystemVariablesDTO, options?: any): AxiosPromise<void> {
            return localVarFp.updateSystemVariables(updateSystemVariablesDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
    /**
     * 
     * @param {Array<CreateOrderReturnReasonDTO>} createOrderReturnReasonDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public createOrderReturnReason(createOrderReturnReasonDTO: Array<CreateOrderReturnReasonDTO>, options?: any) {
        return SettingsApiFp(this.configuration).createOrderReturnReason(createOrderReturnReasonDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateShippingInfoDTO} createShippingInfoDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public createShipping(createShippingInfoDTO: CreateShippingInfoDTO, options?: any) {
        return SettingsApiFp(this.configuration).createShipping(createShippingInfoDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateShippingCostDTO} createShippingCostDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public createShippingCost(createShippingCostDTO: CreateShippingCostDTO, options?: any) {
        return SettingsApiFp(this.configuration).createShippingCost(createShippingCostDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} shippingCostId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public deleteShippingCost(shippingCostId: string, options?: any) {
        return SettingsApiFp(this.configuration).deleteShippingCost(shippingCostId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} shippingInfoId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public deleteShippingInfo(shippingInfoId: string, options?: any) {
        return SettingsApiFp(this.configuration).deleteShippingInfo(shippingInfoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public getAllParentOrderReturnReasons(options?: any) {
        return SettingsApiFp(this.configuration).getAllParentOrderReturnReasons(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public getAllShippingCost(options?: any) {
        return SettingsApiFp(this.configuration).getAllShippingCost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public getAllShippingInfo(options?: any) {
        return SettingsApiFp(this.configuration).getAllShippingInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} orderTotal 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public getShippingCost(orderTotal: number, options?: any) {
        return SettingsApiFp(this.configuration).getShippingCost(orderTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} shippingInfoId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public getShippingInfo(shippingInfoId: string, options?: any) {
        return SettingsApiFp(this.configuration).getShippingInfo(shippingInfoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateSystemVariablesDTO} updateSystemVariablesDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public updateSystemVariables(updateSystemVariablesDTO: UpdateSystemVariablesDTO, options?: any) {
        return SettingsApiFp(this.configuration).updateSystemVariables(updateSystemVariablesDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateUser: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deactivateUser', 'userId', userId)
            const localVarPath = `/v1/user/{userId}/deactivate`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerStoreCredits: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user/store-credits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyProfile: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getProfile', 'userId', userId)
            const localVarPath = `/v1/user/profile/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} limit 
         * @param {number} offset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramAdminList: async (programId: string, limit: number, offset: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'programId' is not null or undefined
            assertParamExists('getProgramAdminList', 'programId', programId)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getProgramAdminList', 'limit', limit)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('getProgramAdminList', 'offset', offset)
            const localVarPath = `/v1/user/program-admins/{programId}`
                .replace(`{${"programId"}}`, encodeURIComponent(String(programId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRebelAdminList: async (limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/user/rebel-admins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateMyProfileDto} updateMyProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMyProfile: async (updateMyProfileDto: UpdateMyProfileDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateMyProfileDto' is not null or undefined
            assertParamExists('updateMyProfile', 'updateMyProfileDto', updateMyProfileDto)
            const localVarPath = `/v1/user/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMyProfileDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {UpdateUserProfileDto} updateUserProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOtherProfile: async (userId: string, updateUserProfileDto: UpdateUserProfileDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateOtherProfile', 'userId', userId)
            // verify required parameter 'updateUserProfileDto' is not null or undefined
            assertParamExists('updateOtherProfile', 'updateUserProfileDto', updateUserProfileDto)
            const localVarPath = `/v1/user/profile/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserProfileDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateUser(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateUser(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerStoreCredits(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStoreCreditsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomerStoreCredits(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMyProfile(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMyProfile(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfile(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfile(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} limit 
         * @param {number} offset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProgramAdminList(programId: string, limit: number, offset: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProgramAdminListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProgramAdminList(programId, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRebelAdminList(limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAdminListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRebelAdminList(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpdateMyProfileDto} updateMyProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMyProfile(updateMyProfileDto: UpdateMyProfileDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMyProfile(updateMyProfileDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} userId 
         * @param {UpdateUserProfileDto} updateUserProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOtherProfile(userId: string, updateUserProfileDto: UpdateUserProfileDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOtherProfile(userId, updateUserProfileDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateUser(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deactivateUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerStoreCredits(options?: any): AxiosPromise<GetStoreCreditsResponse> {
            return localVarFp.getCustomerStoreCredits(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMyProfile(options?: any): AxiosPromise<GetProfileResponse> {
            return localVarFp.getMyProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfile(userId: string, options?: any): AxiosPromise<GetProfileResponse> {
            return localVarFp.getProfile(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} programId 
         * @param {number} limit 
         * @param {number} offset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProgramAdminList(programId: string, limit: number, offset: number, options?: any): AxiosPromise<GetProgramAdminListResponse> {
            return localVarFp.getProgramAdminList(programId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRebelAdminList(limit?: number, offset?: number, options?: any): AxiosPromise<GetAdminListResponse> {
            return localVarFp.getRebelAdminList(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateMyProfileDto} updateMyProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMyProfile(updateMyProfileDto: UpdateMyProfileDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateMyProfile(updateMyProfileDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {UpdateUserProfileDto} updateUserProfileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOtherProfile(userId: string, updateUserProfileDto: UpdateUserProfileDto, options?: any): AxiosPromise<void> {
            return localVarFp.updateOtherProfile(userId, updateUserProfileDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deactivateUser(userId: string, options?: any) {
        return UserApiFp(this.configuration).deactivateUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getCustomerStoreCredits(options?: any) {
        return UserApiFp(this.configuration).getCustomerStoreCredits(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getMyProfile(options?: any) {
        return UserApiFp(this.configuration).getMyProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getProfile(userId: string, options?: any) {
        return UserApiFp(this.configuration).getProfile(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} programId 
     * @param {number} limit 
     * @param {number} offset 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getProgramAdminList(programId: string, limit: number, offset: number, options?: any) {
        return UserApiFp(this.configuration).getProgramAdminList(programId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getRebelAdminList(limit?: number, offset?: number, options?: any) {
        return UserApiFp(this.configuration).getRebelAdminList(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateMyProfileDto} updateMyProfileDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateMyProfile(updateMyProfileDto: UpdateMyProfileDto, options?: any) {
        return UserApiFp(this.configuration).updateMyProfile(updateMyProfileDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {UpdateUserProfileDto} updateUserProfileDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateOtherProfile(userId: string, updateUserProfileDto: UpdateUserProfileDto, options?: any) {
        return UserApiFp(this.configuration).updateOtherProfile(userId, updateUserProfileDto, options).then((request) => request(this.axios, this.basePath));
    }
}


